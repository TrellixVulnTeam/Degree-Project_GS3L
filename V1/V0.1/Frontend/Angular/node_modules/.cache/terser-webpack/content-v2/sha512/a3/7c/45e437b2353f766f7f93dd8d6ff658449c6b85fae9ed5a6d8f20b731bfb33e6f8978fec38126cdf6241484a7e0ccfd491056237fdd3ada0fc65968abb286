{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{AAub:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.r(__webpack_exports__);var index_esm_a,tslib_es6=__webpack_require__(\"mAIw\"),index_cjs=__webpack_require__(\"wj3C\"),index_cjs_default=__webpack_require__.n(index_cjs),dist_index_cjs=__webpack_require__(\"S+S0\"),util_dist_index_cjs=__webpack_require__(\"zVF4\"),idb=__webpack_require__(\"nbvr\"),ERROR_DESCRIPTION_MAP=((index_esm_a={})[\"missing-app-config-values\"]='Missing App configuration value: \"{$valueName}\"',index_esm_a[\"not-registered\"]=\"Firebase Installation is not registered.\",index_esm_a[\"installation-not-found\"]=\"Firebase Installation not found.\",index_esm_a[\"request-failed\"]='{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',index_esm_a[\"app-offline\"]=\"Could not process request. Application offline.\",index_esm_a[\"delete-pending-registration\"]=\"Can't delete installation while there is a pending registration request.\",index_esm_a),ERROR_FACTORY=new util_dist_index_cjs.ErrorFactory(\"installations\",\"Installations\",ERROR_DESCRIPTION_MAP);function isServerError(error){return error instanceof util_dist_index_cjs.FirebaseError&&error.code.includes(\"request-failed\")}function getInstallationsEndpoint(_a){return\"https://firebaseinstallations.googleapis.com/v1/projects/\"+_a.projectId+\"/installations\"}function extractAuthTokenInfoFromResponse(response){return{token:response.token,requestStatus:2,expiresIn:(responseExpiresIn=response.expiresIn,Number(responseExpiresIn.replace(\"s\",\"000\"))),creationTime:Date.now()};var responseExpiresIn}function getErrorFromResponse(requestName,response){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var responseJson,errorData;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return[4,response.json()];case 1:return responseJson=_a.sent(),[2,ERROR_FACTORY.create(\"request-failed\",{requestName:requestName,serverCode:(errorData=responseJson.error).code,serverMessage:errorData.message,serverStatus:errorData.status})]}})})}function getHeaders(_a){return new Headers({\"Content-Type\":\"application/json\",Accept:\"application/json\",\"x-goog-api-key\":_a.apiKey})}function getHeadersWithAuth(appConfig,_a){var refreshToken=_a.refreshToken,headers=getHeaders(appConfig);return headers.append(\"Authorization\",function(refreshToken){return\"FIS_v2 \"+refreshToken}(refreshToken)),headers}function retryIfServerError(fn){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var result;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return[4,fn()];case 1:return(result=_a.sent()).status>=500&&result.status<600?[2,fn()]:[2,result]}})})}function createInstallationRequest(appConfig,_a){var fid=_a.fid;return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var endpoint,headers,request,response,responseValue;return Object(tslib_es6.__generator)(this,function(_b){switch(_b.label){case 0:return endpoint=getInstallationsEndpoint(appConfig),headers=getHeaders(appConfig),request={method:\"POST\",headers:headers,body:JSON.stringify({fid:fid,authVersion:\"FIS_v2\",appId:appConfig.appId,sdkVersion:\"w:0.4.17\"})},[4,retryIfServerError(function(){return fetch(endpoint,request)})];case 1:return(response=_b.sent()).ok?[4,response.json()]:[3,3];case 2:return[2,{fid:(responseValue=_b.sent()).fid||fid,registrationStatus:2,refreshToken:responseValue.refreshToken,authToken:extractAuthTokenInfoFromResponse(responseValue.authToken)}];case 3:return[4,getErrorFromResponse(\"Create Installation\",response)];case 4:throw _b.sent()}})})}function sleep(ms){return new Promise(function(resolve){setTimeout(resolve,ms)})}var VALID_FID_PATTERN=/^[cdef][\\w-]{21}$/;function generateFid(){try{var fidByteArray=new Uint8Array(17);(self.crypto||self.msCrypto).getRandomValues(fidByteArray),fidByteArray[0]=112+fidByteArray[0]%16;var fid=function(fidByteArray){return(array=fidByteArray,btoa(String.fromCharCode.apply(String,Object(tslib_es6.__spread)(array))).replace(/\\+/g,\"-\").replace(/\\//g,\"_\")).substr(0,22);var array}(fidByteArray);return VALID_FID_PATTERN.test(fid)?fid:\"\"}catch(_a){return\"\"}}function getKey(appConfig){return appConfig.appName+\"!\"+appConfig.appId}var fidChangeCallbacks=new Map;function fidChanged(appConfig,fid){var key=getKey(appConfig);callFidChangeCallbacks(key,fid),function(key,fid){var channel=getBroadcastChannel();channel&&channel.postMessage({key:key,fid:fid}),closeBroadcastChannel()}(key,fid)}function callFidChangeCallbacks(key,fid){var e_1,_a,callbacks=fidChangeCallbacks.get(key);if(callbacks)try{for(var callbacks_1=Object(tslib_es6.__values)(callbacks),callbacks_1_1=callbacks_1.next();!callbacks_1_1.done;callbacks_1_1=callbacks_1.next())(0,callbacks_1_1.value)(fid)}catch(e_1_1){e_1={error:e_1_1}}finally{try{callbacks_1_1&&!callbacks_1_1.done&&(_a=callbacks_1.return)&&_a.call(callbacks_1)}finally{if(e_1)throw e_1.error}}}var broadcastChannel=null;function getBroadcastChannel(){return!broadcastChannel&&\"BroadcastChannel\"in self&&((broadcastChannel=new BroadcastChannel(\"[Firebase] FID Change\")).onmessage=function(e){callFidChangeCallbacks(e.data.key,e.data.fid)}),broadcastChannel}function closeBroadcastChannel(){0===fidChangeCallbacks.size&&broadcastChannel&&(broadcastChannel.close(),broadcastChannel=null)}var instance,OBJECT_STORE_NAME=\"firebase-installations-store\",dbPromise=null;function getDbPromise(){return dbPromise||(dbPromise=Object(idb.openDb)(\"firebase-installations-database\",1,function(upgradeDB){switch(upgradeDB.oldVersion){case 0:upgradeDB.createObjectStore(OBJECT_STORE_NAME)}})),dbPromise}function set(appConfig,value){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var key,db,tx,objectStore,oldValue;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return key=getKey(appConfig),[4,getDbPromise()];case 1:return db=_a.sent(),tx=db.transaction(OBJECT_STORE_NAME,\"readwrite\"),[4,(objectStore=tx.objectStore(OBJECT_STORE_NAME)).get(key)];case 2:return oldValue=_a.sent(),[4,objectStore.put(value,key)];case 3:return _a.sent(),[4,tx.complete];case 4:return _a.sent(),oldValue&&oldValue.fid===value.fid||fidChanged(appConfig,value.fid),[2,value]}})})}function remove(appConfig){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var key,db,tx;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return key=getKey(appConfig),[4,getDbPromise()];case 1:return db=_a.sent(),[4,(tx=db.transaction(OBJECT_STORE_NAME,\"readwrite\")).objectStore(OBJECT_STORE_NAME).delete(key)];case 2:return _a.sent(),[4,tx.complete];case 3:return _a.sent(),[2]}})})}function update(appConfig,updateFn){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var key,db,tx,store,oldValue,newValue;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return key=getKey(appConfig),[4,getDbPromise()];case 1:return db=_a.sent(),tx=db.transaction(OBJECT_STORE_NAME,\"readwrite\"),[4,(store=tx.objectStore(OBJECT_STORE_NAME)).get(key)];case 2:return oldValue=_a.sent(),void 0!==(newValue=updateFn(oldValue))?[3,4]:[4,store.delete(key)];case 3:return _a.sent(),[3,6];case 4:return[4,store.put(newValue,key)];case 5:_a.sent(),_a.label=6;case 6:return[4,tx.complete];case 7:return _a.sent(),!newValue||oldValue&&oldValue.fid===newValue.fid||fidChanged(appConfig,newValue.fid),[2,newValue]}})})}function getInstallationEntry(appConfig){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var registrationPromise,installationEntry,_a;return Object(tslib_es6.__generator)(this,function(_b){switch(_b.label){case 0:return[4,update(appConfig,function(oldEntry){var installationEntry=function(oldEntry){return clearTimedOutRequest(oldEntry||{fid:generateFid(),registrationStatus:0})}(oldEntry),entryWithPromise=function(appConfig,installationEntry){if(0===installationEntry.registrationStatus){if(!navigator.onLine)return{installationEntry:installationEntry,registrationPromise:Promise.reject(ERROR_FACTORY.create(\"app-offline\"))};var inProgressEntry={fid:installationEntry.fid,registrationStatus:1,registrationTime:Date.now()};return{installationEntry:inProgressEntry,registrationPromise:function(appConfig,installationEntry){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var registeredInstallationEntry,e_1;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return _a.trys.push([0,2,,7]),[4,createInstallationRequest(appConfig,installationEntry)];case 1:return registeredInstallationEntry=_a.sent(),[2,set(appConfig,registeredInstallationEntry)];case 2:return isServerError(e_1=_a.sent())&&409===e_1.serverCode?[4,remove(appConfig)]:[3,4];case 3:return _a.sent(),[3,6];case 4:return[4,set(appConfig,{fid:installationEntry.fid,registrationStatus:0})];case 5:_a.sent(),_a.label=6;case 6:throw e_1;case 7:return[2]}})})}(appConfig,inProgressEntry)}}return 1===installationEntry.registrationStatus?{installationEntry:installationEntry,registrationPromise:waitUntilFidRegistration(appConfig)}:{installationEntry:installationEntry}}(appConfig,installationEntry);return registrationPromise=entryWithPromise.registrationPromise,entryWithPromise.installationEntry})];case 1:return\"\"!==(installationEntry=_b.sent()).fid?[3,3]:(_a={},[4,registrationPromise]);case 2:return[2,(_a.installationEntry=_b.sent(),_a)];case 3:return[2,{installationEntry:installationEntry,registrationPromise:registrationPromise}]}})})}function waitUntilFidRegistration(appConfig){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var entry,_a,installationEntry,registrationPromise;return Object(tslib_es6.__generator)(this,function(_b){switch(_b.label){case 0:return[4,updateInstallationRequest(appConfig)];case 1:entry=_b.sent(),_b.label=2;case 2:return 1!==entry.registrationStatus?[3,5]:[4,sleep(100)];case 3:return _b.sent(),[4,updateInstallationRequest(appConfig)];case 4:return entry=_b.sent(),[3,2];case 5:return 0!==entry.registrationStatus?[3,7]:[4,getInstallationEntry(appConfig)];case 6:return _a=_b.sent(),installationEntry=_a.installationEntry,(registrationPromise=_a.registrationPromise)?[2,registrationPromise]:[2,installationEntry];case 7:return[2,entry]}})})}function updateInstallationRequest(appConfig){return update(appConfig,function(oldEntry){if(!oldEntry)throw ERROR_FACTORY.create(\"installation-not-found\");return clearTimedOutRequest(oldEntry)})}function clearTimedOutRequest(entry){return 1===(installationEntry=entry).registrationStatus&&installationEntry.registrationTime+1e4<Date.now()?{fid:entry.fid,registrationStatus:0}:entry;var installationEntry}function generateAuthTokenRequest(_a,installationEntry){var appConfig=_a.appConfig,platformLoggerProvider=_a.platformLoggerProvider;return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var endpoint,headers,platformLogger,request,response;return Object(tslib_es6.__generator)(this,function(_b){switch(_b.label){case 0:return endpoint=function(appConfig,_a){var fid=_a.fid;return getInstallationsEndpoint(appConfig)+\"/\"+fid+\"/authTokens:generate\"}(appConfig,installationEntry),headers=getHeadersWithAuth(appConfig,installationEntry),(platformLogger=platformLoggerProvider.getImmediate({optional:!0}))&&headers.append(\"x-firebase-client\",platformLogger.getPlatformInfoString()),request={method:\"POST\",headers:headers,body:JSON.stringify({installation:{sdkVersion:\"w:0.4.17\"}})},[4,retryIfServerError(function(){return fetch(endpoint,request)})];case 1:return(response=_b.sent()).ok?[4,response.json()]:[3,3];case 2:return[2,extractAuthTokenInfoFromResponse(_b.sent())];case 3:return[4,getErrorFromResponse(\"Generate Auth Token\",response)];case 4:throw _b.sent()}})})}function refreshAuthToken(dependencies,forceRefresh){return void 0===forceRefresh&&(forceRefresh=!1),Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var tokenPromise,entry,_a;return Object(tslib_es6.__generator)(this,function(_b){switch(_b.label){case 0:return[4,update(dependencies.appConfig,function(oldEntry){if(!isEntryRegistered(oldEntry))throw ERROR_FACTORY.create(\"not-registered\");var authToken,oldAuthToken=oldEntry.authToken;if(!forceRefresh&&2===(authToken=oldAuthToken).requestStatus&&!function(authToken){var now=Date.now();return now<authToken.creationTime||authToken.creationTime+authToken.expiresIn<now+36e5}(authToken))return oldEntry;if(1===oldAuthToken.requestStatus)return tokenPromise=function(dependencies,forceRefresh){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var entry,authToken;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return[4,updateAuthTokenRequest(dependencies.appConfig)];case 1:entry=_a.sent(),_a.label=2;case 2:return 1!==entry.authToken.requestStatus?[3,5]:[4,sleep(100)];case 3:return _a.sent(),[4,updateAuthTokenRequest(dependencies.appConfig)];case 4:return entry=_a.sent(),[3,2];case 5:return 0===(authToken=entry.authToken).requestStatus?[2,refreshAuthToken(dependencies,forceRefresh)]:[2,authToken]}})})}(dependencies,forceRefresh),oldEntry;if(!navigator.onLine)throw ERROR_FACTORY.create(\"app-offline\");var inProgressEntry=function(oldEntry){var inProgressAuthToken={requestStatus:1,requestTime:Date.now()};return Object(tslib_es6.__assign)(Object(tslib_es6.__assign)({},oldEntry),{authToken:inProgressAuthToken})}(oldEntry);return tokenPromise=function(dependencies,installationEntry){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var authToken,e_1,updatedInstallationEntry;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return _a.trys.push([0,3,,8]),[4,generateAuthTokenRequest(dependencies,installationEntry)];case 1:return authToken=_a.sent(),updatedInstallationEntry=Object(tslib_es6.__assign)(Object(tslib_es6.__assign)({},installationEntry),{authToken:authToken}),[4,set(dependencies.appConfig,updatedInstallationEntry)];case 2:return _a.sent(),[2,authToken];case 3:return!isServerError(e_1=_a.sent())||401!==e_1.serverCode&&404!==e_1.serverCode?[3,5]:[4,remove(dependencies.appConfig)];case 4:return _a.sent(),[3,7];case 5:return updatedInstallationEntry=Object(tslib_es6.__assign)(Object(tslib_es6.__assign)({},installationEntry),{authToken:{requestStatus:0}}),[4,set(dependencies.appConfig,updatedInstallationEntry)];case 6:_a.sent(),_a.label=7;case 7:throw e_1;case 8:return[2]}})})}(dependencies,inProgressEntry),inProgressEntry})];case 1:return entry=_b.sent(),tokenPromise?[4,tokenPromise]:[3,3];case 2:return _a=_b.sent(),[3,4];case 3:_a=entry.authToken,_b.label=4;case 4:return[2,_a]}})})}function updateAuthTokenRequest(appConfig){return update(appConfig,function(oldEntry){if(!isEntryRegistered(oldEntry))throw ERROR_FACTORY.create(\"not-registered\");var authToken;return 1===(authToken=oldEntry.authToken).requestStatus&&authToken.requestTime+1e4<Date.now()?Object(tslib_es6.__assign)(Object(tslib_es6.__assign)({},oldEntry),{authToken:{requestStatus:0}}):oldEntry})}function isEntryRegistered(installationEntry){return void 0!==installationEntry&&2===installationEntry.registrationStatus}function completeInstallationRegistration(appConfig){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var registrationPromise;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return[4,getInstallationEntry(appConfig)];case 1:return(registrationPromise=_a.sent().registrationPromise)?[4,registrationPromise]:[3,3];case 2:_a.sent(),_a.label=3;case 3:return[2]}})})}function deleteInstallationRequest(appConfig,installationEntry){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var endpoint,headers,request,response;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return endpoint=function(appConfig,_a){var fid=_a.fid;return getInstallationsEndpoint(appConfig)+\"/\"+fid}(appConfig,installationEntry),headers=getHeadersWithAuth(appConfig,installationEntry),request={method:\"DELETE\",headers:headers},[4,retryIfServerError(function(){return fetch(endpoint,request)})];case 1:return(response=_a.sent()).ok?[3,3]:[4,getErrorFromResponse(\"Delete Installation\",response)];case 2:throw _a.sent();case 3:return[2]}})})}function getMissingValueError(valueName){return ERROR_FACTORY.create(\"missing-app-config-values\",{valueName:valueName})}(instance=index_cjs_default.a).INTERNAL.registerComponent(new dist_index_cjs.Component(\"installations\",function(container){var app=container.getProvider(\"app\").getImmediate(),dependencies={appConfig:function(app){var e_1,_a;if(!app||!app.options)throw getMissingValueError(\"App Configuration\");if(!app.name)throw getMissingValueError(\"App Name\");try{for(var configKeys_1=Object(tslib_es6.__values)([\"projectId\",\"apiKey\",\"appId\"]),configKeys_1_1=configKeys_1.next();!configKeys_1_1.done;configKeys_1_1=configKeys_1.next()){var keyName=configKeys_1_1.value;if(!app.options[keyName])throw getMissingValueError(keyName)}}catch(e_1_1){e_1={error:e_1_1}}finally{try{configKeys_1_1&&!configKeys_1_1.done&&(_a=configKeys_1.return)&&_a.call(configKeys_1)}finally{if(e_1)throw e_1.error}}return{appName:app.name,projectId:app.options.projectId,apiKey:app.options.apiKey,appId:app.options.appId}}(app),platformLoggerProvider:container.getProvider(\"platform-logger\")};return{app:app,getId:function(){return function(dependencies){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var _a,installationEntry,registrationPromise;return Object(tslib_es6.__generator)(this,function(_b){switch(_b.label){case 0:return[4,getInstallationEntry(dependencies.appConfig)];case 1:return _a=_b.sent(),installationEntry=_a.installationEntry,(registrationPromise=_a.registrationPromise)?registrationPromise.catch(console.error):refreshAuthToken(dependencies).catch(console.error),[2,installationEntry.fid]}})})}(dependencies)},getToken:function(forceRefresh){return function(dependencies,forceRefresh){return void 0===forceRefresh&&(forceRefresh=!1),Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return[4,completeInstallationRegistration(dependencies.appConfig)];case 1:return _a.sent(),[4,refreshAuthToken(dependencies,forceRefresh)];case 2:return[2,_a.sent().token]}})})}(dependencies,forceRefresh)},delete:function(){return function(dependencies){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var appConfig,entry;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return[4,update(appConfig=dependencies.appConfig,function(oldEntry){if(!oldEntry||0!==oldEntry.registrationStatus)return oldEntry})];case 1:if(!(entry=_a.sent()))return[3,6];if(1!==entry.registrationStatus)return[3,2];throw ERROR_FACTORY.create(\"delete-pending-registration\");case 2:if(2!==entry.registrationStatus)return[3,6];if(navigator.onLine)return[3,3];throw ERROR_FACTORY.create(\"app-offline\");case 3:return[4,deleteInstallationRequest(appConfig,entry)];case 4:return _a.sent(),[4,remove(appConfig)];case 5:_a.sent(),_a.label=6;case 6:return[2]}})})}(dependencies)},onIdChange:function(callback){return function(_a,callback){var appConfig=_a.appConfig;return function(appConfig,callback){getBroadcastChannel();var key=getKey(appConfig),callbackSet=fidChangeCallbacks.get(key);callbackSet||(callbackSet=new Set,fidChangeCallbacks.set(key,callbackSet)),callbackSet.add(callback)}(appConfig,callback),function(){!function(appConfig,callback){var key=getKey(appConfig),callbackSet=fidChangeCallbacks.get(key);callbackSet&&(callbackSet.delete(callback),0===callbackSet.size&&fidChangeCallbacks.delete(key),closeBroadcastChannel())}(appConfig,callback)}}(dependencies,callback)}}},\"PUBLIC\")),instance.registerVersion(\"@firebase/installations\",\"0.4.17\");var dist_index_esm_a,index_esm=__webpack_require__(\"q/0M\"),GTAG_URL=\"https://www.googletagmanager.com/gtag/js\",GtagCommand=function(GtagCommand){return GtagCommand.EVENT=\"event\",GtagCommand.SET=\"set\",GtagCommand.CONFIG=\"config\",GtagCommand}({}),EventName=function(EventName){return EventName.ADD_SHIPPING_INFO=\"add_shipping_info\",EventName.ADD_PAYMENT_INFO=\"add_payment_info\",EventName.ADD_TO_CART=\"add_to_cart\",EventName.ADD_TO_WISHLIST=\"add_to_wishlist\",EventName.BEGIN_CHECKOUT=\"begin_checkout\",EventName.CHECKOUT_PROGRESS=\"checkout_progress\",EventName.EXCEPTION=\"exception\",EventName.GENERATE_LEAD=\"generate_lead\",EventName.LOGIN=\"login\",EventName.PAGE_VIEW=\"page_view\",EventName.PURCHASE=\"purchase\",EventName.REFUND=\"refund\",EventName.REMOVE_FROM_CART=\"remove_from_cart\",EventName.SCREEN_VIEW=\"screen_view\",EventName.SEARCH=\"search\",EventName.SELECT_CONTENT=\"select_content\",EventName.SELECT_ITEM=\"select_item\",EventName.SELECT_PROMOTION=\"select_promotion\",EventName.SET_CHECKOUT_OPTION=\"set_checkout_option\",EventName.SHARE=\"share\",EventName.SIGN_UP=\"sign_up\",EventName.TIMING_COMPLETE=\"timing_complete\",EventName.VIEW_CART=\"view_cart\",EventName.VIEW_ITEM=\"view_item\",EventName.VIEW_ITEM_LIST=\"view_item_list\",EventName.VIEW_PROMOTION=\"view_promotion\",EventName.VIEW_SEARCH_RESULTS=\"view_search_results\",EventName}({}),logger=new index_esm.Logger(\"@firebase/analytics\");function gtagOnConfig(gtagCore,initializationPromisesMap,dynamicConfigPromisesList,measurementIdToAppId,measurementId,gtagParams){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var correspondingAppId,dynamicConfigResults,foundConfig,e_1;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:correspondingAppId=measurementIdToAppId[measurementId],_a.label=1;case 1:return _a.trys.push([1,7,,8]),correspondingAppId?[4,initializationPromisesMap[correspondingAppId]]:[3,3];case 2:return _a.sent(),[3,6];case 3:return[4,Promise.all(dynamicConfigPromisesList)];case 4:return dynamicConfigResults=_a.sent(),(foundConfig=dynamicConfigResults.find(function(config){return config.measurementId===measurementId}))?[4,initializationPromisesMap[foundConfig.appId]]:[3,6];case 5:_a.sent(),_a.label=6;case 6:return[3,8];case 7:return e_1=_a.sent(),logger.error(e_1),[3,8];case 8:return gtagCore(GtagCommand.CONFIG,measurementId,gtagParams),[2]}})})}function gtagOnEvent(gtagCore,initializationPromisesMap,dynamicConfigPromisesList,measurementId,gtagParams){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var initializationPromisesToWaitFor,gaSendToList,dynamicConfigResults,_loop_1,_i,gaSendToList_1,e_2;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return _a.trys.push([0,4,,5]),initializationPromisesToWaitFor=[],gtagParams&&gtagParams.send_to?(gaSendToList=gtagParams.send_to,Array.isArray(gaSendToList)||(gaSendToList=[gaSendToList]),[4,Promise.all(dynamicConfigPromisesList)]):[3,2];case 1:for(dynamicConfigResults=_a.sent(),_loop_1=function(sendToId){var foundConfig=dynamicConfigResults.find(function(config){return config.measurementId===sendToId}),initializationPromise=foundConfig&&initializationPromisesMap[foundConfig.appId];if(!initializationPromise)return initializationPromisesToWaitFor=[],\"break\";initializationPromisesToWaitFor.push(initializationPromise)},_i=0,gaSendToList_1=gaSendToList;_i<gaSendToList_1.length&&\"break\"!==_loop_1(gaSendToList_1[_i]);_i++);_a.label=2;case 2:return 0===initializationPromisesToWaitFor.length&&(initializationPromisesToWaitFor=Object.values(initializationPromisesMap)),[4,Promise.all(initializationPromisesToWaitFor)];case 3:return _a.sent(),gtagCore(GtagCommand.EVENT,measurementId,gtagParams||{}),[3,5];case 4:return e_2=_a.sent(),logger.error(e_2),[3,5];case 5:return[2]}})})}var ERRORS=((dist_index_esm_a={})[\"already-exists\"]=\"A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.\",dist_index_esm_a[\"already-initialized\"]=\"Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.\",dist_index_esm_a[\"interop-component-reg-failed\"]=\"Firebase Analytics Interop Component failed to instantiate: {$reason}\",dist_index_esm_a[\"invalid-analytics-context\"]=\"Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}\",dist_index_esm_a[\"indexeddb-unavailable\"]=\"IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}\",dist_index_esm_a[\"fetch-throttle\"]=\"The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.\",dist_index_esm_a[\"config-fetch-failed\"]=\"Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}\",dist_index_esm_a[\"no-api-key\"]='The \"apiKey\" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.',dist_index_esm_a[\"no-app-id\"]='The \"appId\" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.',dist_index_esm_a),index_esm_ERROR_FACTORY=new util_dist_index_cjs.ErrorFactory(\"analytics\",\"Analytics\",ERRORS),defaultRetryData=new(function(){function RetryData(throttleMetadata,intervalMillis){void 0===throttleMetadata&&(throttleMetadata={}),void 0===intervalMillis&&(intervalMillis=1e3),this.throttleMetadata=throttleMetadata,this.intervalMillis=intervalMillis}return RetryData.prototype.getThrottleMetadata=function(appId){return this.throttleMetadata[appId]},RetryData.prototype.setThrottleMetadata=function(appId,metadata){this.throttleMetadata[appId]=metadata},RetryData.prototype.deleteThrottleMetadata=function(appId){delete this.throttleMetadata[appId]},RetryData}());function fetchDynamicConfig(appFields){var _a;return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var appId,request,appUrl,response,errorMessage,jsonResponse;return Object(tslib_es6.__generator)(this,function(_b){switch(_b.label){case 0:return appId=appFields.appId,request={method:\"GET\",headers:(apiKey=appFields.apiKey,new Headers({Accept:\"application/json\",\"x-goog-api-key\":apiKey}))},appUrl=\"https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig\".replace(\"{app-id}\",appId),[4,fetch(appUrl,request)];case 1:if(200===(response=_b.sent()).status||304===response.status)return[3,6];errorMessage=\"\",_b.label=2;case 2:return _b.trys.push([2,4,,5]),[4,response.json()];case 3:return jsonResponse=_b.sent(),(null===(_a=jsonResponse.error)||void 0===_a?void 0:_a.message)&&(errorMessage=jsonResponse.error.message),[3,5];case 4:return _b.sent(),[3,5];case 5:throw index_esm_ERROR_FACTORY.create(\"config-fetch-failed\",{httpStatus:response.status,responseMessage:errorMessage});case 6:return[2,response.json()]}var apiKey})})}function attemptFetchDynamicConfigWithRetry(appFields,_a,signal,retryData){var throttleEndTimeMillis=_a.throttleEndTimeMillis,backoffCount=_a.backoffCount;return void 0===retryData&&(retryData=defaultRetryData),Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var appId,measurementId,e_1,response,e_2,backoffMillis,throttleMetadata;return Object(tslib_es6.__generator)(this,function(_b){switch(_b.label){case 0:appId=appFields.appId,measurementId=appFields.measurementId,_b.label=1;case 1:return _b.trys.push([1,3,,4]),[4,setAbortableTimeout(signal,throttleEndTimeMillis)];case 2:return _b.sent(),[3,4];case 3:if(e_1=_b.sent(),measurementId)return logger.warn(\"Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID \"+measurementId+' provided in the \"measurementId\" field in the local Firebase config. ['+e_1.message+\"]\"),[2,{appId:appId,measurementId:measurementId}];throw e_1;case 4:return _b.trys.push([4,6,,7]),[4,fetchDynamicConfig(appFields)];case 5:return response=_b.sent(),retryData.deleteThrottleMetadata(appId),[2,response];case 6:if(!function(e){if(!(e instanceof util_dist_index_cjs.FirebaseError))return!1;var httpStatus=Number(e.httpStatus);return 429===httpStatus||500===httpStatus||503===httpStatus||504===httpStatus}(e_2=_b.sent())){if(retryData.deleteThrottleMetadata(appId),measurementId)return logger.warn(\"Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID \"+measurementId+' provided in the \"measurementId\" field in the local Firebase config. ['+e_2.message+\"]\"),[2,{appId:appId,measurementId:measurementId}];throw e_2}return backoffMillis=503===Number(e_2.httpStatus)?Object(util_dist_index_cjs.calculateBackoffMillis)(backoffCount,retryData.intervalMillis,30):Object(util_dist_index_cjs.calculateBackoffMillis)(backoffCount,retryData.intervalMillis),throttleMetadata={throttleEndTimeMillis:Date.now()+backoffMillis,backoffCount:backoffCount+1},retryData.setThrottleMetadata(appId,throttleMetadata),logger.debug(\"Calling attemptFetch again in \"+backoffMillis+\" millis\"),[2,attemptFetchDynamicConfigWithRetry(appFields,throttleMetadata,signal,retryData)];case 7:return[2]}})})}function setAbortableTimeout(signal,throttleEndTimeMillis){return new Promise(function(resolve,reject){var backoffMillis=Math.max(throttleEndTimeMillis-Date.now(),0),timeout=setTimeout(resolve,backoffMillis);signal.addEventListener(function(){clearTimeout(timeout),reject(index_esm_ERROR_FACTORY.create(\"fetch-throttle\",{throttleEndTimeMillis:throttleEndTimeMillis}))})})}var gtagCoreFunction,wrappedGtagFunction,AnalyticsAbortSignal=function(){function AnalyticsAbortSignal(){this.listeners=[]}return AnalyticsAbortSignal.prototype.addEventListener=function(listener){this.listeners.push(listener)},AnalyticsAbortSignal.prototype.abort=function(){this.listeners.forEach(function(listener){return listener()})},AnalyticsAbortSignal}(),index_esm_initializationPromisesMap={},index_esm_dynamicConfigPromisesList=[],index_esm_measurementIdToAppId={},dataLayerName=\"dataLayer\",gtagName=\"gtag\",globalInitDone=!1;function settings(options){if(globalInitDone)throw index_esm_ERROR_FACTORY.create(\"already-initialized\");options.dataLayerName&&(dataLayerName=options.dataLayerName),options.gtagName&&(gtagName=options.gtagName)}function isSupported(){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:if(Object(util_dist_index_cjs.isBrowserExtension)())return[2,!1];if(!Object(util_dist_index_cjs.areCookiesEnabled)())return[2,!1];if(!Object(util_dist_index_cjs.isIndexedDBAvailable)())return[2,!1];_a.label=1;case 1:return _a.trys.push([1,3,,4]),[4,Object(util_dist_index_cjs.validateIndexedDBOpenable)()];case 2:return[2,_a.sent()];case 3:return _a.sent(),[2,!1];case 4:return[2]}})})}!function(instance){instance.INTERNAL.registerComponent(new dist_index_cjs.Component(\"analytics\",function(container){return function(app,installations){!function(){var mismatchedEnvMessages=[];if(Object(util_dist_index_cjs.isBrowserExtension)()&&mismatchedEnvMessages.push(\"This is a browser extension environment.\"),Object(util_dist_index_cjs.areCookiesEnabled)()||mismatchedEnvMessages.push(\"Cookies are not available.\"),mismatchedEnvMessages.length>0){var details=mismatchedEnvMessages.map(function(message,index){return\"(\"+(index+1)+\") \"+message}).join(\" \"),err=index_esm_ERROR_FACTORY.create(\"invalid-analytics-context\",{errorInfo:details});logger.warn(err.message)}}();var appId=app.options.appId;if(!appId)throw index_esm_ERROR_FACTORY.create(\"no-app-id\");if(!app.options.apiKey){if(!app.options.measurementId)throw index_esm_ERROR_FACTORY.create(\"no-api-key\");logger.warn('The \"apiKey\" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID '+app.options.measurementId+' provided in the \"measurementId\" field in the local Firebase config.')}if(null!=index_esm_initializationPromisesMap[appId])throw index_esm_ERROR_FACTORY.create(\"already-exists\",{id:appId});if(!globalInitDone){(function(){for(var scriptTags=window.document.getElementsByTagName(\"script\"),_i=0,_a=Object.values(scriptTags);_i<_a.length;_i++){var tag=_a[_i];if(tag.src&&tag.src.includes(GTAG_URL))return tag}return null})()||function(dataLayerName){var script=document.createElement(\"script\");script.src=GTAG_URL+\"?l=\"+dataLayerName,script.async=!0,document.head.appendChild(script)}(dataLayerName),function(dataLayerName){var dataLayer=[];Array.isArray(window[dataLayerName])?dataLayer=window[dataLayerName]:window[dataLayerName]=dataLayer}(dataLayerName);var _a=function(initializationPromisesMap,dynamicConfigPromisesList,measurementIdToAppId,dataLayerName,gtagFunctionName){var gtagCore=function(){for(var _args=[],_i=0;_i<arguments.length;_i++)_args[_i]=arguments[_i];window[dataLayerName].push(arguments)};return window[gtagFunctionName]&&\"function\"==typeof window[gtagFunctionName]&&(gtagCore=window[gtagFunctionName]),window[gtagFunctionName]=function(gtagCore,initializationPromisesMap,dynamicConfigPromisesList,measurementIdToAppId){return function(command,idOrNameOrParams,gtagParams){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var e_3;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return _a.trys.push([0,6,,7]),command!==GtagCommand.EVENT?[3,2]:[4,gtagOnEvent(gtagCore,initializationPromisesMap,dynamicConfigPromisesList,idOrNameOrParams,gtagParams)];case 1:return _a.sent(),[3,5];case 2:return command!==GtagCommand.CONFIG?[3,4]:[4,gtagOnConfig(gtagCore,initializationPromisesMap,dynamicConfigPromisesList,measurementIdToAppId,idOrNameOrParams,gtagParams)];case 3:return _a.sent(),[3,5];case 4:gtagCore(GtagCommand.SET,idOrNameOrParams),_a.label=5;case 5:return[3,7];case 6:return e_3=_a.sent(),logger.error(e_3),[3,7];case 7:return[2]}})})}}(gtagCore,initializationPromisesMap,dynamicConfigPromisesList,measurementIdToAppId),{gtagCore:gtagCore,wrappedGtag:window[gtagFunctionName]}}(index_esm_initializationPromisesMap,index_esm_dynamicConfigPromisesList,index_esm_measurementIdToAppId,dataLayerName,gtagName);wrappedGtagFunction=_a.wrappedGtag,gtagCoreFunction=_a.gtagCore,globalInitDone=!0}return index_esm_initializationPromisesMap[appId]=function(app,dynamicConfigPromisesList,measurementIdToAppId,installations,gtagCore){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var dynamicConfigPromise,fidPromise,_a,dynamicConfig,fid,configProperties,_b;return Object(tslib_es6.__generator)(this,function(_c){switch(_c.label){case 0:return(dynamicConfigPromise=function(app,retryData,timeoutMillis){return void 0===retryData&&(retryData=defaultRetryData),Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var _a,appId,apiKey,measurementId,throttleMetadata,signal,_this=this;return Object(tslib_es6.__generator)(this,function(_b){if(apiKey=(_a=app.options).apiKey,measurementId=_a.measurementId,!(appId=_a.appId))throw index_esm_ERROR_FACTORY.create(\"no-app-id\");if(!apiKey){if(measurementId)return[2,{measurementId:measurementId,appId:appId}];throw index_esm_ERROR_FACTORY.create(\"no-api-key\")}return throttleMetadata=retryData.getThrottleMetadata(appId)||{backoffCount:0,throttleEndTimeMillis:Date.now()},signal=new AnalyticsAbortSignal,setTimeout(function(){return Object(tslib_es6.__awaiter)(_this,void 0,void 0,function(){return Object(tslib_es6.__generator)(this,function(_a){return signal.abort(),[2]})})},6e4),[2,attemptFetchDynamicConfigWithRetry({appId:appId,apiKey:apiKey,measurementId:measurementId},throttleMetadata,signal,retryData)]})})}(app)).then(function(config){measurementIdToAppId[config.measurementId]=config.appId,app.options.measurementId&&config.measurementId!==app.options.measurementId&&logger.warn(\"The measurement ID in the local Firebase config (\"+app.options.measurementId+\") does not match the measurement ID fetched from the server (\"+config.measurementId+\"). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.\")}).catch(function(e){return logger.error(e)}),dynamicConfigPromisesList.push(dynamicConfigPromise),fidPromise=function(){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var e_1;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return Object(util_dist_index_cjs.isIndexedDBAvailable)()?[3,1]:(logger.warn(index_esm_ERROR_FACTORY.create(\"indexeddb-unavailable\",{errorInfo:\"IndexedDB is not available in this environment.\"}).message),[2,!1]);case 1:return _a.trys.push([1,3,,4]),[4,Object(util_dist_index_cjs.validateIndexedDBOpenable)()];case 2:return _a.sent(),[3,4];case 3:return e_1=_a.sent(),logger.warn(index_esm_ERROR_FACTORY.create(\"indexeddb-unavailable\",{errorInfo:e_1}).message),[2,!1];case 4:return[2,!0]}})})}().then(function(envIsValid){return envIsValid?installations.getId():void 0}),[4,Promise.all([dynamicConfigPromise,fidPromise])];case 1:return _a=_c.sent(),dynamicConfig=_a[0],fid=_a[1],gtagCore(\"js\",new Date),(_b={}).origin=\"firebase\",_b.update=!0,configProperties=_b,null!=fid&&(configProperties.firebase_id=fid),gtagCore(GtagCommand.CONFIG,dynamicConfig.measurementId,configProperties),[2,dynamicConfig.measurementId]}})})}(app,index_esm_dynamicConfigPromisesList,index_esm_measurementIdToAppId,installations,gtagCoreFunction),{app:app,logEvent:function(eventName,eventParams,options){(function(gtagFunction,initializationPromise,eventName,eventParams,options){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var measurementId,params;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return options&&options.global?(gtagFunction(GtagCommand.EVENT,eventName,eventParams),[2]):[3,1];case 1:return[4,initializationPromise];case 2:measurementId=_a.sent(),params=Object(tslib_es6.__assign)(Object(tslib_es6.__assign)({},eventParams),{send_to:measurementId}),gtagFunction(GtagCommand.EVENT,eventName,params),_a.label=3;case 3:return[2]}})})})(wrappedGtagFunction,index_esm_initializationPromisesMap[appId],eventName,eventParams,options).catch(function(e){return logger.error(e)})},setCurrentScreen:function(screenName,options){(function(gtagFunction,initializationPromise,screenName,options){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var measurementId;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return options&&options.global?(gtagFunction(GtagCommand.SET,{screen_name:screenName}),[2,Promise.resolve()]):[3,1];case 1:return[4,initializationPromise];case 2:measurementId=_a.sent(),gtagFunction(GtagCommand.CONFIG,measurementId,{update:!0,screen_name:screenName}),_a.label=3;case 3:return[2]}})})})(wrappedGtagFunction,index_esm_initializationPromisesMap[appId],screenName,options).catch(function(e){return logger.error(e)})},setUserId:function(id,options){(function(gtagFunction,initializationPromise,id,options){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var measurementId;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return options&&options.global?(gtagFunction(GtagCommand.SET,{user_id:id}),[2,Promise.resolve()]):[3,1];case 1:return[4,initializationPromise];case 2:measurementId=_a.sent(),gtagFunction(GtagCommand.CONFIG,measurementId,{update:!0,user_id:id}),_a.label=3;case 3:return[2]}})})})(wrappedGtagFunction,index_esm_initializationPromisesMap[appId],id,options).catch(function(e){return logger.error(e)})},setUserProperties:function(properties,options){(function(gtagFunction,initializationPromise,properties,options){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var flatProperties,_i,_a,key,measurementId;return Object(tslib_es6.__generator)(this,function(_b){switch(_b.label){case 0:if(!options||!options.global)return[3,1];for(flatProperties={},_i=0,_a=Object.keys(properties);_i<_a.length;_i++)flatProperties[\"user_properties.\"+(key=_a[_i])]=properties[key];return gtagFunction(GtagCommand.SET,flatProperties),[2,Promise.resolve()];case 1:return[4,initializationPromise];case 2:measurementId=_b.sent(),gtagFunction(GtagCommand.CONFIG,measurementId,{update:!0,user_properties:properties}),_b.label=3;case 3:return[2]}})})})(wrappedGtagFunction,index_esm_initializationPromisesMap[appId],properties,options).catch(function(e){return logger.error(e)})},setAnalyticsCollectionEnabled:function(enabled){(function(initializationPromise,enabled){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function(){var measurementId;return Object(tslib_es6.__generator)(this,function(_a){switch(_a.label){case 0:return[4,initializationPromise];case 1:return measurementId=_a.sent(),window[\"ga-disable-\"+measurementId]=!enabled,[2]}})})})(index_esm_initializationPromisesMap[appId],enabled).catch(function(e){return logger.error(e)})},INTERNAL:{delete:function(){return delete index_esm_initializationPromisesMap[appId],Promise.resolve()}}}}(container.getProvider(\"app\").getImmediate(),container.getProvider(\"installations\").getImmediate())},\"PUBLIC\").setServiceProps({settings:settings,EventName:EventName,isSupported:isSupported})),instance.INTERNAL.registerComponent(new dist_index_cjs.Component(\"analytics-internal\",function(container){try{return{logEvent:container.getProvider(\"analytics\").getImmediate().logEvent}}catch(e){throw index_esm_ERROR_FACTORY.create(\"interop-component-reg-failed\",{reason:e})}},\"PRIVATE\")),instance.registerVersion(\"@firebase/analytics\",\"0.6.0\")}(index_cjs_default.a)},nbvr:function(module,exports,__webpack_require__){!function(exports){\"use strict\";function toArray(arr){return Array.prototype.slice.call(arr)}function promisifyRequest(request){return new Promise(function(resolve,reject){request.onsuccess=function(){resolve(request.result)},request.onerror=function(){reject(request.error)}})}function promisifyRequestCall(obj,method,args){var request,p=new Promise(function(resolve,reject){promisifyRequest(request=obj[method].apply(obj,args)).then(resolve,reject)});return p.request=request,p}function promisifyCursorRequestCall(obj,method,args){var p=promisifyRequestCall(obj,method,args);return p.then(function(value){if(value)return new Cursor(value,p.request)})}function proxyProperties(ProxyClass,targetProp,properties){properties.forEach(function(prop){Object.defineProperty(ProxyClass.prototype,prop,{get:function(){return this[targetProp][prop]},set:function(val){this[targetProp][prop]=val}})})}function proxyRequestMethods(ProxyClass,targetProp,Constructor,properties){properties.forEach(function(prop){prop in Constructor.prototype&&(ProxyClass.prototype[prop]=function(){return promisifyRequestCall(this[targetProp],prop,arguments)})})}function proxyMethods(ProxyClass,targetProp,Constructor,properties){properties.forEach(function(prop){prop in Constructor.prototype&&(ProxyClass.prototype[prop]=function(){return this[targetProp][prop].apply(this[targetProp],arguments)})})}function proxyCursorRequestMethods(ProxyClass,targetProp,Constructor,properties){properties.forEach(function(prop){prop in Constructor.prototype&&(ProxyClass.prototype[prop]=function(){return promisifyCursorRequestCall(this[targetProp],prop,arguments)})})}function Index(index){this._index=index}function Cursor(cursor,request){this._cursor=cursor,this._request=request}function ObjectStore(store){this._store=store}function Transaction(idbTransaction){this._tx=idbTransaction,this.complete=new Promise(function(resolve,reject){idbTransaction.oncomplete=function(){resolve()},idbTransaction.onerror=function(){reject(idbTransaction.error)},idbTransaction.onabort=function(){reject(idbTransaction.error)}})}function UpgradeDB(db,oldVersion,transaction){this._db=db,this.oldVersion=oldVersion,this.transaction=new Transaction(transaction)}function DB(db){this._db=db}proxyProperties(Index,\"_index\",[\"name\",\"keyPath\",\"multiEntry\",\"unique\"]),proxyRequestMethods(Index,\"_index\",IDBIndex,[\"get\",\"getKey\",\"getAll\",\"getAllKeys\",\"count\"]),proxyCursorRequestMethods(Index,\"_index\",IDBIndex,[\"openCursor\",\"openKeyCursor\"]),proxyProperties(Cursor,\"_cursor\",[\"direction\",\"key\",\"primaryKey\",\"value\"]),proxyRequestMethods(Cursor,\"_cursor\",IDBCursor,[\"update\",\"delete\"]),[\"advance\",\"continue\",\"continuePrimaryKey\"].forEach(function(methodName){methodName in IDBCursor.prototype&&(Cursor.prototype[methodName]=function(){var cursor=this,args=arguments;return Promise.resolve().then(function(){return cursor._cursor[methodName].apply(cursor._cursor,args),promisifyRequest(cursor._request).then(function(value){if(value)return new Cursor(value,cursor._request)})})})}),ObjectStore.prototype.createIndex=function(){return new Index(this._store.createIndex.apply(this._store,arguments))},ObjectStore.prototype.index=function(){return new Index(this._store.index.apply(this._store,arguments))},proxyProperties(ObjectStore,\"_store\",[\"name\",\"keyPath\",\"indexNames\",\"autoIncrement\"]),proxyRequestMethods(ObjectStore,\"_store\",IDBObjectStore,[\"put\",\"add\",\"delete\",\"clear\",\"get\",\"getAll\",\"getKey\",\"getAllKeys\",\"count\"]),proxyCursorRequestMethods(ObjectStore,\"_store\",IDBObjectStore,[\"openCursor\",\"openKeyCursor\"]),proxyMethods(ObjectStore,\"_store\",IDBObjectStore,[\"deleteIndex\"]),Transaction.prototype.objectStore=function(){return new ObjectStore(this._tx.objectStore.apply(this._tx,arguments))},proxyProperties(Transaction,\"_tx\",[\"objectStoreNames\",\"mode\"]),proxyMethods(Transaction,\"_tx\",IDBTransaction,[\"abort\"]),UpgradeDB.prototype.createObjectStore=function(){return new ObjectStore(this._db.createObjectStore.apply(this._db,arguments))},proxyProperties(UpgradeDB,\"_db\",[\"name\",\"version\",\"objectStoreNames\"]),proxyMethods(UpgradeDB,\"_db\",IDBDatabase,[\"deleteObjectStore\",\"close\"]),DB.prototype.transaction=function(){return new Transaction(this._db.transaction.apply(this._db,arguments))},proxyProperties(DB,\"_db\",[\"name\",\"version\",\"objectStoreNames\"]),proxyMethods(DB,\"_db\",IDBDatabase,[\"close\"]),[\"openCursor\",\"openKeyCursor\"].forEach(function(funcName){[ObjectStore,Index].forEach(function(Constructor){funcName in Constructor.prototype&&(Constructor.prototype[funcName.replace(\"open\",\"iterate\")]=function(){var args=toArray(arguments),callback=args[args.length-1],nativeObject=this._store||this._index,request=nativeObject[funcName].apply(nativeObject,args.slice(0,-1));request.onsuccess=function(){callback(request.result)}})})}),[Index,ObjectStore].forEach(function(Constructor){Constructor.prototype.getAll||(Constructor.prototype.getAll=function(query,count){var instance=this,items=[];return new Promise(function(resolve){instance.iterateCursor(query,function(cursor){cursor?(items.push(cursor.value),void 0===count||items.length!=count?cursor.continue():resolve(items)):resolve(items)})})})}),exports.openDb=function(name,version,upgradeCallback){var p=promisifyRequestCall(indexedDB,\"open\",[name,version]),request=p.request;return request&&(request.onupgradeneeded=function(event){upgradeCallback&&upgradeCallback(new UpgradeDB(request.result,event.oldVersion,request.transaction))}),p.then(function(db){return new DB(db)})},exports.deleteDb=function(name){return promisifyRequestCall(indexedDB,\"deleteDatabase\",[name])},Object.defineProperty(exports,\"__esModule\",{value:!0})}(exports)}}]);","name":"6-es2015.7c3096f41887e576eb75.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[6],{\n\n/***/ \"AAub\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/@firebase/database/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(\"mAIw\");\n\n// EXTERNAL MODULE: ./node_modules/@firebase/app/dist/index.cjs.js\nvar index_cjs = __webpack_require__(\"wj3C\");\nvar index_cjs_default = /*#__PURE__*/__webpack_require__.n(index_cjs);\n\n// EXTERNAL MODULE: ./node_modules/@firebase/component/dist/index.cjs.js\nvar dist_index_cjs = __webpack_require__(\"S+S0\");\n\n// EXTERNAL MODULE: ./node_modules/@firebase/util/dist/index.cjs.js\nvar util_dist_index_cjs = __webpack_require__(\"zVF4\");\n\n// EXTERNAL MODULE: ./node_modules/idb/build/idb.js\nvar idb = __webpack_require__(\"nbvr\");\n\n// CONCATENATED MODULE: ./node_modules/@firebase/installations/dist/index.esm.js\n\n\n\n\n\n\nvar index_esm_name = \"@firebase/installations\";\nvar version = \"0.4.17\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar PENDING_TIMEOUT_MS = 10000;\r\nvar PACKAGE_VERSION = \"w:\" + version;\r\nvar INTERNAL_AUTH_VERSION = 'FIS_v2';\r\nvar INSTALLATIONS_API_URL = 'https://firebaseinstallations.googleapis.com/v1';\r\nvar TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\r\nvar SERVICE = 'installations';\r\nvar SERVICE_NAME = 'Installations';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar index_esm_a;\r\nvar ERROR_DESCRIPTION_MAP = (index_esm_a = {},\r\n    index_esm_a[\"missing-app-config-values\" /* MISSING_APP_CONFIG_VALUES */] = 'Missing App configuration value: \"{$valueName}\"',\r\n    index_esm_a[\"not-registered\" /* NOT_REGISTERED */] = 'Firebase Installation is not registered.',\r\n    index_esm_a[\"installation-not-found\" /* INSTALLATION_NOT_FOUND */] = 'Firebase Installation not found.',\r\n    index_esm_a[\"request-failed\" /* REQUEST_FAILED */] = '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\r\n    index_esm_a[\"app-offline\" /* APP_OFFLINE */] = 'Could not process request. Application offline.',\r\n    index_esm_a[\"delete-pending-registration\" /* DELETE_PENDING_REGISTRATION */] = \"Can't delete installation while there is a pending registration request.\",\r\n    index_esm_a);\r\nvar ERROR_FACTORY = new util_dist_index_cjs[\"ErrorFactory\"](SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);\r\n/** Returns true if error is a FirebaseError that is based on an error from the server. */\r\nfunction isServerError(error) {\r\n    return (error instanceof util_dist_index_cjs[\"FirebaseError\"] &&\r\n        error.code.includes(\"request-failed\" /* REQUEST_FAILED */));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getInstallationsEndpoint(_a) {\r\n    var projectId = _a.projectId;\r\n    return INSTALLATIONS_API_URL + \"/projects/\" + projectId + \"/installations\";\r\n}\r\nfunction extractAuthTokenInfoFromResponse(response) {\r\n    return {\r\n        token: response.token,\r\n        requestStatus: 2 /* COMPLETED */,\r\n        expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\r\n        creationTime: Date.now()\r\n    };\r\n}\r\nfunction getErrorFromResponse(requestName, response) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var responseJson, errorData;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, response.json()];\r\n                case 1:\r\n                    responseJson = _a.sent();\r\n                    errorData = responseJson.error;\r\n                    return [2 /*return*/, ERROR_FACTORY.create(\"request-failed\" /* REQUEST_FAILED */, {\r\n                            requestName: requestName,\r\n                            serverCode: errorData.code,\r\n                            serverMessage: errorData.message,\r\n                            serverStatus: errorData.status\r\n                        })];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction getHeaders(_a) {\r\n    var apiKey = _a.apiKey;\r\n    return new Headers({\r\n        'Content-Type': 'application/json',\r\n        Accept: 'application/json',\r\n        'x-goog-api-key': apiKey\r\n    });\r\n}\r\nfunction getHeadersWithAuth(appConfig, _a) {\r\n    var refreshToken = _a.refreshToken;\r\n    var headers = getHeaders(appConfig);\r\n    headers.append('Authorization', getAuthorizationHeader(refreshToken));\r\n    return headers;\r\n}\r\n/**\r\n * Calls the passed in fetch wrapper and returns the response.\r\n * If the returned response has a status of 5xx, re-runs the function once and\r\n * returns the response.\r\n */\r\nfunction retryIfServerError(fn) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var result;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, fn()];\r\n                case 1:\r\n                    result = _a.sent();\r\n                    if (result.status >= 500 && result.status < 600) {\r\n                        // Internal Server Error. Retry request.\r\n                        return [2 /*return*/, fn()];\r\n                    }\r\n                    return [2 /*return*/, result];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn) {\r\n    // This works because the server will never respond with fractions of a second.\r\n    return Number(responseExpiresIn.replace('s', '000'));\r\n}\r\nfunction getAuthorizationHeader(refreshToken) {\r\n    return INTERNAL_AUTH_VERSION + \" \" + refreshToken;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction createInstallationRequest(appConfig, _a) {\r\n    var fid = _a.fid;\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var endpoint, headers, body, request, response, responseValue, registeredInstallationEntry;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    endpoint = getInstallationsEndpoint(appConfig);\r\n                    headers = getHeaders(appConfig);\r\n                    body = {\r\n                        fid: fid,\r\n                        authVersion: INTERNAL_AUTH_VERSION,\r\n                        appId: appConfig.appId,\r\n                        sdkVersion: PACKAGE_VERSION\r\n                    };\r\n                    request = {\r\n                        method: 'POST',\r\n                        headers: headers,\r\n                        body: JSON.stringify(body)\r\n                    };\r\n                    return [4 /*yield*/, retryIfServerError(function () { return fetch(endpoint, request); })];\r\n                case 1:\r\n                    response = _b.sent();\r\n                    if (!response.ok) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, response.json()];\r\n                case 2:\r\n                    responseValue = _b.sent();\r\n                    registeredInstallationEntry = {\r\n                        fid: responseValue.fid || fid,\r\n                        registrationStatus: 2 /* COMPLETED */,\r\n                        refreshToken: responseValue.refreshToken,\r\n                        authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\r\n                    };\r\n                    return [2 /*return*/, registeredInstallationEntry];\r\n                case 3: return [4 /*yield*/, getErrorFromResponse('Create Installation', response)];\r\n                case 4: throw _b.sent();\r\n            }\r\n        });\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Returns a promise that resolves after given time passes. */\r\nfunction sleep(ms) {\r\n    return new Promise(function (resolve) {\r\n        setTimeout(resolve, ms);\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction bufferToBase64UrlSafe(array) {\r\n    var b64 = btoa(String.fromCharCode.apply(String, Object(tslib_es6[\"__spread\"])(array)));\r\n    return b64.replace(/\\+/g, '-').replace(/\\//g, '_');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\r\nvar INVALID_FID = '';\r\n/**\r\n * Generates a new FID using random values from Web Crypto API.\r\n * Returns an empty string if FID generation fails for any reason.\r\n */\r\nfunction generateFid() {\r\n    try {\r\n        // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\r\n        // bytes. our implementation generates a 17 byte array instead.\r\n        var fidByteArray = new Uint8Array(17);\r\n        var crypto_1 = self.crypto || self.msCrypto;\r\n        crypto_1.getRandomValues(fidByteArray);\r\n        // Replace the first 4 random bits with the constant FID header of 0b0111.\r\n        fidByteArray[0] = 112 + (fidByteArray[0] % 16);\r\n        var fid = encode(fidByteArray);\r\n        return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\r\n    }\r\n    catch (_a) {\r\n        // FID generation errored\r\n        return INVALID_FID;\r\n    }\r\n}\r\n/** Converts a FID Uint8Array to a base64 string representation. */\r\nfunction encode(fidByteArray) {\r\n    var b64String = bufferToBase64UrlSafe(fidByteArray);\r\n    // Remove the 23rd character that was added because of the extra 4 bits at the\r\n    // end of our 17 byte array, and the '=' padding.\r\n    return b64String.substr(0, 22);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Returns a string key that can be used to identify the app. */\r\nfunction getKey(appConfig) {\r\n    return appConfig.appName + \"!\" + appConfig.appId;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar fidChangeCallbacks = new Map();\r\n/**\r\n * Calls the onIdChange callbacks with the new FID value, and broadcasts the\r\n * change to other tabs.\r\n */\r\nfunction fidChanged(appConfig, fid) {\r\n    var key = getKey(appConfig);\r\n    callFidChangeCallbacks(key, fid);\r\n    broadcastFidChange(key, fid);\r\n}\r\nfunction addCallback(appConfig, callback) {\r\n    // Open the broadcast channel if it's not already open,\r\n    // to be able to listen to change events from other tabs.\r\n    getBroadcastChannel();\r\n    var key = getKey(appConfig);\r\n    var callbackSet = fidChangeCallbacks.get(key);\r\n    if (!callbackSet) {\r\n        callbackSet = new Set();\r\n        fidChangeCallbacks.set(key, callbackSet);\r\n    }\r\n    callbackSet.add(callback);\r\n}\r\nfunction removeCallback(appConfig, callback) {\r\n    var key = getKey(appConfig);\r\n    var callbackSet = fidChangeCallbacks.get(key);\r\n    if (!callbackSet) {\r\n        return;\r\n    }\r\n    callbackSet.delete(callback);\r\n    if (callbackSet.size === 0) {\r\n        fidChangeCallbacks.delete(key);\r\n    }\r\n    // Close broadcast channel if there are no more callbacks.\r\n    closeBroadcastChannel();\r\n}\r\nfunction callFidChangeCallbacks(key, fid) {\r\n    var e_1, _a;\r\n    var callbacks = fidChangeCallbacks.get(key);\r\n    if (!callbacks) {\r\n        return;\r\n    }\r\n    try {\r\n        for (var callbacks_1 = Object(tslib_es6[\"__values\"])(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\r\n            var callback = callbacks_1_1.value;\r\n            callback(fid);\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n}\r\nfunction broadcastFidChange(key, fid) {\r\n    var channel = getBroadcastChannel();\r\n    if (channel) {\r\n        channel.postMessage({ key: key, fid: fid });\r\n    }\r\n    closeBroadcastChannel();\r\n}\r\nvar broadcastChannel = null;\r\n/** Opens and returns a BroadcastChannel if it is supported by the browser. */\r\nfunction getBroadcastChannel() {\r\n    if (!broadcastChannel && 'BroadcastChannel' in self) {\r\n        broadcastChannel = new BroadcastChannel('[Firebase] FID Change');\r\n        broadcastChannel.onmessage = function (e) {\r\n            callFidChangeCallbacks(e.data.key, e.data.fid);\r\n        };\r\n    }\r\n    return broadcastChannel;\r\n}\r\nfunction closeBroadcastChannel() {\r\n    if (fidChangeCallbacks.size === 0 && broadcastChannel) {\r\n        broadcastChannel.close();\r\n        broadcastChannel = null;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar DATABASE_NAME = 'firebase-installations-database';\r\nvar DATABASE_VERSION = 1;\r\nvar OBJECT_STORE_NAME = 'firebase-installations-store';\r\nvar dbPromise = null;\r\nfunction getDbPromise() {\r\n    if (!dbPromise) {\r\n        dbPromise = Object(idb[\"openDb\"])(DATABASE_NAME, DATABASE_VERSION, function (upgradeDB) {\r\n            // We don't use 'break' in this switch statement, the fall-through\r\n            // behavior is what we want, because if there are multiple versions between\r\n            // the old version and the current version, we want ALL the migrations\r\n            // that correspond to those versions to run, not only the last one.\r\n            // eslint-disable-next-line default-case\r\n            switch (upgradeDB.oldVersion) {\r\n                case 0:\r\n                    upgradeDB.createObjectStore(OBJECT_STORE_NAME);\r\n            }\r\n        });\r\n    }\r\n    return dbPromise;\r\n}\r\n/** Assigns or overwrites the record for the given key with the given value. */\r\nfunction set(appConfig, value) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var key, db, tx, objectStore, oldValue;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    key = getKey(appConfig);\r\n                    return [4 /*yield*/, getDbPromise()];\r\n                case 1:\r\n                    db = _a.sent();\r\n                    tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n                    objectStore = tx.objectStore(OBJECT_STORE_NAME);\r\n                    return [4 /*yield*/, objectStore.get(key)];\r\n                case 2:\r\n                    oldValue = _a.sent();\r\n                    return [4 /*yield*/, objectStore.put(value, key)];\r\n                case 3:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, tx.complete];\r\n                case 4:\r\n                    _a.sent();\r\n                    if (!oldValue || oldValue.fid !== value.fid) {\r\n                        fidChanged(appConfig, value.fid);\r\n                    }\r\n                    return [2 /*return*/, value];\r\n            }\r\n        });\r\n    });\r\n}\r\n/** Removes record(s) from the objectStore that match the given key. */\r\nfunction remove(appConfig) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var key, db, tx;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    key = getKey(appConfig);\r\n                    return [4 /*yield*/, getDbPromise()];\r\n                case 1:\r\n                    db = _a.sent();\r\n                    tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n                    return [4 /*yield*/, tx.objectStore(OBJECT_STORE_NAME).delete(key)];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, tx.complete];\r\n                case 3:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Atomically updates a record with the result of updateFn, which gets\r\n * called with the current value. If newValue is undefined, the record is\r\n * deleted instead.\r\n * @return Updated value\r\n */\r\nfunction update(appConfig, updateFn) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var key, db, tx, store, oldValue, newValue;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    key = getKey(appConfig);\r\n                    return [4 /*yield*/, getDbPromise()];\r\n                case 1:\r\n                    db = _a.sent();\r\n                    tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n                    store = tx.objectStore(OBJECT_STORE_NAME);\r\n                    return [4 /*yield*/, store.get(key)];\r\n                case 2:\r\n                    oldValue = _a.sent();\r\n                    newValue = updateFn(oldValue);\r\n                    if (!(newValue === undefined)) return [3 /*break*/, 4];\r\n                    return [4 /*yield*/, store.delete(key)];\r\n                case 3:\r\n                    _a.sent();\r\n                    return [3 /*break*/, 6];\r\n                case 4: return [4 /*yield*/, store.put(newValue, key)];\r\n                case 5:\r\n                    _a.sent();\r\n                    _a.label = 6;\r\n                case 6: return [4 /*yield*/, tx.complete];\r\n                case 7:\r\n                    _a.sent();\r\n                    if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {\r\n                        fidChanged(appConfig, newValue.fid);\r\n                    }\r\n                    return [2 /*return*/, newValue];\r\n            }\r\n        });\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Updates and returns the InstallationEntry from the database.\r\n * Also triggers a registration request if it is necessary and possible.\r\n */\r\nfunction getInstallationEntry(appConfig) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var registrationPromise, installationEntry;\r\n        var _a;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0: return [4 /*yield*/, update(appConfig, function (oldEntry) {\r\n                        var installationEntry = updateOrCreateInstallationEntry(oldEntry);\r\n                        var entryWithPromise = triggerRegistrationIfNecessary(appConfig, installationEntry);\r\n                        registrationPromise = entryWithPromise.registrationPromise;\r\n                        return entryWithPromise.installationEntry;\r\n                    })];\r\n                case 1:\r\n                    installationEntry = _b.sent();\r\n                    if (!(installationEntry.fid === INVALID_FID)) return [3 /*break*/, 3];\r\n                    _a = {};\r\n                    return [4 /*yield*/, registrationPromise];\r\n                case 2: \r\n                // FID generation failed. Waiting for the FID from the server.\r\n                return [2 /*return*/, (_a.installationEntry = _b.sent(), _a)];\r\n                case 3: return [2 /*return*/, {\r\n                        installationEntry: installationEntry,\r\n                        registrationPromise: registrationPromise\r\n                    }];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Creates a new Installation Entry if one does not exist.\r\n * Also clears timed out pending requests.\r\n */\r\nfunction updateOrCreateInstallationEntry(oldEntry) {\r\n    var entry = oldEntry || {\r\n        fid: generateFid(),\r\n        registrationStatus: 0 /* NOT_STARTED */\r\n    };\r\n    return clearTimedOutRequest(entry);\r\n}\r\n/**\r\n * If the Firebase Installation is not registered yet, this will trigger the\r\n * registration and return an InProgressInstallationEntry.\r\n *\r\n * If registrationPromise does not exist, the installationEntry is guaranteed\r\n * to be registered.\r\n */\r\nfunction triggerRegistrationIfNecessary(appConfig, installationEntry) {\r\n    if (installationEntry.registrationStatus === 0 /* NOT_STARTED */) {\r\n        if (!navigator.onLine) {\r\n            // Registration required but app is offline.\r\n            var registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create(\"app-offline\" /* APP_OFFLINE */));\r\n            return {\r\n                installationEntry: installationEntry,\r\n                registrationPromise: registrationPromiseWithError\r\n            };\r\n        }\r\n        // Try registering. Change status to IN_PROGRESS.\r\n        var inProgressEntry = {\r\n            fid: installationEntry.fid,\r\n            registrationStatus: 1 /* IN_PROGRESS */,\r\n            registrationTime: Date.now()\r\n        };\r\n        var registrationPromise = registerInstallation(appConfig, inProgressEntry);\r\n        return { installationEntry: inProgressEntry, registrationPromise: registrationPromise };\r\n    }\r\n    else if (installationEntry.registrationStatus === 1 /* IN_PROGRESS */) {\r\n        return {\r\n            installationEntry: installationEntry,\r\n            registrationPromise: waitUntilFidRegistration(appConfig)\r\n        };\r\n    }\r\n    else {\r\n        return { installationEntry: installationEntry };\r\n    }\r\n}\r\n/** This will be executed only once for each new Firebase Installation. */\r\nfunction registerInstallation(appConfig, installationEntry) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var registeredInstallationEntry, e_1;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    _a.trys.push([0, 2, , 7]);\r\n                    return [4 /*yield*/, createInstallationRequest(appConfig, installationEntry)];\r\n                case 1:\r\n                    registeredInstallationEntry = _a.sent();\r\n                    return [2 /*return*/, set(appConfig, registeredInstallationEntry)];\r\n                case 2:\r\n                    e_1 = _a.sent();\r\n                    if (!(isServerError(e_1) && e_1.serverCode === 409)) return [3 /*break*/, 4];\r\n                    // Server returned a \"FID can not be used\" error.\r\n                    // Generate a new ID next time.\r\n                    return [4 /*yield*/, remove(appConfig)];\r\n                case 3:\r\n                    // Server returned a \"FID can not be used\" error.\r\n                    // Generate a new ID next time.\r\n                    _a.sent();\r\n                    return [3 /*break*/, 6];\r\n                case 4: \r\n                // Registration failed. Set FID as not registered.\r\n                return [4 /*yield*/, set(appConfig, {\r\n                        fid: installationEntry.fid,\r\n                        registrationStatus: 0 /* NOT_STARTED */\r\n                    })];\r\n                case 5:\r\n                    // Registration failed. Set FID as not registered.\r\n                    _a.sent();\r\n                    _a.label = 6;\r\n                case 6: throw e_1;\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n/** Call if FID registration is pending in another request. */\r\nfunction waitUntilFidRegistration(appConfig) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var entry, _a, installationEntry, registrationPromise;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0: return [4 /*yield*/, updateInstallationRequest(appConfig)];\r\n                case 1:\r\n                    entry = _b.sent();\r\n                    _b.label = 2;\r\n                case 2:\r\n                    if (!(entry.registrationStatus === 1 /* IN_PROGRESS */)) return [3 /*break*/, 5];\r\n                    // createInstallation request still in progress.\r\n                    return [4 /*yield*/, sleep(100)];\r\n                case 3:\r\n                    // createInstallation request still in progress.\r\n                    _b.sent();\r\n                    return [4 /*yield*/, updateInstallationRequest(appConfig)];\r\n                case 4:\r\n                    entry = _b.sent();\r\n                    return [3 /*break*/, 2];\r\n                case 5:\r\n                    if (!(entry.registrationStatus === 0 /* NOT_STARTED */)) return [3 /*break*/, 7];\r\n                    return [4 /*yield*/, getInstallationEntry(appConfig)];\r\n                case 6:\r\n                    _a = _b.sent(), installationEntry = _a.installationEntry, registrationPromise = _a.registrationPromise;\r\n                    if (registrationPromise) {\r\n                        return [2 /*return*/, registrationPromise];\r\n                    }\r\n                    else {\r\n                        // if there is no registrationPromise, entry is registered.\r\n                        return [2 /*return*/, installationEntry];\r\n                    }\r\n                case 7: return [2 /*return*/, entry];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Called only if there is a CreateInstallation request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * CreateInstallation request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */\r\nfunction updateInstallationRequest(appConfig) {\r\n    return update(appConfig, function (oldEntry) {\r\n        if (!oldEntry) {\r\n            throw ERROR_FACTORY.create(\"installation-not-found\" /* INSTALLATION_NOT_FOUND */);\r\n        }\r\n        return clearTimedOutRequest(oldEntry);\r\n    });\r\n}\r\nfunction clearTimedOutRequest(entry) {\r\n    if (hasInstallationRequestTimedOut(entry)) {\r\n        return {\r\n            fid: entry.fid,\r\n            registrationStatus: 0 /* NOT_STARTED */\r\n        };\r\n    }\r\n    return entry;\r\n}\r\nfunction hasInstallationRequestTimedOut(installationEntry) {\r\n    return (installationEntry.registrationStatus === 1 /* IN_PROGRESS */ &&\r\n        installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now());\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction generateAuthTokenRequest(_a, installationEntry) {\r\n    var appConfig = _a.appConfig, platformLoggerProvider = _a.platformLoggerProvider;\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var endpoint, headers, platformLogger, body, request, response, responseValue, completedAuthToken;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\r\n                    headers = getHeadersWithAuth(appConfig, installationEntry);\r\n                    platformLogger = platformLoggerProvider.getImmediate({\r\n                        optional: true\r\n                    });\r\n                    if (platformLogger) {\r\n                        headers.append('x-firebase-client', platformLogger.getPlatformInfoString());\r\n                    }\r\n                    body = {\r\n                        installation: {\r\n                            sdkVersion: PACKAGE_VERSION\r\n                        }\r\n                    };\r\n                    request = {\r\n                        method: 'POST',\r\n                        headers: headers,\r\n                        body: JSON.stringify(body)\r\n                    };\r\n                    return [4 /*yield*/, retryIfServerError(function () { return fetch(endpoint, request); })];\r\n                case 1:\r\n                    response = _b.sent();\r\n                    if (!response.ok) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, response.json()];\r\n                case 2:\r\n                    responseValue = _b.sent();\r\n                    completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);\r\n                    return [2 /*return*/, completedAuthToken];\r\n                case 3: return [4 /*yield*/, getErrorFromResponse('Generate Auth Token', response)];\r\n                case 4: throw _b.sent();\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction getGenerateAuthTokenEndpoint(appConfig, _a) {\r\n    var fid = _a.fid;\r\n    return getInstallationsEndpoint(appConfig) + \"/\" + fid + \"/authTokens:generate\";\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a valid authentication token for the installation. Generates a new\r\n * token if one doesn't exist, is expired or about to expire.\r\n *\r\n * Should only be called if the Firebase Installation is registered.\r\n */\r\nfunction refreshAuthToken(dependencies, forceRefresh) {\r\n    if (forceRefresh === void 0) { forceRefresh = false; }\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var tokenPromise, entry, authToken, _a;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0: return [4 /*yield*/, update(dependencies.appConfig, function (oldEntry) {\r\n                        if (!isEntryRegistered(oldEntry)) {\r\n                            throw ERROR_FACTORY.create(\"not-registered\" /* NOT_REGISTERED */);\r\n                        }\r\n                        var oldAuthToken = oldEntry.authToken;\r\n                        if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\r\n                            // There is a valid token in the DB.\r\n                            return oldEntry;\r\n                        }\r\n                        else if (oldAuthToken.requestStatus === 1 /* IN_PROGRESS */) {\r\n                            // There already is a token request in progress.\r\n                            tokenPromise = waitUntilAuthTokenRequest(dependencies, forceRefresh);\r\n                            return oldEntry;\r\n                        }\r\n                        else {\r\n                            // No token or token expired.\r\n                            if (!navigator.onLine) {\r\n                                throw ERROR_FACTORY.create(\"app-offline\" /* APP_OFFLINE */);\r\n                            }\r\n                            var inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\r\n                            tokenPromise = fetchAuthTokenFromServer(dependencies, inProgressEntry);\r\n                            return inProgressEntry;\r\n                        }\r\n                    })];\r\n                case 1:\r\n                    entry = _b.sent();\r\n                    if (!tokenPromise) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, tokenPromise];\r\n                case 2:\r\n                    _a = _b.sent();\r\n                    return [3 /*break*/, 4];\r\n                case 3:\r\n                    _a = entry.authToken;\r\n                    _b.label = 4;\r\n                case 4:\r\n                    authToken = _a;\r\n                    return [2 /*return*/, authToken];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Call only if FID is registered and Auth Token request is in progress.\r\n *\r\n * Waits until the current pending request finishes. If the request times out,\r\n * tries once in this thread as well.\r\n */\r\nfunction waitUntilAuthTokenRequest(dependencies, forceRefresh) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var entry, authToken;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, updateAuthTokenRequest(dependencies.appConfig)];\r\n                case 1:\r\n                    entry = _a.sent();\r\n                    _a.label = 2;\r\n                case 2:\r\n                    if (!(entry.authToken.requestStatus === 1 /* IN_PROGRESS */)) return [3 /*break*/, 5];\r\n                    // generateAuthToken still in progress.\r\n                    return [4 /*yield*/, sleep(100)];\r\n                case 3:\r\n                    // generateAuthToken still in progress.\r\n                    _a.sent();\r\n                    return [4 /*yield*/, updateAuthTokenRequest(dependencies.appConfig)];\r\n                case 4:\r\n                    entry = _a.sent();\r\n                    return [3 /*break*/, 2];\r\n                case 5:\r\n                    authToken = entry.authToken;\r\n                    if (authToken.requestStatus === 0 /* NOT_STARTED */) {\r\n                        // The request timed out or failed in a different call. Try again.\r\n                        return [2 /*return*/, refreshAuthToken(dependencies, forceRefresh)];\r\n                    }\r\n                    else {\r\n                        return [2 /*return*/, authToken];\r\n                    }\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Called only if there is a GenerateAuthToken request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * GenerateAuthToken request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */\r\nfunction updateAuthTokenRequest(appConfig) {\r\n    return update(appConfig, function (oldEntry) {\r\n        if (!isEntryRegistered(oldEntry)) {\r\n            throw ERROR_FACTORY.create(\"not-registered\" /* NOT_REGISTERED */);\r\n        }\r\n        var oldAuthToken = oldEntry.authToken;\r\n        if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\r\n            return Object(tslib_es6[\"__assign\"])(Object(tslib_es6[\"__assign\"])({}, oldEntry), { authToken: { requestStatus: 0 /* NOT_STARTED */ } });\r\n        }\r\n        return oldEntry;\r\n    });\r\n}\r\nfunction fetchAuthTokenFromServer(dependencies, installationEntry) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var authToken, updatedInstallationEntry, e_1, updatedInstallationEntry;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    _a.trys.push([0, 3, , 8]);\r\n                    return [4 /*yield*/, generateAuthTokenRequest(dependencies, installationEntry)];\r\n                case 1:\r\n                    authToken = _a.sent();\r\n                    updatedInstallationEntry = Object(tslib_es6[\"__assign\"])(Object(tslib_es6[\"__assign\"])({}, installationEntry), { authToken: authToken });\r\n                    return [4 /*yield*/, set(dependencies.appConfig, updatedInstallationEntry)];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [2 /*return*/, authToken];\r\n                case 3:\r\n                    e_1 = _a.sent();\r\n                    if (!(isServerError(e_1) && (e_1.serverCode === 401 || e_1.serverCode === 404))) return [3 /*break*/, 5];\r\n                    // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\r\n                    // Generate a new ID next time.\r\n                    return [4 /*yield*/, remove(dependencies.appConfig)];\r\n                case 4:\r\n                    // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\r\n                    // Generate a new ID next time.\r\n                    _a.sent();\r\n                    return [3 /*break*/, 7];\r\n                case 5:\r\n                    updatedInstallationEntry = Object(tslib_es6[\"__assign\"])(Object(tslib_es6[\"__assign\"])({}, installationEntry), { authToken: { requestStatus: 0 /* NOT_STARTED */ } });\r\n                    return [4 /*yield*/, set(dependencies.appConfig, updatedInstallationEntry)];\r\n                case 6:\r\n                    _a.sent();\r\n                    _a.label = 7;\r\n                case 7: throw e_1;\r\n                case 8: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction isEntryRegistered(installationEntry) {\r\n    return (installationEntry !== undefined &&\r\n        installationEntry.registrationStatus === 2 /* COMPLETED */);\r\n}\r\nfunction isAuthTokenValid(authToken) {\r\n    return (authToken.requestStatus === 2 /* COMPLETED */ &&\r\n        !isAuthTokenExpired(authToken));\r\n}\r\nfunction isAuthTokenExpired(authToken) {\r\n    var now = Date.now();\r\n    return (now < authToken.creationTime ||\r\n        authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER);\r\n}\r\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */\r\nfunction makeAuthTokenRequestInProgressEntry(oldEntry) {\r\n    var inProgressAuthToken = {\r\n        requestStatus: 1 /* IN_PROGRESS */,\r\n        requestTime: Date.now()\r\n    };\r\n    return Object(tslib_es6[\"__assign\"])(Object(tslib_es6[\"__assign\"])({}, oldEntry), { authToken: inProgressAuthToken });\r\n}\r\nfunction hasAuthTokenRequestTimedOut(authToken) {\r\n    return (authToken.requestStatus === 1 /* IN_PROGRESS */ &&\r\n        authToken.requestTime + PENDING_TIMEOUT_MS < Date.now());\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getId(dependencies) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var _a, installationEntry, registrationPromise;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0: return [4 /*yield*/, getInstallationEntry(dependencies.appConfig)];\r\n                case 1:\r\n                    _a = _b.sent(), installationEntry = _a.installationEntry, registrationPromise = _a.registrationPromise;\r\n                    if (registrationPromise) {\r\n                        registrationPromise.catch(console.error);\r\n                    }\r\n                    else {\r\n                        // If the installation is already registered, update the authentication\r\n                        // token if needed.\r\n                        refreshAuthToken(dependencies).catch(console.error);\r\n                    }\r\n                    return [2 /*return*/, installationEntry.fid];\r\n            }\r\n        });\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getToken(dependencies, forceRefresh) {\r\n    if (forceRefresh === void 0) { forceRefresh = false; }\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var authToken;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, completeInstallationRegistration(dependencies.appConfig)];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, refreshAuthToken(dependencies, forceRefresh)];\r\n                case 2:\r\n                    authToken = _a.sent();\r\n                    return [2 /*return*/, authToken.token];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction completeInstallationRegistration(appConfig) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var registrationPromise;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, getInstallationEntry(appConfig)];\r\n                case 1:\r\n                    registrationPromise = (_a.sent()).registrationPromise;\r\n                    if (!registrationPromise) return [3 /*break*/, 3];\r\n                    // A createInstallation request is in progress. Wait until it finishes.\r\n                    return [4 /*yield*/, registrationPromise];\r\n                case 2:\r\n                    // A createInstallation request is in progress. Wait until it finishes.\r\n                    _a.sent();\r\n                    _a.label = 3;\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction deleteInstallationRequest(appConfig, installationEntry) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var endpoint, headers, request, response;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    endpoint = getDeleteEndpoint(appConfig, installationEntry);\r\n                    headers = getHeadersWithAuth(appConfig, installationEntry);\r\n                    request = {\r\n                        method: 'DELETE',\r\n                        headers: headers\r\n                    };\r\n                    return [4 /*yield*/, retryIfServerError(function () { return fetch(endpoint, request); })];\r\n                case 1:\r\n                    response = _a.sent();\r\n                    if (!!response.ok) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, getErrorFromResponse('Delete Installation', response)];\r\n                case 2: throw _a.sent();\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction getDeleteEndpoint(appConfig, _a) {\r\n    var fid = _a.fid;\r\n    return getInstallationsEndpoint(appConfig) + \"/\" + fid;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction deleteInstallation(dependencies) {\r\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\r\n        var appConfig, entry;\r\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    appConfig = dependencies.appConfig;\r\n                    return [4 /*yield*/, update(appConfig, function (oldEntry) {\r\n                            if (oldEntry && oldEntry.registrationStatus === 0 /* NOT_STARTED */) {\r\n                                // Delete the unregistered entry without sending a deleteInstallation request.\r\n                                return undefined;\r\n                            }\r\n                            return oldEntry;\r\n                        })];\r\n                case 1:\r\n                    entry = _a.sent();\r\n                    if (!entry) return [3 /*break*/, 6];\r\n                    if (!(entry.registrationStatus === 1 /* IN_PROGRESS */)) return [3 /*break*/, 2];\r\n                    // Can't delete while trying to register.\r\n                    throw ERROR_FACTORY.create(\"delete-pending-registration\" /* DELETE_PENDING_REGISTRATION */);\r\n                case 2:\r\n                    if (!(entry.registrationStatus === 2 /* COMPLETED */)) return [3 /*break*/, 6];\r\n                    if (!!navigator.onLine) return [3 /*break*/, 3];\r\n                    throw ERROR_FACTORY.create(\"app-offline\" /* APP_OFFLINE */);\r\n                case 3: return [4 /*yield*/, deleteInstallationRequest(appConfig, entry)];\r\n                case 4:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, remove(appConfig)];\r\n                case 5:\r\n                    _a.sent();\r\n                    _a.label = 6;\r\n                case 6: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Sets a new callback that will get called when Installation ID changes.\r\n * Returns an unsubscribe function that will remove the callback when called.\r\n */\r\nfunction onIdChange(_a, callback) {\r\n    var appConfig = _a.appConfig;\r\n    addCallback(appConfig, callback);\r\n    return function () {\r\n        removeCallback(appConfig, callback);\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction extractAppConfig(app) {\r\n    var e_1, _a;\r\n    if (!app || !app.options) {\r\n        throw getMissingValueError('App Configuration');\r\n    }\r\n    if (!app.name) {\r\n        throw getMissingValueError('App Name');\r\n    }\r\n    // Required app config keys\r\n    var configKeys = [\r\n        'projectId',\r\n        'apiKey',\r\n        'appId'\r\n    ];\r\n    try {\r\n        for (var configKeys_1 = Object(tslib_es6[\"__values\"])(configKeys), configKeys_1_1 = configKeys_1.next(); !configKeys_1_1.done; configKeys_1_1 = configKeys_1.next()) {\r\n            var keyName = configKeys_1_1.value;\r\n            if (!app.options[keyName]) {\r\n                throw getMissingValueError(keyName);\r\n            }\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (configKeys_1_1 && !configKeys_1_1.done && (_a = configKeys_1.return)) _a.call(configKeys_1);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    return {\r\n        appName: app.name,\r\n        projectId: app.options.projectId,\r\n        apiKey: app.options.apiKey,\r\n        appId: app.options.appId\r\n    };\r\n}\r\nfunction getMissingValueError(valueName) {\r\n    return ERROR_FACTORY.create(\"missing-app-config-values\" /* MISSING_APP_CONFIG_VALUES */, {\r\n        valueName: valueName\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction registerInstallations(instance) {\r\n    var installationsName = 'installations';\r\n    instance.INTERNAL.registerComponent(new dist_index_cjs[\"Component\"](installationsName, function (container) {\r\n        var app = container.getProvider('app').getImmediate();\r\n        // Throws if app isn't configured properly.\r\n        var appConfig = extractAppConfig(app);\r\n        var platformLoggerProvider = container.getProvider('platform-logger');\r\n        var dependencies = {\r\n            appConfig: appConfig,\r\n            platformLoggerProvider: platformLoggerProvider\r\n        };\r\n        var installations = {\r\n            app: app,\r\n            getId: function () { return getId(dependencies); },\r\n            getToken: function (forceRefresh) {\r\n                return getToken(dependencies, forceRefresh);\r\n            },\r\n            delete: function () { return deleteInstallation(dependencies); },\r\n            onIdChange: function (callback) {\r\n                return onIdChange(dependencies, callback);\r\n            }\r\n        };\r\n        return installations;\r\n    }, \"PUBLIC\" /* PUBLIC */));\r\n    instance.registerVersion(index_esm_name, version);\r\n}\r\nregisterInstallations(index_cjs_default.a);\n\n\n//# sourceMappingURL=index.esm.js.map\n\n// EXTERNAL MODULE: ./node_modules/@firebase/logger/dist/index.esm.js\nvar index_esm = __webpack_require__(\"q/0M\");\n\n// CONCATENATED MODULE: ./node_modules/@firebase/analytics/dist/index.esm.js\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Key to attach FID to in gtag params.\nvar GA_FID_KEY = 'firebase_id';\nvar ORIGIN_KEY = 'origin';\nvar FETCH_TIMEOUT_MILLIS = 60 * 1000;\nvar DYNAMIC_CONFIG_URL = 'https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig';\nvar GTAG_URL = 'https://www.googletagmanager.com/gtag/js';\nvar GtagCommand = /*@__PURE__*/ (function (GtagCommand) {\n    GtagCommand[\"EVENT\"] = \"event\";\n    GtagCommand[\"SET\"] = \"set\";\n    GtagCommand[\"CONFIG\"] = \"config\";\n    return GtagCommand;\n})({});\n/*\n * Officially recommended event names for gtag.js\n * Any other string is also allowed.\n */\nvar EventName = /*@__PURE__*/ (function (EventName) {\n    EventName[\"ADD_SHIPPING_INFO\"] = \"add_shipping_info\";\n    EventName[\"ADD_PAYMENT_INFO\"] = \"add_payment_info\";\n    EventName[\"ADD_TO_CART\"] = \"add_to_cart\";\n    EventName[\"ADD_TO_WISHLIST\"] = \"add_to_wishlist\";\n    EventName[\"BEGIN_CHECKOUT\"] = \"begin_checkout\";\n    /** @deprecated */\n    EventName[\"CHECKOUT_PROGRESS\"] = \"checkout_progress\";\n    EventName[\"EXCEPTION\"] = \"exception\";\n    EventName[\"GENERATE_LEAD\"] = \"generate_lead\";\n    EventName[\"LOGIN\"] = \"login\";\n    EventName[\"PAGE_VIEW\"] = \"page_view\";\n    EventName[\"PURCHASE\"] = \"purchase\";\n    EventName[\"REFUND\"] = \"refund\";\n    EventName[\"REMOVE_FROM_CART\"] = \"remove_from_cart\";\n    EventName[\"SCREEN_VIEW\"] = \"screen_view\";\n    EventName[\"SEARCH\"] = \"search\";\n    EventName[\"SELECT_CONTENT\"] = \"select_content\";\n    EventName[\"SELECT_ITEM\"] = \"select_item\";\n    EventName[\"SELECT_PROMOTION\"] = \"select_promotion\";\n    /** @deprecated */\n    EventName[\"SET_CHECKOUT_OPTION\"] = \"set_checkout_option\";\n    EventName[\"SHARE\"] = \"share\";\n    EventName[\"SIGN_UP\"] = \"sign_up\";\n    EventName[\"TIMING_COMPLETE\"] = \"timing_complete\";\n    EventName[\"VIEW_CART\"] = \"view_cart\";\n    EventName[\"VIEW_ITEM\"] = \"view_item\";\n    EventName[\"VIEW_ITEM_LIST\"] = \"view_item_list\";\n    EventName[\"VIEW_PROMOTION\"] = \"view_promotion\";\n    EventName[\"VIEW_SEARCH_RESULTS\"] = \"view_search_results\";\n    return EventName;\n})({});\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Logs an analytics event through the Firebase SDK.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param eventName Google Analytics event name, choose from standard list or use a custom string.\n * @param eventParams Analytics event parameters.\n */\nfunction logEvent(gtagFunction, initializationPromise, eventName, eventParams, options) {\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n        var measurementId, params;\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!(options && options.global))\n                        return [3 /*break*/, 1];\n                    gtagFunction(GtagCommand.EVENT, eventName, eventParams);\n                    return [2 /*return*/];\n                case 1: return [4 /*yield*/, initializationPromise];\n                case 2:\n                    measurementId = _a.sent();\n                    params = Object(tslib_es6[\"__assign\"])(Object(tslib_es6[\"__assign\"])({}, eventParams), { 'send_to': measurementId });\n                    gtagFunction(GtagCommand.EVENT, eventName, params);\n                    _a.label = 3;\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Set screen_name parameter for this Google Analytics ID.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param screenName Screen name string to set.\n */\nfunction setCurrentScreen(gtagFunction, initializationPromise, screenName, options) {\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n        var measurementId;\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!(options && options.global))\n                        return [3 /*break*/, 1];\n                    gtagFunction(GtagCommand.SET, { 'screen_name': screenName });\n                    return [2 /*return*/, Promise.resolve()];\n                case 1: return [4 /*yield*/, initializationPromise];\n                case 2:\n                    measurementId = _a.sent();\n                    gtagFunction(GtagCommand.CONFIG, measurementId, {\n                        update: true,\n                        'screen_name': screenName\n                    });\n                    _a.label = 3;\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Set user_id parameter for this Google Analytics ID.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param id User ID string to set\n */\nfunction setUserId(gtagFunction, initializationPromise, id, options) {\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n        var measurementId;\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!(options && options.global))\n                        return [3 /*break*/, 1];\n                    gtagFunction(GtagCommand.SET, { 'user_id': id });\n                    return [2 /*return*/, Promise.resolve()];\n                case 1: return [4 /*yield*/, initializationPromise];\n                case 2:\n                    measurementId = _a.sent();\n                    gtagFunction(GtagCommand.CONFIG, measurementId, {\n                        update: true,\n                        'user_id': id\n                    });\n                    _a.label = 3;\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Set all other user properties other than user_id and screen_name.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param properties Map of user properties to set\n */\nfunction setUserProperties(gtagFunction, initializationPromise, properties, options) {\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n        var flatProperties, _i, _a, key, measurementId;\n        return Object(tslib_es6[\"__generator\"])(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (!(options && options.global))\n                        return [3 /*break*/, 1];\n                    flatProperties = {};\n                    for (_i = 0, _a = Object.keys(properties); _i < _a.length; _i++) {\n                        key = _a[_i];\n                        // use dot notation for merge behavior in gtag.js\n                        flatProperties[\"user_properties.\" + key] = properties[key];\n                    }\n                    gtagFunction(GtagCommand.SET, flatProperties);\n                    return [2 /*return*/, Promise.resolve()];\n                case 1: return [4 /*yield*/, initializationPromise];\n                case 2:\n                    measurementId = _b.sent();\n                    gtagFunction(GtagCommand.CONFIG, measurementId, {\n                        update: true,\n                        'user_properties': properties\n                    });\n                    _b.label = 3;\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Set whether collection is enabled for this ID.\n *\n * @param enabled If true, collection is enabled for this ID.\n */\nfunction setAnalyticsCollectionEnabled(initializationPromise, enabled) {\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n        var measurementId;\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, initializationPromise];\n                case 1:\n                    measurementId = _a.sent();\n                    window[\"ga-disable-\" + measurementId] = !enabled;\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar logger = new index_esm[\"Logger\"]('@firebase/analytics');\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Inserts gtag script tag into the page to asynchronously download gtag.\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\n */\nfunction insertScriptTag(dataLayerName) {\n    var script = document.createElement('script');\n    // We are not providing an analyticsId in the URL because it would trigger a `page_view`\n    // without fid. We will initialize ga-id using gtag (config) command together with fid.\n    script.src = GTAG_URL + \"?l=\" + dataLayerName;\n    script.async = true;\n    document.head.appendChild(script);\n}\n/**\n * Get reference to, or create, global datalayer.\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\n */\nfunction getOrCreateDataLayer(dataLayerName) {\n    // Check for existing dataLayer and create if needed.\n    var dataLayer = [];\n    if (Array.isArray(window[dataLayerName])) {\n        dataLayer = window[dataLayerName];\n    }\n    else {\n        window[dataLayerName] = dataLayer;\n    }\n    return dataLayer;\n}\n/**\n * Wrapped gtag logic when gtag is called with 'config' command.\n *\n * @param gtagCore Basic gtag function that just appends to dataLayer.\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\n * @param measurementId GA Measurement ID to set config for.\n * @param gtagParams Gtag config params to set.\n */\nfunction gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams) {\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n        var correspondingAppId, dynamicConfigResults, foundConfig, e_1;\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    correspondingAppId = measurementIdToAppId[measurementId];\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 7, , 8]);\n                    if (!correspondingAppId)\n                        return [3 /*break*/, 3];\n                    return [4 /*yield*/, initializationPromisesMap[correspondingAppId]];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 6];\n                case 3: return [4 /*yield*/, Promise.all(dynamicConfigPromisesList)];\n                case 4:\n                    dynamicConfigResults = _a.sent();\n                    foundConfig = dynamicConfigResults.find(function (config) { return config.measurementId === measurementId; });\n                    if (!foundConfig)\n                        return [3 /*break*/, 6];\n                    return [4 /*yield*/, initializationPromisesMap[foundConfig.appId]];\n                case 5:\n                    _a.sent();\n                    _a.label = 6;\n                case 6: return [3 /*break*/, 8];\n                case 7:\n                    e_1 = _a.sent();\n                    logger.error(e_1);\n                    return [3 /*break*/, 8];\n                case 8:\n                    gtagCore(GtagCommand.CONFIG, measurementId, gtagParams);\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Wrapped gtag logic when gtag is called with 'event' command.\n *\n * @param gtagCore Basic gtag function that just appends to dataLayer.\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementId GA Measurement ID to log event to.\n * @param gtagParams Params to log with this event.\n */\nfunction gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams) {\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n        var initializationPromisesToWaitFor, gaSendToList, dynamicConfigResults, _loop_1, _i, gaSendToList_1, sendToId, state_1, e_2;\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 4, , 5]);\n                    initializationPromisesToWaitFor = [];\n                    if (!(gtagParams && gtagParams['send_to']))\n                        return [3 /*break*/, 2];\n                    gaSendToList = gtagParams['send_to'];\n                    // Make it an array if is isn't, so it can be dealt with the same way.\n                    if (!Array.isArray(gaSendToList)) {\n                        gaSendToList = [gaSendToList];\n                    }\n                    return [4 /*yield*/, Promise.all(dynamicConfigPromisesList)];\n                case 1:\n                    dynamicConfigResults = _a.sent();\n                    _loop_1 = function (sendToId) {\n                        // Any fetched dynamic measurement ID that matches this 'send_to' ID\n                        var foundConfig = dynamicConfigResults.find(function (config) { return config.measurementId === sendToId; });\n                        var initializationPromise = foundConfig && initializationPromisesMap[foundConfig.appId];\n                        if (initializationPromise) {\n                            initializationPromisesToWaitFor.push(initializationPromise);\n                        }\n                        else {\n                            // Found an item in 'send_to' that is not associated\n                            // directly with an FID, possibly a group.  Empty this array,\n                            // exit the loop early, and let it get populated below.\n                            initializationPromisesToWaitFor = [];\n                            return \"break\";\n                        }\n                    };\n                    for (_i = 0, gaSendToList_1 = gaSendToList; _i < gaSendToList_1.length; _i++) {\n                        sendToId = gaSendToList_1[_i];\n                        state_1 = _loop_1(sendToId);\n                        if (state_1 === \"break\")\n                            break;\n                    }\n                    _a.label = 2;\n                case 2:\n                    // This will be unpopulated if there was no 'send_to' field , or\n                    // if not all entries in the 'send_to' field could be mapped to\n                    // a FID. In these cases, wait on all pending initialization promises.\n                    if (initializationPromisesToWaitFor.length === 0) {\n                        initializationPromisesToWaitFor = Object.values(initializationPromisesMap);\n                    }\n                    // Run core gtag function with args after all relevant initialization\n                    // promises have been resolved.\n                    return [4 /*yield*/, Promise.all(initializationPromisesToWaitFor)];\n                case 3:\n                    // Run core gtag function with args after all relevant initialization\n                    // promises have been resolved.\n                    _a.sent();\n                    // Workaround for http://b/141370449 - third argument cannot be undefined.\n                    gtagCore(GtagCommand.EVENT, measurementId, gtagParams || {});\n                    return [3 /*break*/, 5];\n                case 4:\n                    e_2 = _a.sent();\n                    logger.error(e_2);\n                    return [3 /*break*/, 5];\n                case 5: return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Wraps a standard gtag function with extra code to wait for completion of\n * relevant initialization promises before sending requests.\n *\n * @param gtagCore Basic gtag function that just appends to dataLayer.\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\n */\nfunction wrapGtag(gtagCore, \n/**\n * Allows wrapped gtag calls to wait on whichever intialization promises are required,\n * depending on the contents of the gtag params' `send_to` field, if any.\n */\ninitializationPromisesMap, \n/**\n * Wrapped gtag calls sometimes require all dynamic config fetches to have returned\n * before determining what initialization promises (which include FIDs) to wait for.\n */\ndynamicConfigPromisesList, \n/**\n * Wrapped gtag config calls can narrow down which initialization promise (with FID)\n * to wait for if the measurementId is already fetched, by getting the corresponding appId,\n * which is the key for the initialization promises map.\n */\nmeasurementIdToAppId) {\n    /**\n     * Wrapper around gtag that ensures FID is sent with gtag calls.\n     * @param command Gtag command type.\n     * @param idOrNameOrParams Measurement ID if command is EVENT/CONFIG, params if command is SET.\n     * @param gtagParams Params if event is EVENT/CONFIG.\n     */\n    function gtagWrapper(command, idOrNameOrParams, gtagParams) {\n        return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n            var e_3;\n            return Object(tslib_es6[\"__generator\"])(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 6, , 7]);\n                        if (!(command === GtagCommand.EVENT))\n                            return [3 /*break*/, 2];\n                        // If EVENT, second arg must be measurementId.\n                        return [4 /*yield*/, gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, idOrNameOrParams, gtagParams)];\n                    case 1:\n                        // If EVENT, second arg must be measurementId.\n                        _a.sent();\n                        return [3 /*break*/, 5];\n                    case 2:\n                        if (!(command === GtagCommand.CONFIG))\n                            return [3 /*break*/, 4];\n                        // If CONFIG, second arg must be measurementId.\n                        return [4 /*yield*/, gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, idOrNameOrParams, gtagParams)];\n                    case 3:\n                        // If CONFIG, second arg must be measurementId.\n                        _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        // If SET, second arg must be params.\n                        gtagCore(GtagCommand.SET, idOrNameOrParams);\n                        _a.label = 5;\n                    case 5: return [3 /*break*/, 7];\n                    case 6:\n                        e_3 = _a.sent();\n                        logger.error(e_3);\n                        return [3 /*break*/, 7];\n                    case 7: return [2 /*return*/];\n                }\n            });\n        });\n    }\n    return gtagWrapper;\n}\n/**\n * Creates global gtag function or wraps existing one if found.\n * This wrapped function attaches Firebase instance ID (FID) to gtag 'config' and\n * 'event' calls that belong to the GAID associated with this Firebase instance.\n *\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\n * @param dataLayerName Name of global GA datalayer array.\n * @param gtagFunctionName Name of global gtag function (\"gtag\" if not user-specified).\n */\nfunction wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagFunctionName) {\n    // Create a basic core gtag function\n    var gtagCore = function () {\n        var _args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            _args[_i] = arguments[_i];\n        }\n        // Must push IArguments object, not an array.\n        window[dataLayerName].push(arguments);\n    };\n    // Replace it with existing one if found\n    if (window[gtagFunctionName] &&\n        typeof window[gtagFunctionName] === 'function') {\n        // @ts-ignore\n        gtagCore = window[gtagFunctionName];\n    }\n    window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId);\n    return {\n        gtagCore: gtagCore,\n        wrappedGtag: window[gtagFunctionName]\n    };\n}\n/**\n * Returns first script tag in DOM matching our gtag url pattern.\n */\nfunction findGtagScriptOnPage() {\n    var scriptTags = window.document.getElementsByTagName('script');\n    for (var _i = 0, _a = Object.values(scriptTags); _i < _a.length; _i++) {\n        var tag = _a[_i];\n        if (tag.src && tag.src.includes(GTAG_URL)) {\n            return tag;\n        }\n    }\n    return null;\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar dist_index_esm_a;\nvar ERRORS = (dist_index_esm_a = {},\n    dist_index_esm_a[\"already-exists\" /* ALREADY_EXISTS */] = 'A Firebase Analytics instance with the appId {$id} ' +\n        ' already exists. ' +\n        'Only one Firebase Analytics instance can be created for each appId.',\n    dist_index_esm_a[\"already-initialized\" /* ALREADY_INITIALIZED */] = 'Firebase Analytics has already been initialized.' +\n        'settings() must be called before initializing any Analytics instance' +\n        'or it will have no effect.',\n    dist_index_esm_a[\"interop-component-reg-failed\" /* INTEROP_COMPONENT_REG_FAILED */] = 'Firebase Analytics Interop Component failed to instantiate: {$reason}',\n    dist_index_esm_a[\"invalid-analytics-context\" /* INVALID_ANALYTICS_CONTEXT */] = 'Firebase Analytics is not supported in this environment. ' +\n        'Wrap initialization of analytics in analytics.isSupported() ' +\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\n    dist_index_esm_a[\"indexeddb-unavailable\" /* INDEXEDDB_UNAVAILABLE */] = 'IndexedDB unavailable or restricted in this environment. ' +\n        'Wrap initialization of analytics in analytics.isSupported() ' +\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\n    dist_index_esm_a[\"fetch-throttle\" /* FETCH_THROTTLE */] = 'The config fetch request timed out while in an exponential backoff state.' +\n        ' Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',\n    dist_index_esm_a[\"config-fetch-failed\" /* CONFIG_FETCH_FAILED */] = 'Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}',\n    dist_index_esm_a[\"no-api-key\" /* NO_API_KEY */] = 'The \"apiKey\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\n        'contain a valid API key.',\n    dist_index_esm_a[\"no-app-id\" /* NO_APP_ID */] = 'The \"appId\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\n        'contain a valid app ID.',\n    dist_index_esm_a);\nvar index_esm_ERROR_FACTORY = new util_dist_index_cjs[\"ErrorFactory\"]('analytics', 'Analytics', ERRORS);\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Backoff factor for 503 errors, which we want to be conservative about\n * to avoid overloading servers. Each retry interval will be\n * BASE_INTERVAL_MILLIS * LONG_RETRY_FACTOR ^ retryCount, so the second one\n * will be ~30 seconds (with fuzzing).\n */\nvar LONG_RETRY_FACTOR = 30;\n/**\n * Base wait interval to multiplied by backoffFactor^backoffCount.\n */\nvar BASE_INTERVAL_MILLIS = 1000;\n/**\n * Stubbable retry data storage class.\n */\nvar RetryData = /** @class */ /*@__PURE__*/ (function () {\n    function RetryData(throttleMetadata, intervalMillis) {\n        if (throttleMetadata === void 0) {\n            throttleMetadata = {};\n        }\n        if (intervalMillis === void 0) {\n            intervalMillis = BASE_INTERVAL_MILLIS;\n        }\n        this.throttleMetadata = throttleMetadata;\n        this.intervalMillis = intervalMillis;\n    }\n    RetryData.prototype.getThrottleMetadata = function (appId) {\n        return this.throttleMetadata[appId];\n    };\n    RetryData.prototype.setThrottleMetadata = function (appId, metadata) {\n        this.throttleMetadata[appId] = metadata;\n    };\n    RetryData.prototype.deleteThrottleMetadata = function (appId) {\n        delete this.throttleMetadata[appId];\n    };\n    return RetryData;\n}());\nvar defaultRetryData = new RetryData();\n/**\n * Set GET request headers.\n * @param apiKey App API key.\n */\nfunction index_esm_getHeaders(apiKey) {\n    return new Headers({\n        Accept: 'application/json',\n        'x-goog-api-key': apiKey\n    });\n}\n/**\n * Fetches dynamic config from backend.\n * @param app Firebase app to fetch config for.\n */\nfunction fetchDynamicConfig(appFields) {\n    var _a;\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n        var appId, apiKey, request, appUrl, response, errorMessage, jsonResponse, _ignored_1;\n        return Object(tslib_es6[\"__generator\"])(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    appId = appFields.appId, apiKey = appFields.apiKey;\n                    request = {\n                        method: 'GET',\n                        headers: index_esm_getHeaders(apiKey)\n                    };\n                    appUrl = DYNAMIC_CONFIG_URL.replace('{app-id}', appId);\n                    return [4 /*yield*/, fetch(appUrl, request)];\n                case 1:\n                    response = _b.sent();\n                    if (!(response.status !== 200 && response.status !== 304))\n                        return [3 /*break*/, 6];\n                    errorMessage = '';\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 4, , 5]);\n                    return [4 /*yield*/, response.json()];\n                case 3:\n                    jsonResponse = (_b.sent());\n                    if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {\n                        errorMessage = jsonResponse.error.message;\n                    }\n                    return [3 /*break*/, 5];\n                case 4:\n                    _ignored_1 = _b.sent();\n                    return [3 /*break*/, 5];\n                case 5: throw index_esm_ERROR_FACTORY.create(\"config-fetch-failed\" /* CONFIG_FETCH_FAILED */, {\n                    httpStatus: response.status,\n                    responseMessage: errorMessage\n                });\n                case 6: return [2 /*return*/, response.json()];\n            }\n        });\n    });\n}\n/**\n * Fetches dynamic config from backend, retrying if failed.\n * @param app Firebase app to fetch config for.\n */\nfunction fetchDynamicConfigWithRetry(app, \n// retryData and timeoutMillis are parameterized to allow passing a different value for testing.\nretryData, timeoutMillis) {\n    if (retryData === void 0) {\n        retryData = defaultRetryData;\n    }\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n        var _a, appId, apiKey, measurementId, throttleMetadata, signal;\n        var _this = this;\n        return Object(tslib_es6[\"__generator\"])(this, function (_b) {\n            _a = app.options, appId = _a.appId, apiKey = _a.apiKey, measurementId = _a.measurementId;\n            if (!appId) {\n                throw index_esm_ERROR_FACTORY.create(\"no-app-id\" /* NO_APP_ID */);\n            }\n            if (!apiKey) {\n                if (measurementId) {\n                    return [2 /*return*/, {\n                            measurementId: measurementId,\n                            appId: appId\n                        }];\n                }\n                throw index_esm_ERROR_FACTORY.create(\"no-api-key\" /* NO_API_KEY */);\n            }\n            throttleMetadata = retryData.getThrottleMetadata(appId) || {\n                backoffCount: 0,\n                throttleEndTimeMillis: Date.now()\n            };\n            signal = new AnalyticsAbortSignal();\n            setTimeout(function () {\n                return Object(tslib_es6[\"__awaiter\"])(_this, void 0, void 0, function () {\n                    return Object(tslib_es6[\"__generator\"])(this, function (_a) {\n                        // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\n                        signal.abort();\n                        return [2 /*return*/];\n                    });\n                });\n            }, timeoutMillis !== undefined ? timeoutMillis : FETCH_TIMEOUT_MILLIS);\n            return [2 /*return*/, attemptFetchDynamicConfigWithRetry({ appId: appId, apiKey: apiKey, measurementId: measurementId }, throttleMetadata, signal, retryData)];\n        });\n    });\n}\n/**\n * Runs one retry attempt.\n * @param appFields Necessary app config fields.\n * @param throttleMetadata Ongoing metadata to determine throttling times.\n * @param signal Abort signal.\n */\nfunction attemptFetchDynamicConfigWithRetry(appFields, _a, signal, retryData // for testing\n) {\n    var throttleEndTimeMillis = _a.throttleEndTimeMillis, backoffCount = _a.backoffCount;\n    if (retryData === void 0) {\n        retryData = defaultRetryData;\n    }\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n        var appId, measurementId, e_1, response, e_2, backoffMillis, throttleMetadata;\n        return Object(tslib_es6[\"__generator\"])(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    appId = appFields.appId, measurementId = appFields.measurementId;\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, setAbortableTimeout(signal, throttleEndTimeMillis)];\n                case 2:\n                    _b.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    e_1 = _b.sent();\n                    if (measurementId) {\n                        logger.warn(\"Timed out fetching this Firebase app's measurement ID from the server.\" +\n                            (\" Falling back to the measurement ID \" + measurementId) +\n                            (\" provided in the \\\"measurementId\\\" field in the local Firebase config. [\" + e_1.message + \"]\"));\n                        return [2 /*return*/, { appId: appId, measurementId: measurementId }];\n                    }\n                    throw e_1;\n                case 4:\n                    _b.trys.push([4, 6, , 7]);\n                    return [4 /*yield*/, fetchDynamicConfig(appFields)];\n                case 5:\n                    response = _b.sent();\n                    // Note the SDK only clears throttle state if response is success or non-retriable.\n                    retryData.deleteThrottleMetadata(appId);\n                    return [2 /*return*/, response];\n                case 6:\n                    e_2 = _b.sent();\n                    if (!isRetriableError(e_2)) {\n                        retryData.deleteThrottleMetadata(appId);\n                        if (measurementId) {\n                            logger.warn(\"Failed to fetch this Firebase app's measurement ID from the server.\" +\n                                (\" Falling back to the measurement ID \" + measurementId) +\n                                (\" provided in the \\\"measurementId\\\" field in the local Firebase config. [\" + e_2.message + \"]\"));\n                            return [2 /*return*/, { appId: appId, measurementId: measurementId }];\n                        }\n                        else {\n                            throw e_2;\n                        }\n                    }\n                    backoffMillis = Number(e_2.httpStatus) === 503\n                        ? Object(util_dist_index_cjs[\"calculateBackoffMillis\"])(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR)\n                        : Object(util_dist_index_cjs[\"calculateBackoffMillis\"])(backoffCount, retryData.intervalMillis);\n                    throttleMetadata = {\n                        throttleEndTimeMillis: Date.now() + backoffMillis,\n                        backoffCount: backoffCount + 1\n                    };\n                    // Persists state.\n                    retryData.setThrottleMetadata(appId, throttleMetadata);\n                    logger.debug(\"Calling attemptFetch again in \" + backoffMillis + \" millis\");\n                    return [2 /*return*/, attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData)];\n                case 7: return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Supports waiting on a backoff by:\n *\n * <ul>\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\n *       request appear the same.</li>\n * </ul>\n *\n * <p>Visible for testing.\n */\nfunction setAbortableTimeout(signal, throttleEndTimeMillis) {\n    return new Promise(function (resolve, reject) {\n        // Derives backoff from given end time, normalizing negative numbers to zero.\n        var backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\n        var timeout = setTimeout(resolve, backoffMillis);\n        // Adds listener, rather than sets onabort, because signal is a shared object.\n        signal.addEventListener(function () {\n            clearTimeout(timeout);\n            // If the request completes before this timeout, the rejection has no effect.\n            reject(index_esm_ERROR_FACTORY.create(\"fetch-throttle\" /* FETCH_THROTTLE */, {\n                throttleEndTimeMillis: throttleEndTimeMillis\n            }));\n        });\n    });\n}\n/**\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\n */\nfunction isRetriableError(e) {\n    if (!(e instanceof util_dist_index_cjs[\"FirebaseError\"])) {\n        return false;\n    }\n    // Uses string index defined by ErrorData, which FirebaseError implements.\n    var httpStatus = Number(e['httpStatus']);\n    return (httpStatus === 429 ||\n        httpStatus === 500 ||\n        httpStatus === 503 ||\n        httpStatus === 504);\n}\n/**\n * Shims a minimal AbortSignal (copied from Remote Config).\n *\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\n * swapped out if/when we do.\n */\nvar AnalyticsAbortSignal = /** @class */ /*@__PURE__*/ (function () {\n    function AnalyticsAbortSignal() {\n        this.listeners = [];\n    }\n    AnalyticsAbortSignal.prototype.addEventListener = function (listener) {\n        this.listeners.push(listener);\n    };\n    AnalyticsAbortSignal.prototype.abort = function () {\n        this.listeners.forEach(function (listener) { return listener(); });\n    };\n    return AnalyticsAbortSignal;\n}());\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction validateIndexedDB() {\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n        var e_1;\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!!Object(util_dist_index_cjs[\"isIndexedDBAvailable\"])())\n                        return [3 /*break*/, 1];\n                    logger.warn(index_esm_ERROR_FACTORY.create(\"indexeddb-unavailable\" /* INDEXEDDB_UNAVAILABLE */, {\n                        errorInfo: 'IndexedDB is not available in this environment.'\n                    }).message);\n                    return [2 /*return*/, false];\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, Object(util_dist_index_cjs[\"validateIndexedDBOpenable\"])()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    e_1 = _a.sent();\n                    logger.warn(index_esm_ERROR_FACTORY.create(\"indexeddb-unavailable\" /* INDEXEDDB_UNAVAILABLE */, {\n                        errorInfo: e_1\n                    }).message);\n                    return [2 /*return*/, false];\n                case 4: return [2 /*return*/, true];\n            }\n        });\n    });\n}\n/**\n * Initialize the analytics instance in gtag.js by calling config command with fid.\n *\n * NOTE: We combine analytics initialization and setting fid together because we want fid to be\n * part of the `page_view` event that's sent during the initialization\n * @param app Firebase app\n * @param gtagCore The gtag function that's not wrapped.\n * @param dynamicConfigPromisesList Array of all dynamic config promises.\n * @param measurementIdToAppId Maps measurementID to appID.\n * @param installations FirebaseInstallations instance.\n *\n * @returns Measurement ID.\n */\nfunction initializeIds(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCore) {\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n        var dynamicConfigPromise, fidPromise, _a, dynamicConfig, fid, configProperties;\n        var _b;\n        return Object(tslib_es6[\"__generator\"])(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    dynamicConfigPromise = fetchDynamicConfigWithRetry(app);\n                    // Once fetched, map measurementIds to appId, for ease of lookup in wrapped gtag function.\n                    dynamicConfigPromise\n                        .then(function (config) {\n                        measurementIdToAppId[config.measurementId] = config.appId;\n                        if (app.options.measurementId &&\n                            config.measurementId !== app.options.measurementId) {\n                            logger.warn(\"The measurement ID in the local Firebase config (\" + app.options.measurementId + \")\" +\n                                (\" does not match the measurement ID fetched from the server (\" + config.measurementId + \").\") +\n                                \" To ensure analytics events are always sent to the correct Analytics property,\" +\n                                \" update the\" +\n                                \" measurement ID field in the local config or remove it from the local config.\");\n                        }\n                    })\n                        .catch(function (e) { return logger.error(e); });\n                    // Add to list to track state of all dynamic config promises.\n                    dynamicConfigPromisesList.push(dynamicConfigPromise);\n                    fidPromise = validateIndexedDB().then(function (envIsValid) {\n                        if (envIsValid) {\n                            return installations.getId();\n                        }\n                        else {\n                            return undefined;\n                        }\n                    });\n                    return [4 /*yield*/, Promise.all([\n                            dynamicConfigPromise,\n                            fidPromise\n                        ])];\n                case 1:\n                    _a = _c.sent(), dynamicConfig = _a[0], fid = _a[1];\n                    // This command initializes gtag.js and only needs to be called once for the entire web app,\n                    // but since it is idempotent, we can call it multiple times.\n                    // We keep it together with other initialization logic for better code structure.\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    gtagCore('js', new Date());\n                    configProperties = (_b = {},\n                        // guard against developers accidentally setting properties with prefix `firebase_`\n                        _b[ORIGIN_KEY] = 'firebase',\n                        _b.update = true,\n                        _b);\n                    if (fid != null) {\n                        configProperties[GA_FID_KEY] = fid;\n                    }\n                    // It should be the first config command called on this GA-ID\n                    // Initialize this GA-ID and set FID on it using the gtag config API.\n                    gtagCore(GtagCommand.CONFIG, dynamicConfig.measurementId, configProperties);\n                    return [2 /*return*/, dynamicConfig.measurementId];\n            }\n        });\n    });\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Maps appId to full initialization promise. Wrapped gtag calls must wait on\n * all or some of these, depending on the call's `send_to` param and the status\n * of the dynamic config fetches (see below).\n */\nvar index_esm_initializationPromisesMap = {};\n/**\n * List of dynamic config fetch promises. In certain cases, wrapped gtag calls\n * wait on all these to be complete in order to determine if it can selectively\n * wait for only certain initialization (FID) promises or if it must wait for all.\n */\nvar index_esm_dynamicConfigPromisesList = [];\n/**\n * Maps fetched measurementIds to appId. Populated when the app's dynamic config\n * fetch completes. If already populated, gtag config calls can use this to\n * selectively wait for only this app's initialization promise (FID) instead of all\n * initialization promises.\n */\nvar index_esm_measurementIdToAppId = {};\n/**\n * Name for window global data layer array used by GA: defaults to 'dataLayer'.\n */\nvar dataLayerName = 'dataLayer';\n/**\n * Name for window global gtag function used by GA: defaults to 'gtag'.\n */\nvar gtagName = 'gtag';\n/**\n * Reproduction of standard gtag function or reference to existing\n * gtag function on window object.\n */\nvar gtagCoreFunction;\n/**\n * Wrapper around gtag function that ensures FID is sent with all\n * relevant event and config calls.\n */\nvar wrappedGtagFunction;\n/**\n * Flag to ensure page initialization steps (creation or wrapping of\n * dataLayer and gtag script) are only run once per page load.\n */\nvar globalInitDone = false;\n/**\n * For testing\n */\nfunction resetGlobalVars(newGlobalInitDone, newInitializationPromisesMap, newDynamicPromises) {\n    if (newGlobalInitDone === void 0) {\n        newGlobalInitDone = false;\n    }\n    if (newInitializationPromisesMap === void 0) {\n        newInitializationPromisesMap = {};\n    }\n    if (newDynamicPromises === void 0) {\n        newDynamicPromises = [];\n    }\n    globalInitDone = newGlobalInitDone;\n    index_esm_initializationPromisesMap = newInitializationPromisesMap;\n    index_esm_dynamicConfigPromisesList = newDynamicPromises;\n    dataLayerName = 'dataLayer';\n    gtagName = 'gtag';\n}\n/**\n * For testing\n */\nfunction getGlobalVars() {\n    return {\n        initializationPromisesMap: index_esm_initializationPromisesMap,\n        dynamicConfigPromisesList: index_esm_dynamicConfigPromisesList\n    };\n}\n/**\n * This must be run before calling firebase.analytics() or it won't\n * have any effect.\n * @param options Custom gtag and dataLayer names.\n */\nfunction settings(options) {\n    if (globalInitDone) {\n        throw index_esm_ERROR_FACTORY.create(\"already-initialized\" /* ALREADY_INITIALIZED */);\n    }\n    if (options.dataLayerName) {\n        dataLayerName = options.dataLayerName;\n    }\n    if (options.gtagName) {\n        gtagName = options.gtagName;\n    }\n}\n/**\n * Returns true if no environment mismatch is found.\n * If environment mismatches are found, throws an INVALID_ANALYTICS_CONTEXT\n * error that also lists details for each mismatch found.\n */\nfunction warnOnBrowserContextMismatch() {\n    var mismatchedEnvMessages = [];\n    if (Object(util_dist_index_cjs[\"isBrowserExtension\"])()) {\n        mismatchedEnvMessages.push('This is a browser extension environment.');\n    }\n    if (!Object(util_dist_index_cjs[\"areCookiesEnabled\"])()) {\n        mismatchedEnvMessages.push('Cookies are not available.');\n    }\n    if (mismatchedEnvMessages.length > 0) {\n        var details = mismatchedEnvMessages\n            .map(function (message, index) { return \"(\" + (index + 1) + \") \" + message; })\n            .join(' ');\n        var err = index_esm_ERROR_FACTORY.create(\"invalid-analytics-context\" /* INVALID_ANALYTICS_CONTEXT */, {\n            errorInfo: details\n        });\n        logger.warn(err.message);\n    }\n}\nfunction factory(app, installations) {\n    warnOnBrowserContextMismatch();\n    var appId = app.options.appId;\n    if (!appId) {\n        throw index_esm_ERROR_FACTORY.create(\"no-app-id\" /* NO_APP_ID */);\n    }\n    if (!app.options.apiKey) {\n        if (app.options.measurementId) {\n            logger.warn(\"The \\\"apiKey\\\" field is empty in the local Firebase config. This is needed to fetch the latest\" +\n                (\" measurement ID for this Firebase app. Falling back to the measurement ID \" + app.options.measurementId) +\n                \" provided in the \\\"measurementId\\\" field in the local Firebase config.\");\n        }\n        else {\n            throw index_esm_ERROR_FACTORY.create(\"no-api-key\" /* NO_API_KEY */);\n        }\n    }\n    if (index_esm_initializationPromisesMap[appId] != null) {\n        throw index_esm_ERROR_FACTORY.create(\"already-exists\" /* ALREADY_EXISTS */, {\n            id: appId\n        });\n    }\n    if (!globalInitDone) {\n        // Steps here should only be done once per page: creation or wrapping\n        // of dataLayer and global gtag function.\n        // Detect if user has already put the gtag <script> tag on this page.\n        if (!findGtagScriptOnPage()) {\n            insertScriptTag(dataLayerName);\n        }\n        getOrCreateDataLayer(dataLayerName);\n        var _a = wrapOrCreateGtag(index_esm_initializationPromisesMap, index_esm_dynamicConfigPromisesList, index_esm_measurementIdToAppId, dataLayerName, gtagName), wrappedGtag = _a.wrappedGtag, gtagCore = _a.gtagCore;\n        wrappedGtagFunction = wrappedGtag;\n        gtagCoreFunction = gtagCore;\n        globalInitDone = true;\n    }\n    // Async but non-blocking.\n    // This map reflects the completion state of all promises for each appId.\n    index_esm_initializationPromisesMap[appId] = initializeIds(app, index_esm_dynamicConfigPromisesList, index_esm_measurementIdToAppId, installations, gtagCoreFunction);\n    var analyticsInstance = {\n        app: app,\n        // Public methods return void for API simplicity and to better match gtag,\n        // while internal implementations return promises.\n        logEvent: function (eventName, eventParams, options) {\n            logEvent(wrappedGtagFunction, index_esm_initializationPromisesMap[appId], eventName, eventParams, options).catch(function (e) { return logger.error(e); });\n        },\n        setCurrentScreen: function (screenName, options) {\n            setCurrentScreen(wrappedGtagFunction, index_esm_initializationPromisesMap[appId], screenName, options).catch(function (e) { return logger.error(e); });\n        },\n        setUserId: function (id, options) {\n            setUserId(wrappedGtagFunction, index_esm_initializationPromisesMap[appId], id, options).catch(function (e) { return logger.error(e); });\n        },\n        setUserProperties: function (properties, options) {\n            setUserProperties(wrappedGtagFunction, index_esm_initializationPromisesMap[appId], properties, options).catch(function (e) { return logger.error(e); });\n        },\n        setAnalyticsCollectionEnabled: function (enabled) {\n            setAnalyticsCollectionEnabled(index_esm_initializationPromisesMap[appId], enabled).catch(function (e) { return logger.error(e); });\n        },\n        INTERNAL: {\n            delete: function () {\n                delete index_esm_initializationPromisesMap[appId];\n                return Promise.resolve();\n            }\n        }\n    };\n    return analyticsInstance;\n}\nvar dist_index_esm_name = \"@firebase/analytics\";\nvar index_esm_version = \"0.6.0\";\n/**\n * Type constant for Firebase Analytics.\n */\nvar ANALYTICS_TYPE = 'analytics';\nfunction registerAnalytics(instance) {\n    instance.INTERNAL.registerComponent(new dist_index_cjs[\"Component\"](ANALYTICS_TYPE, function (container) {\n        // getImmediate for FirebaseApp will always succeed\n        var app = container.getProvider('app').getImmediate();\n        var installations = container\n            .getProvider('installations')\n            .getImmediate();\n        return factory(app, installations);\n    }, \"PUBLIC\" /* PUBLIC */).setServiceProps({\n        settings: settings,\n        EventName: EventName,\n        isSupported: isSupported\n    }));\n    instance.INTERNAL.registerComponent(new dist_index_cjs[\"Component\"]('analytics-internal', internalFactory, \"PRIVATE\" /* PRIVATE */));\n    instance.registerVersion(dist_index_esm_name, index_esm_version);\n    function internalFactory(container) {\n        try {\n            var analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();\n            return {\n                logEvent: analytics.logEvent\n            };\n        }\n        catch (e) {\n            throw index_esm_ERROR_FACTORY.create(\"interop-component-reg-failed\" /* INTEROP_COMPONENT_REG_FAILED */, {\n                reason: e\n            });\n        }\n    }\n}\nregisterAnalytics(index_cjs_default.a);\n/**\n * this is a public static method provided to users that wraps four different checks:\n *\n * 1. check if it's not a browser extension environment.\n * 1. check if cookie is enabled in current browser.\n * 3. check if IndexedDB is supported by the browser environment.\n * 4. check if the current browser context is valid for using IndexedDB.\n *\n */\nfunction isSupported() {\n    return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function () {\n        var isDBOpenable, error_1;\n        return Object(tslib_es6[\"__generator\"])(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (Object(util_dist_index_cjs[\"isBrowserExtension\"])()) {\n                        return [2 /*return*/, false];\n                    }\n                    if (!Object(util_dist_index_cjs[\"areCookiesEnabled\"])()) {\n                        return [2 /*return*/, false];\n                    }\n                    if (!Object(util_dist_index_cjs[\"isIndexedDBAvailable\"])()) {\n                        return [2 /*return*/, false];\n                    }\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, Object(util_dist_index_cjs[\"validateIndexedDBOpenable\"])()];\n                case 2:\n                    isDBOpenable = _a.sent();\n                    return [2 /*return*/, isDBOpenable];\n                case 3:\n                    error_1 = _a.sent();\n                    return [2 /*return*/, false];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\n\n//# sourceMappingURL=index.esm.js.map\n\n// CONCATENATED MODULE: ./node_modules/firebase/analytics/dist/index.esm.js\n\n//# sourceMappingURL=index.esm.js.map\n\n\n/***/ }),\n\n/***/ \"nbvr\":\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, function (exports) { 'use strict';\n\n  function toArray(arr) {\n    return Array.prototype.slice.call(arr);\n  }\n\n  function promisifyRequest(request) {\n    return new Promise(function(resolve, reject) {\n      request.onsuccess = function() {\n        resolve(request.result);\n      };\n\n      request.onerror = function() {\n        reject(request.error);\n      };\n    });\n  }\n\n  function promisifyRequestCall(obj, method, args) {\n    var request;\n    var p = new Promise(function(resolve, reject) {\n      request = obj[method].apply(obj, args);\n      promisifyRequest(request).then(resolve, reject);\n    });\n\n    p.request = request;\n    return p;\n  }\n\n  function promisifyCursorRequestCall(obj, method, args) {\n    var p = promisifyRequestCall(obj, method, args);\n    return p.then(function(value) {\n      if (!value) return;\n      return new Cursor(value, p.request);\n    });\n  }\n\n  function proxyProperties(ProxyClass, targetProp, properties) {\n    properties.forEach(function(prop) {\n      Object.defineProperty(ProxyClass.prototype, prop, {\n        get: function() {\n          return this[targetProp][prop];\n        },\n        set: function(val) {\n          this[targetProp][prop] = val;\n        }\n      });\n    });\n  }\n\n  function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return this[targetProp][prop].apply(this[targetProp], arguments);\n      };\n    });\n  }\n\n  function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyCursorRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function Index(index) {\n    this._index = index;\n  }\n\n  proxyProperties(Index, '_index', [\n    'name',\n    'keyPath',\n    'multiEntry',\n    'unique'\n  ]);\n\n  proxyRequestMethods(Index, '_index', IDBIndex, [\n    'get',\n    'getKey',\n    'getAll',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(Index, '_index', IDBIndex, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  function Cursor(cursor, request) {\n    this._cursor = cursor;\n    this._request = request;\n  }\n\n  proxyProperties(Cursor, '_cursor', [\n    'direction',\n    'key',\n    'primaryKey',\n    'value'\n  ]);\n\n  proxyRequestMethods(Cursor, '_cursor', IDBCursor, [\n    'update',\n    'delete'\n  ]);\n\n  // proxy 'next' methods\n  ['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {\n    if (!(methodName in IDBCursor.prototype)) return;\n    Cursor.prototype[methodName] = function() {\n      var cursor = this;\n      var args = arguments;\n      return Promise.resolve().then(function() {\n        cursor._cursor[methodName].apply(cursor._cursor, args);\n        return promisifyRequest(cursor._request).then(function(value) {\n          if (!value) return;\n          return new Cursor(value, cursor._request);\n        });\n      });\n    };\n  });\n\n  function ObjectStore(store) {\n    this._store = store;\n  }\n\n  ObjectStore.prototype.createIndex = function() {\n    return new Index(this._store.createIndex.apply(this._store, arguments));\n  };\n\n  ObjectStore.prototype.index = function() {\n    return new Index(this._store.index.apply(this._store, arguments));\n  };\n\n  proxyProperties(ObjectStore, '_store', [\n    'name',\n    'keyPath',\n    'indexNames',\n    'autoIncrement'\n  ]);\n\n  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'put',\n    'add',\n    'delete',\n    'clear',\n    'get',\n    'getAll',\n    'getKey',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  proxyMethods(ObjectStore, '_store', IDBObjectStore, [\n    'deleteIndex'\n  ]);\n\n  function Transaction(idbTransaction) {\n    this._tx = idbTransaction;\n    this.complete = new Promise(function(resolve, reject) {\n      idbTransaction.oncomplete = function() {\n        resolve();\n      };\n      idbTransaction.onerror = function() {\n        reject(idbTransaction.error);\n      };\n      idbTransaction.onabort = function() {\n        reject(idbTransaction.error);\n      };\n    });\n  }\n\n  Transaction.prototype.objectStore = function() {\n    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));\n  };\n\n  proxyProperties(Transaction, '_tx', [\n    'objectStoreNames',\n    'mode'\n  ]);\n\n  proxyMethods(Transaction, '_tx', IDBTransaction, [\n    'abort'\n  ]);\n\n  function UpgradeDB(db, oldVersion, transaction) {\n    this._db = db;\n    this.oldVersion = oldVersion;\n    this.transaction = new Transaction(transaction);\n  }\n\n  UpgradeDB.prototype.createObjectStore = function() {\n    return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));\n  };\n\n  proxyProperties(UpgradeDB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(UpgradeDB, '_db', IDBDatabase, [\n    'deleteObjectStore',\n    'close'\n  ]);\n\n  function DB(db) {\n    this._db = db;\n  }\n\n  DB.prototype.transaction = function() {\n    return new Transaction(this._db.transaction.apply(this._db, arguments));\n  };\n\n  proxyProperties(DB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(DB, '_db', IDBDatabase, [\n    'close'\n  ]);\n\n  // Add cursor iterators\n  // TODO: remove this once browsers do the right thing with promises\n  ['openCursor', 'openKeyCursor'].forEach(function(funcName) {\n    [ObjectStore, Index].forEach(function(Constructor) {\n      // Don't create iterateKeyCursor if openKeyCursor doesn't exist.\n      if (!(funcName in Constructor.prototype)) return;\n\n      Constructor.prototype[funcName.replace('open', 'iterate')] = function() {\n        var args = toArray(arguments);\n        var callback = args[args.length - 1];\n        var nativeObject = this._store || this._index;\n        var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));\n        request.onsuccess = function() {\n          callback(request.result);\n        };\n      };\n    });\n  });\n\n  // polyfill getAll\n  [Index, ObjectStore].forEach(function(Constructor) {\n    if (Constructor.prototype.getAll) return;\n    Constructor.prototype.getAll = function(query, count) {\n      var instance = this;\n      var items = [];\n\n      return new Promise(function(resolve) {\n        instance.iterateCursor(query, function(cursor) {\n          if (!cursor) {\n            resolve(items);\n            return;\n          }\n          items.push(cursor.value);\n\n          if (count !== undefined && items.length == count) {\n            resolve(items);\n            return;\n          }\n          cursor.continue();\n        });\n      });\n    };\n  });\n\n  function openDb(name, version, upgradeCallback) {\n    var p = promisifyRequestCall(indexedDB, 'open', [name, version]);\n    var request = p.request;\n\n    if (request) {\n      request.onupgradeneeded = function(event) {\n        if (upgradeCallback) {\n          upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));\n        }\n      };\n    }\n\n    return p.then(function(db) {\n      return new DB(db);\n    });\n  }\n\n  function deleteDb(name) {\n    return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);\n  }\n\n  exports.openDb = openDb;\n  exports.deleteDb = deleteDb;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n/***/ })\n\n}]);","inputSourceMap":null}