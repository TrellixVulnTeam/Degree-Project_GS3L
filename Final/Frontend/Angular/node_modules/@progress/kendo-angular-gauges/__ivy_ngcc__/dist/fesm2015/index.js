/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param } from 'tslib';
import { Injectable, NgModule, Input, ViewChild, ElementRef, HostBinding, Directive, Optional, TemplateRef, ContentChild, Component, ChangeDetectionStrategy, ChangeDetectorRef, Renderer2, NgZone, ContentChildren, QueryList } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ResizeSensorModule, ResizeSensorComponent } from '@progress/kendo-angular-common';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-intl';
import * as ɵngcc2 from '@progress/kendo-angular-l10n';
import * as ɵngcc3 from '@angular/common';
import * as ɵngcc4 from '@progress/kendo-angular-common';

const _c0 = ["surface"];
const _c1 = ["label"];
function ArcGaugeComponent_div_2_ng_template_2_Template(rf, ctx) { }
function ArcGaugeComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4, 5);
    ɵngcc0.ɵɵtemplate(2, ArcGaugeComponent_div_2_ng_template_2_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.centerTemplate.templateRef)("ngTemplateOutletContext", ctx_r1.centerTemplateContext);
} }
export { ResizeSensorComponent } from '@progress/kendo-angular-common';
import { IntlService } from '@progress/kendo-angular-intl';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { exportImage, exportSVG, drawDOM } from '@progress/kendo-drawing';
import { validatePackage } from '@progress/kendo-licensing';
import { ArcGauge, LinearGauge, RadialGauge } from '@progress/kendo-charts';

function isObject(value) {
    return typeof value === "object";
}
function diffOptions(original, current) {
    if (Object.keys(original).length !== Object.keys(current).length) {
        return true;
    }
    for (let field in original) {
        if (field !== 'value' && original.hasOwnProperty(field)) {
            const originalValue = original[field];
            const currentValue = current[field];
            const diff = isObject(originalValue) && isObject(currentValue) ?
                diffOptions(originalValue, currentValue) : originalValue !== currentValue;
            if (diff) {
                return true;
            }
        }
    }
}
function diffPointerOptions(original, current) {
    if (!original || !current) {
        return true;
    }
    original = [].concat(original);
    current = [].concat(current);
    if (original.length !== current.length) {
        return true;
    }
    for (let idx = 0; idx < original.length; idx++) {
        if (diffOptions(original[idx], current[idx])) {
            return true;
        }
    }
}
/**
 * @hidden
 */
let ConfigurationService = class ConfigurationService {
    /**
     * @hidden
     */
    constructor() {
        this.options = {};
    }
    copyChanges(prefix, changes) {
        for (let propertyName in changes) {
            if (!changes.hasOwnProperty(propertyName)) {
                continue;
            }
            const value = changes[propertyName].currentValue;
            const optionName = (prefix ? prefix + '.' : '') + propertyName;
            this.set(optionName, value);
        }
    }
    read() {
        this.hasChanges = false;
        this.valueChange = false;
        return this.options;
    }
    readValues() {
        this.valueChange = false;
        const pointers = [].concat(this.options.pointer);
        return pointers.map((pointer) => pointer.value);
    }
    readValue() {
        this.valueChange = false;
        return this.options.value;
    }
    set(field, value) {
        const { key, options } = this.optionContext(field);
        if (!this.hasChanges && (key === 'value' || (key === 'pointer' && !diffPointerOptions(this.options.pointer, value)))) {
            this.valueChange = true;
        }
        else {
            this.hasChanges = true;
            this.valueChange = false;
        }
        options[key] = value;
    }
    optionContext(field) {
        const parts = field.split('.');
        let options = this.options;
        let key = parts.shift();
        while (parts.length > 0) {
            options = options[key] = options[key] || {};
            key = parts.shift();
        }
        return { key: key, options: options };
    }
};
ConfigurationService.ɵfac = function ConfigurationService_Factory(t) { return new (t || ConfigurationService)(); };
ConfigurationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ConfigurationService, factory: function (t) { return ConfigurationService.ɵfac(t); } });

/**
 * @hidden
 */
let CollectionChangesService = class CollectionChangesService {
};
CollectionChangesService.ɵfac = function CollectionChangesService_Factory(t) { return new (t || CollectionChangesService)(); };
CollectionChangesService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CollectionChangesService, factory: function (t) { return CollectionChangesService.ɵfac(t); } });

const template = `
    <div class="k-var--gauge-pointer"></div>
    <div class="k-var--gauge-track"></div>
    <div class="k-var--normal-text-color"></div>
`;
/**
 * @hidden
 */
let ThemeService = class ThemeService {
    read() {
        if (!this.options) {
            this.load();
        }
        return this.options;
    }
    load() {
        if (typeof document === 'undefined') {
            this.options = {};
            return;
        }
        const container = document.createElement('div');
        container.style.display = 'none';
        container.innerHTML = template;
        document.body.appendChild(container);
        try {
            const pointerColor = this.getColor(container, 'gauge-pointer');
            const rangePlaceholder = this.getColor(container, 'gauge-track');
            const textColor = this.getColor(container, 'normal-text-color');
            this.options = {
                pointer: {
                    color: pointerColor
                },
                scale: {
                    labels: {
                        color: textColor
                    },
                    rangePlaceholderColor: rangePlaceholder,
                    minorTicks: {
                        color: textColor
                    },
                    majorTicks: {
                        color: textColor
                    },
                    line: {
                        color: textColor
                    }
                }
            };
        }
        finally {
            document.body.removeChild(container);
        }
    }
    getColor(container, varName) {
        return window.getComputedStyle(container.querySelector(`.k-var--${varName}`)).backgroundColor;
    }
};
ThemeService.ɵfac = function ThemeService_Factory(t) { return new (t || ThemeService)(); };
ThemeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ThemeService, factory: function (t) { return ThemeService.ɵfac(t); } });

/**
 * @hidden
 */
let SharedModule = class SharedModule {
};
SharedModule.ɵfac = function SharedModule_Factory(t) { return new (t || SharedModule)(); };
SharedModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SharedModule });
SharedModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [
        ThemeService
    ], imports: [ResizeSensorModule] });

/**
 * @hidden
 */
class CollectionComponent {
    constructor(key, configurationService, collectionChangesService) {
        this.key = key;
        this.configurationService = configurationService;
        this.collectionChangesService = collectionChangesService;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
        this.configurationService.set(this.key, []);
    }
    ngAfterContentInit() {
        this.subscription = this.children.changes.subscribe(() => this.collectionChangesService.hasChanges = true);
    }
    ngAfterContentChecked() {
        if (this.collectionChangesService.hasChanges) {
            this.configurationService.set(this.key, this.readItems());
            this.collectionChangesService.hasChanges = false;
        }
    }
    readItems() {
        return this.children.map(child => Object.assign({}, child.configurationService.read()));
    }
}
CollectionComponent.ɵfac = function CollectionComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CollectionComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CollectionComponent });

/**
 * @hidden
 */
class CollectionItemComponent {
    constructor(configurationService, collectionChangesService) {
        this.configurationService = configurationService;
        this.collectionChangesService = collectionChangesService;
    }
    ngOnChanges(changes) {
        this.configurationService.copyChanges('', changes);
        this.collectionChangesService.hasChanges = true;
    }
}
CollectionItemComponent.ɵfac = function CollectionItemComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CollectionItemComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CollectionItemComponent, features: [ɵngcc0.ɵɵNgOnChangesFeature] });

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-gauges',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1608133935,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

const inDocument = (element) => {
    let node = element;
    while (node && node !== document.body) {
        node = node.parentNode;
    }
    return Boolean(node);
};
/**
 * @hidden
 */
class GaugeComponent {
    constructor(configurationService, themeService, intlService, localizationService, element, renderer, ngZone) {
        this.configurationService = configurationService;
        this.themeService = themeService;
        this.intlService = intlService;
        this.localizationService = localizationService;
        this.element = element;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /**
         * The maximum number of times the Gauge resizes per second.
         * Defaults to `10`. To disable the automatic resizing, set `resizeRateLimit` to `0`.
         */
        this.resizeRateLimit = 10;
        this.className = true;
        this.theme = null;
        this.rtl = false;
        validatePackage(packageMetadata);
    }
    ngOnInit() {
        this.setDirection();
        this.subscriptions = this.intlService.changes.subscribe(this.intlChange.bind(this));
        this.subscriptions.add(this.localizationService.changes.subscribe(this.rtlChange.bind(this)));
    }
    ngAfterViewChecked() {
        if (typeof document === 'undefined') {
            return;
        }
        let updateMethod;
        if (!this.instance) {
            updateMethod = this.init;
        }
        else if (this.configurationService.hasChanges) {
            updateMethod = this.updateOptions;
        }
        else if (this.configurationService.valueChange) {
            updateMethod = this.setValues;
        }
        if (updateMethod) {
            clearTimeout(this.redrawTimeout);
            if (!this.instance && !inDocument(this.element.nativeElement)) { // required in case the gauge is initialized by ng-content outside of the DOM
                this.defer(() => {
                    this.updateCall(updateMethod);
                });
            }
            else {
                this.updateCall(updateMethod);
            }
        }
    }
    updateCall(updateMethod) {
        this.updateDirection();
        updateMethod.call(this);
        this.updateSize();
    }
    updateOptions() {
        this.instance.setOptions(this.configurationService.read());
    }
    setValues() {
        this.instance.allValues(this.configurationService.readValues());
    }
    ngOnChanges(changes) {
        this.configurationService.copyChanges('', changes);
    }
    ngOnDestroy() {
        if (this.instance) {
            this.instance.destroy();
        }
        this.subscriptions.unsubscribe();
        clearTimeout(this.redrawTimeout);
    }
    /**
     * Exports the Gauge as an image. The export operation is asynchronous and returns a promise.
     *
     * @param {ImageExportOptions} options - The parameters for the exported image.
     * @returns {Promise<string>} - A promise that will be resolved with a PNG image that is encoded as a Data URI.
     */
    exportImage(options = {}) {
        return this.exportVisual().then((visual) => {
            return exportImage(visual, options);
        });
    }
    /**
     * Exports the Gauge as an SVG document. The export operation is asynchronous and returns a promise.
     *
     * @param {SVGExportOptions} options - The parameters for the exported file.
     * @returns {Promise<string>} - A promise that will be resolved with an SVG document that is encoded as a Data URI.
     */
    exportSVG(options = {}) {
        return this.exportVisual().then((visual) => {
            return exportSVG(visual, options);
        });
    }
    /**
     * Exports the Gauge as a Drawing `Scene`.
     *
     * @returns {Promise<Group>} - A promise that will be resolved with the export visual.
     */
    exportVisual() {
        return Promise.resolve(this.instance.exportVisual());
    }
    /**
     * @hidden
     */
    onResize(_event) {
        if (this.autoResize) {
            this.resize();
        }
    }
    /**
     * Detects the size of the container and redraws the Gauge.
     * Resizing is automatic unless you set the `resizeRateLimit` option to `0`.
     */
    resize() {
        if (this.instance) {
            this.instance.resize();
        }
    }
    init() {
        if (!this.surfaceElement) {
            return;
        }
        this.createInstance(this.surfaceElement.nativeElement, this.configurationService.read(), this.themeService.read(), {
            intlService: this.intlService,
            rtl: this.rtl
        });
    }
    get autoResize() {
        return this.resizeRateLimit > 0;
    }
    updateSize() {
        this.resizeSensor.acceptSize();
    }
    intlChange() {
        if (this.instance) {
            this.deferredRedraw();
        }
    }
    rtlChange() {
        if (this.instance && this.rtl !== this.isRTL) {
            this.deferredRedraw();
        }
    }
    deferredRedraw() {
        this.defer(() => {
            this.updateDirection();
            this.instance.noTransitionsRedraw();
        });
    }
    defer(callback) {
        this.ngZone.runOutsideAngular(() => {
            clearTimeout(this.redrawTimeout);
            this.redrawTimeout = setTimeout(callback, 0);
        });
    }
    updateDirection() {
        const current = this.isRTL;
        if (this.rtl !== current) {
            this.setDirection();
            if (this.instance) {
                this.instance.setDirection(current);
            }
        }
    }
    setDirection() {
        this.rtl = this.isRTL;
        if (this.element) {
            this.renderer.setAttribute(this.element.nativeElement, 'dir', this.rtl ? 'rtl' : 'ltr');
        }
    }
    get isRTL() {
        return Boolean(this.localizationService.rtl);
    }
}
GaugeComponent.ɵfac = function GaugeComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
GaugeComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GaugeComponent, viewQuery: function GaugeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 3);
        ɵngcc0.ɵɵviewQuery(ResizeSensorComponent, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.surfaceElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resizeSensor = _t.first);
    } }, hostVars: 2, hostBindings: function GaugeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-gauge", ctx.className);
    } }, inputs: { resizeRateLimit: "resizeRateLimit", gaugeArea: "gaugeArea", renderAs: "renderAs", scale: "scale", transitions: "transitions" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], GaugeComponent.prototype, "gaugeArea", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], GaugeComponent.prototype, "renderAs", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GaugeComponent.prototype, "resizeRateLimit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GaugeComponent.prototype, "scale", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], GaugeComponent.prototype, "transitions", void 0);
__decorate([
    ViewChild('surface', { static: true }),
    __metadata("design:type", ElementRef)
], GaugeComponent.prototype, "surfaceElement", void 0);
__decorate([
    ViewChild(ResizeSensorComponent, { static: true }),
    __metadata("design:type", ResizeSensorComponent)
], GaugeComponent.prototype, "resizeSensor", void 0);
__decorate([
    HostBinding('class.k-gauge'),
    __metadata("design:type", Boolean)
], GaugeComponent.prototype, "className", void 0);

/**
 * @hidden
 */
class SettingsComponent {
    constructor(key, configurationService) {
        this.key = key;
        this.configurationService = configurationService;
    }
    ngOnChanges(changes) {
        this.configurationService.copyChanges(this.key, changes);
    }
    ngOnDestroy() {
        this.configurationService.set(this.key, null);
    }
}
SettingsComponent.ɵfac = function SettingsComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SettingsComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SettingsComponent, features: [ɵngcc0.ɵɵNgOnChangesFeature] });

/**
 * @hidden
 */
class GaugeAreaComponent extends SettingsComponent {
}
GaugeAreaComponent.ɵfac = function GaugeAreaComponent_Factory(t) { return ɵGaugeAreaComponent_BaseFactory(t || GaugeAreaComponent); };
GaugeAreaComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GaugeAreaComponent, inputs: { background: "background", border: "border", height: "height", margin: "margin", width: "width" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], GaugeAreaComponent.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GaugeAreaComponent.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GaugeAreaComponent.prototype, "height", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GaugeAreaComponent.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GaugeAreaComponent.prototype, "width", void 0);

/**
 * @hidden
 */
class LabelsComponent extends SettingsComponent {
}
LabelsComponent.ɵfac = function LabelsComponent_Factory(t) { return ɵLabelsComponent_BaseFactory(t || LabelsComponent); };
LabelsComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LabelsComponent, inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", margin: "margin", padding: "padding", content: "content", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], LabelsComponent.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LabelsComponent.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], LabelsComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], LabelsComponent.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], LabelsComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LabelsComponent.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LabelsComponent.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], LabelsComponent.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], LabelsComponent.prototype, "visible", void 0);

/**
 * @hidden
 */
class RangeComponent extends CollectionItemComponent {
}
RangeComponent.ɵfac = function RangeComponent_Factory(t) { return ɵRangeComponent_BaseFactory(t || RangeComponent); };
RangeComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RangeComponent, inputs: { from: "from", to: "to", opacity: "opacity", color: "color" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Number)
], RangeComponent.prototype, "from", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], RangeComponent.prototype, "to", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], RangeComponent.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RangeComponent.prototype, "color", void 0);

/**
 * @hidden
 */
class ScaleComponent extends SettingsComponent {
}
ScaleComponent.ɵfac = function ScaleComponent_Factory(t) { return ɵScaleComponent_BaseFactory(t || ScaleComponent); };
ScaleComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ScaleComponent, inputs: { labels: "labels", majorTicks: "majorTicks", minorTicks: "minorTicks", min: "min", max: "max", minorUnit: "minorUnit", majorUnit: "majorUnit", reverse: "reverse", rangeSize: "rangeSize", rangePlaceholderColor: "rangePlaceholderColor" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], ScaleComponent.prototype, "labels", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ScaleComponent.prototype, "majorTicks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ScaleComponent.prototype, "minorTicks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ScaleComponent.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ScaleComponent.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ScaleComponent.prototype, "minorUnit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ScaleComponent.prototype, "majorUnit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ScaleComponent.prototype, "reverse", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ScaleComponent.prototype, "rangeSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ScaleComponent.prototype, "rangePlaceholderColor", void 0);

/**
 * A directive that selects a [template]({{ site.data.urls.angular['templatesyntax'] }})
 * within the `<kendo-arcgauge>` component which will be used for the center template
 * ([more information and example]({% slug centertemplate_arcgauge %})).
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-arcgauge [value]="value">
 *             <ng-template kendoArcGaugeCenterTemplate let-value="value">
 *                 {{ value }}%
 *             </ng-template>
 *         </kendo-arcgauge>
 *
 *     `
 * })
 * export class AppComponent {
 *   public value: number = 10;
 * }
 *
 * ```
 */
let ArcCenterTemplateDirective = class ArcCenterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
ArcCenterTemplateDirective.ɵfac = function ArcCenterTemplateDirective_Factory(t) { return new (t || ArcCenterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
ArcCenterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ArcCenterTemplateDirective, selectors: [["", "kendoArcGaugeCenterTemplate", ""]] });
ArcCenterTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], ArcCenterTemplateDirective);

/* tslint:disable:use-life-cycle-interface */
/**
 * Represents the [Kendo UI ArcGauge component for Angular]({% slug overview_arcgauge_gauges %}).
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *      <kendo-arcgauge [value]="value" [scale]="{ max: 100 }">
 *          <ng-template kendoArcGaugeCenterTemplate let-value="value">
 *              {{ value }}%
 *          </ng-template>
 *      </kendo-arcgauge>
 *   `
 * })
 * class AppComponent {
 *   public value: number = 10;
 * }
 *
 * ```
 */
let ArcGaugeComponent = class ArcGaugeComponent extends GaugeComponent {
    constructor(changeDetector, configurationService, themeService, intlService, localizationService, element, renderer, ngZone) {
        super(configurationService, themeService, intlService, localizationService, element, renderer, ngZone);
        this.changeDetector = changeDetector;
        this.className = true;
        this.centerTemplateContext = {};
    }
    ngOnInit() {
        super.ngOnInit();
        if (this.element) {
            this.renderer.setStyle(this.element.nativeElement, 'position', 'relative');
        }
    }
    ngAfterViewChecked() {
        super.ngAfterViewChecked();
        if (this.labelElement && !this.centerTemplate) {
            this.changeDetector.detectChanges();
        }
        else if (!this.labelElement && this.centerTemplate) {
            this.updateCenterTemplate();
        }
    }
    /**
     * Exports the ArcGauge as a Drawing `Scene`.
     *
     * @returns {Promise<Group>} - A promise that will be resolved with the export visual.
     */
    exportVisual() {
        return drawDOM(this.element.nativeElement);
    }
    /**
     * Detects the size of the container and redraws the Gauge.
     * Resizing is automatic unless you set the `resizeRateLimit` option to `0`.
     */
    resize() {
        super.resize();
        this.updateCenterTemplate();
    }
    createInstance(element, options, theme, context) {
        this.instance = new ArcGauge(element, options, theme, context);
        this.updateElements();
    }
    updateOptions() {
        super.updateOptions();
        this.updateElements();
    }
    setValues() {
        const value = this.configurationService.readValue();
        this.instance.value(value);
        this.updateCenterTemplate();
    }
    updateElements() {
        this.resizeSensor.acceptSize();
        this.updateCenterTemplate();
    }
    updateCenterTemplate() {
        if (!this.instance || !this.centerTemplate) {
            return;
        }
        this.centerTemplateContext.value = this.instance.value();
        this.centerTemplateContext.color = this.instance.currentColor();
        this.changeDetector.detectChanges();
        this.positionLabel();
    }
    positionLabel() {
        if (!this.labelElement) {
            return;
        }
        const element = this.labelElement.nativeElement;
        const width = element.offsetWidth;
        const height = element.offsetHeight;
        const position = this.instance.centerLabelPosition(width, height);
        element.style.top = `${position.top}px`;
        element.style.left = `${position.left}px`;
    }
    //tslint:disable-next-line: no-empty
    updateSize() {
    }
};
ArcGaugeComponent.ɵfac = function ArcGaugeComponent_Factory(t) { return new (t || ArcGaugeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(ThemeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ArcGaugeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ArcGaugeComponent, selectors: [["kendo-arcgauge"]], contentQueries: function ArcGaugeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ArcCenterTemplateDirective, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.centerTemplate = _t.first);
    } }, viewQuery: function ArcGaugeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.labelElement = _t.first);
    } }, hostVars: 2, hostBindings: function ArcGaugeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-arcgauge", ctx.className);
    } }, inputs: { value: "value", color: "color", colors: "colors", opacity: "opacity", scale: "scale" }, exportAs: ["kendoArcGauge"], features: [ɵngcc0.ɵɵProvidersFeature([
            ConfigurationService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.arcgauge'
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 2, consts: [[1, "k-chart-surface"], ["surface", ""], ["class", "k-arcgauge-label", 4, "ngIf"], [3, "rateLimit", "resize"], [1, "k-arcgauge-label"], ["label", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function ArcGaugeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
        ɵngcc0.ɵɵtemplate(2, ArcGaugeComponent_div_2_Template, 3, 2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "kendo-resize-sensor", 3);
        ɵngcc0.ɵɵlistener("resize", function ArcGaugeComponent_Template_kendo_resize_sensor_resize_3_listener($event) { return ctx.onResize($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.centerTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("rateLimit", ctx.resizeRateLimit);
    } }, directives: [ɵngcc3.NgIf, ɵngcc4.ResizeSensorComponent, ɵngcc3.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Number)
], ArcGaugeComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ArcGaugeComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ArcGaugeComponent.prototype, "colors", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ArcGaugeComponent.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ArcGaugeComponent.prototype, "scale", void 0);
__decorate([
    ContentChild(ArcCenterTemplateDirective, { static: false }),
    __metadata("design:type", ArcCenterTemplateDirective)
], ArcGaugeComponent.prototype, "centerTemplate", void 0);
__decorate([
    ViewChild("label", { static: false }),
    __metadata("design:type", ElementRef)
], ArcGaugeComponent.prototype, "labelElement", void 0);
__decorate([
    HostBinding('class.k-arcgauge'),
    __metadata("design:type", Boolean)
], ArcGaugeComponent.prototype, "className", void 0);
ArcGaugeComponent = __decorate([ __metadata("design:paramtypes", [ChangeDetectorRef,
        ConfigurationService,
        ThemeService,
        IntlService,
        LocalizationService,
        ElementRef,
        Renderer2,
        NgZone])
], ArcGaugeComponent);

/**
 * The configuration options of the ArcGauge area.
 * Represents the entire visible area of the ArcGauge.
 */
let ArcGaugeAreaComponent = class ArcGaugeAreaComponent extends GaugeAreaComponent {
    constructor(configurationService) {
        super('gaugeArea', configurationService);
        this.configurationService = configurationService;
    }
};
ArcGaugeAreaComponent.ɵfac = function ArcGaugeAreaComponent_Factory(t) { return new (t || ArcGaugeAreaComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
ArcGaugeAreaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ArcGaugeAreaComponent, selectors: [["kendo-arcgauge-area"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ArcGaugeAreaComponent_Template(rf, ctx) { }, encapsulation: 2 });
ArcGaugeAreaComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], ArcGaugeAreaComponent);

/**
 * The configuration options for the scale of the ArcGauge
 * ([see example]({% slug scaleoptions_arcgauge %})).
 */
let ArcScaleComponent = class ArcScaleComponent extends ScaleComponent {
    constructor(configurationService) {
        super('scale', configurationService);
        this.configurationService = configurationService;
    }
};
ArcScaleComponent.ɵfac = function ArcScaleComponent_Factory(t) { return new (t || ArcScaleComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
ArcScaleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ArcScaleComponent, selectors: [["kendo-arcgauge-scale"]], inputs: { labels: "labels", rangeDistance: "rangeDistance", rangeLineCap: "rangeLineCap", startAngle: "startAngle", endAngle: "endAngle" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ArcScaleComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], ArcScaleComponent.prototype, "labels", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ArcScaleComponent.prototype, "rangeDistance", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ArcScaleComponent.prototype, "rangeLineCap", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ArcScaleComponent.prototype, "startAngle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ArcScaleComponent.prototype, "endAngle", void 0);
ArcScaleComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], ArcScaleComponent);

/**
 * The configuration options for the scale labels of the RadialGauge.
 */
let RadialLabelsComponent = class RadialLabelsComponent extends LabelsComponent {
    constructor(configurationService) {
        super('scale.labels', configurationService);
        this.configurationService = configurationService;
    }
};
RadialLabelsComponent.ɵfac = function RadialLabelsComponent_Factory(t) { return new (t || RadialLabelsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
RadialLabelsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RadialLabelsComponent, selectors: [["kendo-radialgauge-scale-labels"]], inputs: { position: "position" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function RadialLabelsComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], RadialLabelsComponent.prototype, "position", void 0);
RadialLabelsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], RadialLabelsComponent);

/**
 * The configuration options for the scale labels of the ArcGauge.
 */
let ArcLabelsComponent = class ArcLabelsComponent extends RadialLabelsComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        configurationService.set(`${this.key}.visible`, true);
    }
};
ArcLabelsComponent.ɵfac = function ArcLabelsComponent_Factory(t) { return new (t || ArcLabelsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
ArcLabelsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ArcLabelsComponent, selectors: [["kendo-arcgauge-scale-labels"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ArcLabelsComponent_Template(rf, ctx) { }, encapsulation: 2 });
ArcLabelsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], ArcLabelsComponent);

/**
 * The configuration options for an ArcGauge color item.
 */
let ColorComponent = class ColorComponent extends CollectionItemComponent {
    constructor(configurationService, collectionChangesService) {
        super(configurationService, collectionChangesService);
    }
};
ColorComponent.ɵfac = function ColorComponent_Factory(t) { return new (t || ColorComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionChangesService)); };
ColorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColorComponent, selectors: [["kendo-arcgauge-color"]], inputs: { color: "color", opacity: "opacity", from: "from", to: "to" }, features: [ɵngcc0.ɵɵProvidersFeature([ConfigurationService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColorComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], ColorComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ColorComponent.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ColorComponent.prototype, "from", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ColorComponent.prototype, "to", void 0);
ColorComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionChangesService])
], ColorComponent);

/**
 * A collection of one or more ArcGauge colors
 * ([more information and example]({% slug colorranges_arcgauge %})).
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-arcgauge [value]="value">
 *              <kendo-arcgauge-colors>
 *                  <kendo-arcgauge-color *ngFor="let item of colors"
 *                      [from]="item.from" [to]="item.to" [color]="item.color">
 *                  </kendo-arcgauge-color>
 *              </kendo-arcgauge-colors>
 *         </kendo-arcgauge>
 *     `
 * })
 * export class AppComponent {
 *     public value: number = 10;
 *
 *     public colors: any[] = [{
 *         to: 25,
 *         color: '#0058e9'
 *     }, {
 *         from: 25,
 *         to: 50,
 *         color: '#37b400'
 *     }, {
 *         from: 50,
 *         to: 75,
 *         color: '#ffc000'
 *     }, {
 *         from: 75,
 *         color: '#f31700'
 *     }];
 * }
 *
 * ```
 */
let ColorsComponent = class ColorsComponent extends CollectionComponent {
    constructor(configurationService, collectionChangesService) {
        super('colors', configurationService, collectionChangesService);
    }
};
ColorsComponent.ɵfac = function ColorsComponent_Factory(t) { return new (t || ColorsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionChangesService)); };
ColorsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColorsComponent, selectors: [["kendo-arcgauge-colors"]], contentQueries: function ColorsComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColorComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([CollectionChangesService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColorsComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    ContentChildren(ColorComponent),
    __metadata("design:type", QueryList)
], ColorsComponent.prototype, "children", void 0);
ColorsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionChangesService])
], ColorsComponent);

const DIRECTIVES = [ArcGaugeComponent, ArcCenterTemplateDirective, ArcGaugeAreaComponent, ArcScaleComponent, ArcLabelsComponent,
    ColorsComponent, ColorComponent];
/**
 * A [module]({{ site.data.urls.angular['ngmodules'] }}) that includes the ArcGauge component and its directives.
 * Imports the `ArcGaugeModule` into your application
 * [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity) or any other sub-module
 * that will use the ArcGauge component.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { ArcGaugeModule } from '@progress/kendo-angular-gauges';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, ArcGaugeModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
let ArcGaugeModule = class ArcGaugeModule {
};
ArcGaugeModule.ɵfac = function ArcGaugeModule_Factory(t) { return new (t || ArcGaugeModule)(); };
ArcGaugeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ArcGaugeModule });
ArcGaugeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[SharedModule, CommonModule]] });

/**
 * Represents the [Kendo UI LinearGauge component for Angular]({% slug overview_lineargauge_gauges %}).
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *      <kendo-lineargauge [pointer]="{ value: value }">
 *      </kendo-lineargauge>
 *   `
 * })
 * class AppComponent {
 *   public value: number = 10;
 * }
 *
 * ```
 */
let LinearGaugeComponent = class LinearGaugeComponent extends GaugeComponent {
    constructor(configurationService, themeService, intlService, localizationService, element, renderer, ngZone) {
        super(configurationService, themeService, intlService, localizationService, element, renderer, ngZone);
    }
    createInstance(element, options, theme, context) {
        this.instance = new LinearGauge(element, options, theme, context);
    }
};
LinearGaugeComponent.ɵfac = function LinearGaugeComponent_Factory(t) { return new (t || LinearGaugeComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(ThemeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
LinearGaugeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LinearGaugeComponent, selectors: [["kendo-lineargauge"]], inputs: { pointer: "pointer", scale: "scale" }, exportAs: ["kendoLinearGauge"], features: [ɵngcc0.ɵɵProvidersFeature([
            ConfigurationService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.lineargauge'
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 1, consts: [[1, "k-chart-surface"], ["surface", ""], [3, "rateLimit", "resize"]], template: function LinearGaugeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
        ɵngcc0.ɵɵelementStart(2, "kendo-resize-sensor", 2);
        ɵngcc0.ɵɵlistener("resize", function LinearGaugeComponent_Template_kendo_resize_sensor_resize_2_listener($event) { return ctx.onResize($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("rateLimit", ctx.resizeRateLimit);
    } }, directives: [ɵngcc4.ResizeSensorComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], LinearGaugeComponent.prototype, "pointer", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LinearGaugeComponent.prototype, "scale", void 0);
LinearGaugeComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        ThemeService,
        IntlService,
        LocalizationService,
        ElementRef,
        Renderer2,
        NgZone])
], LinearGaugeComponent);

/**
 * The configuration options for the LinearGauge area.
 * Represents the entire visible area of the LinearGauge.
 */
let LinearGaugeAreaComponent = class LinearGaugeAreaComponent extends GaugeAreaComponent {
    constructor(configurationService) {
        super('gaugeArea', configurationService);
        this.configurationService = configurationService;
    }
};
LinearGaugeAreaComponent.ɵfac = function LinearGaugeAreaComponent_Factory(t) { return new (t || LinearGaugeAreaComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
LinearGaugeAreaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LinearGaugeAreaComponent, selectors: [["kendo-lineargauge-area"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LinearGaugeAreaComponent_Template(rf, ctx) { }, encapsulation: 2 });
LinearGaugeAreaComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], LinearGaugeAreaComponent);

/**
 * The configuration options for the scale of the LinearGauge
 * ([see example]({% slug scaleoptions_lineargauge %})).
 */
let LinearScaleComponent = class LinearScaleComponent extends ScaleComponent {
    constructor(configurationService) {
        super('scale', configurationService);
        this.configurationService = configurationService;
    }
};
LinearScaleComponent.ɵfac = function LinearScaleComponent_Factory(t) { return new (t || LinearScaleComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
LinearScaleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LinearScaleComponent, selectors: [["kendo-lineargauge-scale"]], inputs: { line: "line", ranges: "ranges", mirror: "mirror", vertical: "vertical" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LinearScaleComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], LinearScaleComponent.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], LinearScaleComponent.prototype, "ranges", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], LinearScaleComponent.prototype, "mirror", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], LinearScaleComponent.prototype, "vertical", void 0);
LinearScaleComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], LinearScaleComponent);

/**
 * The configuration options for the scale labels of the LinearGauge.
 */
let LinearLabelsComponent = class LinearLabelsComponent extends LabelsComponent {
    constructor(configurationService) {
        super('scale.labels', configurationService);
        this.configurationService = configurationService;
    }
};
LinearLabelsComponent.ɵfac = function LinearLabelsComponent_Factory(t) { return new (t || LinearLabelsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
LinearLabelsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LinearLabelsComponent, selectors: [["kendo-lineargauge-scale-labels"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LinearLabelsComponent_Template(rf, ctx) { }, encapsulation: 2 });
LinearLabelsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], LinearLabelsComponent);

/**
 * The configuration options for a pointer item of a LinearGauge.
 */
let LinearPointerComponent = class LinearPointerComponent extends CollectionItemComponent {
    constructor(configurationService, collectionChangesService) {
        super(configurationService, collectionChangesService);
    }
};
LinearPointerComponent.ɵfac = function LinearPointerComponent_Factory(t) { return new (t || LinearPointerComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionChangesService)); };
LinearPointerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LinearPointerComponent, selectors: [["kendo-lineargauge-pointer"]], inputs: { border: "border", color: "color", margin: "margin", opacity: "opacity", shape: "shape", size: "size", value: "value" }, features: [ɵngcc0.ɵɵProvidersFeature([ConfigurationService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LinearPointerComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], LinearPointerComponent.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], LinearPointerComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LinearPointerComponent.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LinearPointerComponent.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], LinearPointerComponent.prototype, "shape", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LinearPointerComponent.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LinearPointerComponent.prototype, "value", void 0);
LinearPointerComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionChangesService])
], LinearPointerComponent);

/**
 * A collection of one or more LinearGauge pointers
 * ([more information]({% slug multiplepointers_lineargauge %})).
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-lineargauge>
 *             <kendo-lineargauge-pointers>
 *                 <kendo-lineargauge-pointer *ngFor="let pointer of pointers"
 *                     [value]="pointer.value" [color]="pointer.color" shape="barIndicator">
 *                 </kendo-lineargauge-pointer>
 *             </kendo-lineargauge-pointers>
 *         </kendo-lineargauge>
 *     `
 * })
 * export class AppComponent {
 *     public pointers: any[] = [{
 *         value: 10,
 *         color: '#ff4500'
 *     }, {
 *         value: 12,
 *         color: '#28b4c8'
 *     }, {
 *         value: 20,
 *         color: '#8b0000'
 *     }];
 * }
 *
 * ```
 */
let LinearPointersComponent = class LinearPointersComponent extends CollectionComponent {
    constructor(configurationService, collectionChangesService) {
        super('pointer', configurationService, collectionChangesService);
    }
};
LinearPointersComponent.ɵfac = function LinearPointersComponent_Factory(t) { return new (t || LinearPointersComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionChangesService)); };
LinearPointersComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LinearPointersComponent, selectors: [["kendo-lineargauge-pointers"]], contentQueries: function LinearPointersComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, LinearPointerComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([CollectionChangesService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LinearPointersComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    ContentChildren(LinearPointerComponent),
    __metadata("design:type", QueryList)
], LinearPointersComponent.prototype, "children", void 0);
LinearPointersComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionChangesService])
], LinearPointersComponent);

/**
 * The configuration options for a scale range item of a LinearGauge.
 */
let LinearRangeComponent = class LinearRangeComponent extends RangeComponent {
    constructor(configurationService, collectionChangesService) {
        super(configurationService, collectionChangesService);
    }
};
LinearRangeComponent.ɵfac = function LinearRangeComponent_Factory(t) { return new (t || LinearRangeComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionChangesService)); };
LinearRangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LinearRangeComponent, selectors: [["kendo-lineargauge-scale-range"]], features: [ɵngcc0.ɵɵProvidersFeature([ConfigurationService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LinearRangeComponent_Template(rf, ctx) { }, encapsulation: 2 });
LinearRangeComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionChangesService])
], LinearRangeComponent);

/**
 * A collection of one or more LinearGauge scale ranges
 * ([more information and example]({% slug scaleranghes_lineargauge %})).
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-lineargauge>
 *             <kendo-lineargauge-scale>
 *                 <kendo-lineargauge-scale-ranges>
 *                     <kendo-lineargauge-scale-range *ngFor="let range of ranges"
 *                         [from]="range.from" [to]="range.to" [color]="range.color">
 *                     </kendo-lineargauge-scale-range>
 *                 </kendo-lineargauge-scale-ranges>
 *             </kendo-lineargauge-scale>
 *         </kendo-lineargauge>
 *     `
 * })
 * export class AppComponent {
 *     public ranges: any[] = [{
 *         from: 0,
 *         to: 15,
 *         color: '#ffd246'
 *     }, {
 *         from: 15,
 *         to: 30,
 *         color: '#28b4c8'
 *     }, {
 *         from: 30,
 *         to: 50,
 *         color: '#78d237'
 *     }];
 * }
 *
 * ```
 */
let LinearRangesComponent = class LinearRangesComponent extends CollectionComponent {
    constructor(configurationService, collectionChangesService) {
        super('scale.ranges', configurationService, collectionChangesService);
    }
};
LinearRangesComponent.ɵfac = function LinearRangesComponent_Factory(t) { return new (t || LinearRangesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionChangesService)); };
LinearRangesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LinearRangesComponent, selectors: [["kendo-lineargauge-scale-ranges"]], contentQueries: function LinearRangesComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, LinearRangeComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([CollectionChangesService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LinearRangesComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    ContentChildren(LinearRangeComponent),
    __metadata("design:type", QueryList)
], LinearRangesComponent.prototype, "children", void 0);
LinearRangesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionChangesService])
], LinearRangesComponent);

const DIRECTIVES$1 = [LinearGaugeComponent, LinearGaugeAreaComponent, LinearScaleComponent, LinearLabelsComponent,
    LinearPointersComponent, LinearPointerComponent, LinearRangeComponent, LinearRangesComponent];
/**
 * A [module]({{ site.data.urls.angular['ngmodules'] }}) that includes the LinearGauge component and its directives.
 * Imports the `LinearGaugeModule` into your application
 * [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity) or any other sub-module
 * that will use the LinearGauge component.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { LinearGaugeModule } from '@progress/kendo-angular-gauges';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, LinearGaugeModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
let LinearGaugeModule = class LinearGaugeModule {
};
LinearGaugeModule.ɵfac = function LinearGaugeModule_Factory(t) { return new (t || LinearGaugeModule)(); };
LinearGaugeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LinearGaugeModule });
LinearGaugeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[SharedModule]] });

/**
 * Represents the [Kendo UI RadialGauge component for Angular]({% slug overview_radialgauge_gauges %}).
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *      <kendo-radialgauge [pointer]="{ value: value }">
 *      </kendo-radialgauge>
 *   `
 * })
 * class AppComponent {
 *   public value: number = 10;
 * }
 *
 * ```
 */
let RadialGaugeComponent = class RadialGaugeComponent extends GaugeComponent {
    constructor(configurationService, themeService, intlService, localizationService, element, renderer, ngZone) {
        super(configurationService, themeService, intlService, localizationService, element, renderer, ngZone);
    }
    createInstance(element, options, theme, context) {
        this.instance = new RadialGauge(element, options, theme, context);
    }
};
RadialGaugeComponent.ɵfac = function RadialGaugeComponent_Factory(t) { return new (t || RadialGaugeComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(ThemeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
RadialGaugeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RadialGaugeComponent, selectors: [["kendo-radialgauge"]], inputs: { pointer: "pointer", scale: "scale" }, exportAs: ["kendoRadialGauge"], features: [ɵngcc0.ɵɵProvidersFeature([
            ConfigurationService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.radialgauge'
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 1, consts: [[1, "k-chart-surface"], ["surface", ""], [3, "rateLimit", "resize"]], template: function RadialGaugeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
        ɵngcc0.ɵɵelementStart(2, "kendo-resize-sensor", 2);
        ɵngcc0.ɵɵlistener("resize", function RadialGaugeComponent_Template_kendo_resize_sensor_resize_2_listener($event) { return ctx.onResize($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("rateLimit", ctx.resizeRateLimit);
    } }, directives: [ɵngcc4.ResizeSensorComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], RadialGaugeComponent.prototype, "pointer", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RadialGaugeComponent.prototype, "scale", void 0);
RadialGaugeComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        ThemeService,
        IntlService,
        LocalizationService,
        ElementRef,
        Renderer2,
        NgZone])
], RadialGaugeComponent);

/**
 * The configuration options for the RadialGauge area.
 * Represents the entire visible area of the RadialGauge.
 */
let RadialGaugeAreaComponent = class RadialGaugeAreaComponent extends GaugeAreaComponent {
    constructor(configurationService) {
        super('gaugeArea', configurationService);
        this.configurationService = configurationService;
    }
};
RadialGaugeAreaComponent.ɵfac = function RadialGaugeAreaComponent_Factory(t) { return new (t || RadialGaugeAreaComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
RadialGaugeAreaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RadialGaugeAreaComponent, selectors: [["kendo-radialgauge-area"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function RadialGaugeAreaComponent_Template(rf, ctx) { }, encapsulation: 2 });
RadialGaugeAreaComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], RadialGaugeAreaComponent);

/**
 * The configuration options for the scale of the RadialGauge
 * ([more information and example]({% slug scaleoptions_radialgauge %})).
 */
let RadialScaleComponent = class RadialScaleComponent extends ScaleComponent {
    constructor(configurationService) {
        super('scale', configurationService);
        this.configurationService = configurationService;
    }
};
RadialScaleComponent.ɵfac = function RadialScaleComponent_Factory(t) { return new (t || RadialScaleComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
RadialScaleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RadialScaleComponent, selectors: [["kendo-radialgauge-scale"]], inputs: { labels: "labels", rangeDistance: "rangeDistance", ranges: "ranges", startAngle: "startAngle", endAngle: "endAngle" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function RadialScaleComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], RadialScaleComponent.prototype, "labels", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], RadialScaleComponent.prototype, "rangeDistance", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], RadialScaleComponent.prototype, "ranges", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], RadialScaleComponent.prototype, "startAngle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], RadialScaleComponent.prototype, "endAngle", void 0);
RadialScaleComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], RadialScaleComponent);

/**
 * The configuration options for a pointer item of a RadialGauge.
 */
let RadialPointerComponent = class RadialPointerComponent extends CollectionItemComponent {
    constructor(configurationService, collectionChangesService) {
        super(configurationService, collectionChangesService);
    }
};
RadialPointerComponent.ɵfac = function RadialPointerComponent_Factory(t) { return new (t || RadialPointerComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionChangesService)); };
RadialPointerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RadialPointerComponent, selectors: [["kendo-radialgauge-pointer"]], inputs: { cap: "cap", color: "color", length: "length", value: "value" }, features: [ɵngcc0.ɵɵProvidersFeature([ConfigurationService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function RadialPointerComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], RadialPointerComponent.prototype, "cap", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RadialPointerComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], RadialPointerComponent.prototype, "length", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], RadialPointerComponent.prototype, "value", void 0);
RadialPointerComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionChangesService])
], RadialPointerComponent);

/**
 * A collection of one or more RadialGauge pointers
 * ([more information and example]({% slug multiplepointers_radialgauge %})).
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-radialgauge>
 *             <kendo-radialgauge-pointers>
 *                 <kendo-radialgauge-pointer *ngFor="let pointer of pointers"
 *                     [value]="pointer.value" [color]="pointer.color">
 *                 </kendo-radialgauge-pointer>
 *             </kendo-radialgauge-pointers>
 *         </kendo-radialgauge>
 *     `
 * })
 * export class AppComponent {
 *     public pointers: any[] = [{
 *         value: 10,
 *         color: '#ffd246'
 *     }, {
 *         value: 20,
 *         color: '#28b4c8'
 *     }, {
 *         value: 30,
 *         color: '#78d237'
 *     }];
 * }
 *
 * ```
 */
let RadialPointersComponent = class RadialPointersComponent extends CollectionComponent {
    constructor(configurationService, collectionChangesService) {
        super('pointer', configurationService, collectionChangesService);
    }
};
RadialPointersComponent.ɵfac = function RadialPointersComponent_Factory(t) { return new (t || RadialPointersComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionChangesService)); };
RadialPointersComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RadialPointersComponent, selectors: [["kendo-radialgauge-pointers"]], contentQueries: function RadialPointersComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, RadialPointerComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([CollectionChangesService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function RadialPointersComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    ContentChildren(RadialPointerComponent),
    __metadata("design:type", QueryList)
], RadialPointersComponent.prototype, "children", void 0);
RadialPointersComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionChangesService])
], RadialPointersComponent);

/**
 * The configuration options for a scale range item of a RadialGauge.
 */
let RadialRangeComponent = class RadialRangeComponent extends RangeComponent {
    constructor(configurationService, collectionChangesService) {
        super(configurationService, collectionChangesService);
    }
};
RadialRangeComponent.ɵfac = function RadialRangeComponent_Factory(t) { return new (t || RadialRangeComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionChangesService)); };
RadialRangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RadialRangeComponent, selectors: [["kendo-radialgauge-scale-range"]], features: [ɵngcc0.ɵɵProvidersFeature([ConfigurationService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function RadialRangeComponent_Template(rf, ctx) { }, encapsulation: 2 });
RadialRangeComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionChangesService])
], RadialRangeComponent);

/**
 * A collection of one or more RadialGauge scale ranges
 * ([more information and example]({% slug scaleranghes_radialgauge %})).
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-radialgauge>
 *             <kendo-radialgauge-scale>
 *                 <kendo-radialgauge-scale-ranges>
 *                     <kendo-radialgauge-scale-range *ngFor="let range of ranges"
 *                         [from]="range.from" [to]="range.to" [color]="range.color">
 *                     </kendo-radialgauge-scale-range>
 *                 </kendo-radialgauge-scale-ranges>
 *             </kendo-radialgauge-scale>
 *         </kendo-radialgauge>
 *     `
 * })
 * export class AppComponent {
 *     public ranges: any[] = [{
 *         from: 0,
 *         to: 15,
 *         color: '#ffd246'
 *     }, {
 *         from: 15,
 *         to: 30,
 *         color: '#28b4c8'
 *     }, {
 *         from: 30,
 *         to: 50,
 *         color: '#78d237'
 *     }];
 * }
 *
 * ```
 */
let RadialRangesComponent = class RadialRangesComponent extends CollectionComponent {
    constructor(configurationService, collectionChangesService) {
        super('scale.ranges', configurationService, collectionChangesService);
    }
};
RadialRangesComponent.ɵfac = function RadialRangesComponent_Factory(t) { return new (t || RadialRangesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionChangesService)); };
RadialRangesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RadialRangesComponent, selectors: [["kendo-radialgauge-scale-ranges"]], contentQueries: function RadialRangesComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, RadialRangeComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([CollectionChangesService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function RadialRangesComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    ContentChildren(RadialRangeComponent),
    __metadata("design:type", QueryList)
], RadialRangesComponent.prototype, "children", void 0);
RadialRangesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionChangesService])
], RadialRangesComponent);

const DIRECTIVES$2 = [RadialGaugeComponent, RadialGaugeAreaComponent, RadialScaleComponent, RadialLabelsComponent,
    RadialPointersComponent, RadialPointerComponent, RadialRangeComponent, RadialRangesComponent];
/**
 * A [module]({{ site.data.urls.angular['ngmodules'] }}) that includes the RadialGauge component and its directives.
 * Imports the `RadialGaugeModule` into your application
 * [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity) or any other sub-module
 * that will use the RadialGauge component.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { RadialGaugeModule } from '@progress/kendo-angular-gauges';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, RadialGaugeModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
let RadialGaugeModule = class RadialGaugeModule {
};
RadialGaugeModule.ɵfac = function RadialGaugeModule_Factory(t) { return new (t || RadialGaugeModule)(); };
RadialGaugeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: RadialGaugeModule });
RadialGaugeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[SharedModule]] });

/**
 * A [module]({{ site.data.urls.angular['ngmodules'] }}) that includes all Gauge components and directives.
 *
 * Imports the `GaugesModule` into your application
 * [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity) or any other sub-module
 * that will use the Gauge components.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { GaugesModule } from '@progress/kendo-angular-charts';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, GaugesModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
let GaugesModule = class GaugesModule {
};
GaugesModule.ɵfac = function GaugesModule_Factory(t) { return new (t || GaugesModule)(); };
GaugesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: GaugesModule });
GaugesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [ArcGaugeModule, LinearGaugeModule, RadialGaugeModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ConfigurationService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CollectionChangesService, [{
        type: Injectable
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ThemeService, [{
        type: Injectable
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedModule, { exports: function () { return [ResizeSensorModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SharedModule, [{
        type: NgModule,
        args: [{
                exports: [ResizeSensorModule],
                providers: [
                    ThemeService
                ]
            }]
    }], null, null); })();




const ɵGaugeAreaComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(GaugeAreaComponent);
const ɵLabelsComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(LabelsComponent);
const ɵRangeComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(RangeComponent);
const ɵScaleComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(ScaleComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ArcCenterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoArcGaugeCenterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ArcGaugeComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'kendoArcGauge',
                providers: [
                    ConfigurationService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.arcgauge'
                    }
                ],
                selector: 'kendo-arcgauge',
                template: `
    <div #surface class='k-chart-surface'></div>
    <div class="k-arcgauge-label" *ngIf="centerTemplate" #label>
        <ng-template [ngTemplateOutlet]="centerTemplate.templateRef" [ngTemplateOutletContext]="centerTemplateContext"></ng-template>
    </div>
    <kendo-resize-sensor (resize)="onResize($event)" [rateLimit]="resizeRateLimit"></kendo-resize-sensor>
  `
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ConfigurationService }, { type: ThemeService }, { type: ɵngcc1.IntlService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { className: [{
            type: HostBinding,
            args: ['class.k-arcgauge']
        }], value: [{
            type: Input
        }], color: [{
            type: Input
        }], colors: [{
            type: Input
        }], opacity: [{
            type: Input
        }], scale: [{
            type: Input
        }], centerTemplate: [{
            type: ContentChild,
            args: [ArcCenterTemplateDirective, { static: false }]
        }], labelElement: [{
            type: ViewChild,
            args: ["label", { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ArcGaugeAreaComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-arcgauge-area',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ArcScaleComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-arcgauge-scale',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, { labels: [{
            type: Input
        }], rangeDistance: [{
            type: Input
        }], rangeLineCap: [{
            type: Input
        }], startAngle: [{
            type: Input
        }], endAngle: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadialLabelsComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-radialgauge-scale-labels',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, { position: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ArcLabelsComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-arcgauge-scale-labels',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColorComponent, [{
        type: Component,
        args: [{
                providers: [ConfigurationService],
                selector: 'kendo-arcgauge-color',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionChangesService }]; }, { color: [{
            type: Input
        }], opacity: [{
            type: Input
        }], from: [{
            type: Input
        }], to: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColorsComponent, [{
        type: Component,
        args: [{
                providers: [CollectionChangesService],
                selector: 'kendo-arcgauge-colors',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionChangesService }]; }, { children: [{
            type: ContentChildren,
            args: [ColorComponent]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ArcGaugeModule, { declarations: function () { return [ArcGaugeComponent, ArcCenterTemplateDirective, ArcGaugeAreaComponent, ArcScaleComponent, ArcLabelsComponent, ColorsComponent, ColorComponent]; }, imports: function () { return [SharedModule, CommonModule]; }, exports: function () { return [ArcGaugeComponent, ArcCenterTemplateDirective, ArcGaugeAreaComponent, ArcScaleComponent, ArcLabelsComponent, ColorsComponent, ColorComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ArcGaugeModule, [{
        type: NgModule,
        args: [{
                declarations: [DIRECTIVES],
                exports: [DIRECTIVES],
                imports: [SharedModule, CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LinearGaugeComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'kendoLinearGauge',
                providers: [
                    ConfigurationService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.lineargauge'
                    }
                ],
                selector: 'kendo-lineargauge',
                template: `
    <div #surface class='k-chart-surface'></div>
    <kendo-resize-sensor (resize)="onResize($event)" [rateLimit]="resizeRateLimit"></kendo-resize-sensor>
  `
            }]
    }], function () { return [{ type: ConfigurationService }, { type: ThemeService }, { type: ɵngcc1.IntlService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { pointer: [{
            type: Input
        }], scale: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LinearGaugeAreaComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-lineargauge-area',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LinearScaleComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-lineargauge-scale',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, { line: [{
            type: Input
        }], ranges: [{
            type: Input
        }], mirror: [{
            type: Input
        }], vertical: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LinearLabelsComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-lineargauge-scale-labels',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LinearPointerComponent, [{
        type: Component,
        args: [{
                providers: [ConfigurationService],
                selector: 'kendo-lineargauge-pointer',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionChangesService }]; }, { border: [{
            type: Input
        }], color: [{
            type: Input
        }], margin: [{
            type: Input
        }], opacity: [{
            type: Input
        }], shape: [{
            type: Input
        }], size: [{
            type: Input
        }], value: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LinearPointersComponent, [{
        type: Component,
        args: [{
                providers: [CollectionChangesService],
                selector: 'kendo-lineargauge-pointers',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionChangesService }]; }, { children: [{
            type: ContentChildren,
            args: [LinearPointerComponent]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LinearRangeComponent, [{
        type: Component,
        args: [{
                providers: [ConfigurationService],
                selector: 'kendo-lineargauge-scale-range',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionChangesService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LinearRangesComponent, [{
        type: Component,
        args: [{
                providers: [CollectionChangesService],
                selector: 'kendo-lineargauge-scale-ranges',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionChangesService }]; }, { children: [{
            type: ContentChildren,
            args: [LinearRangeComponent]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LinearGaugeModule, { declarations: [LinearGaugeComponent, LinearGaugeAreaComponent, LinearScaleComponent, LinearLabelsComponent, LinearPointersComponent, LinearPointerComponent, LinearRangeComponent, LinearRangesComponent], imports: [SharedModule], exports: [LinearGaugeComponent, LinearGaugeAreaComponent, LinearScaleComponent, LinearLabelsComponent, LinearPointersComponent, LinearPointerComponent, LinearRangeComponent, LinearRangesComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LinearGaugeModule, [{
        type: NgModule,
        args: [{
                declarations: [DIRECTIVES$1],
                exports: [DIRECTIVES$1],
                imports: [SharedModule]
            }]
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadialGaugeComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'kendoRadialGauge',
                providers: [
                    ConfigurationService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.radialgauge'
                    }
                ],
                selector: 'kendo-radialgauge',
                template: `
    <div #surface class='k-chart-surface'></div>
    <kendo-resize-sensor (resize)="onResize($event)" [rateLimit]="resizeRateLimit"></kendo-resize-sensor>
  `
            }]
    }], function () { return [{ type: ConfigurationService }, { type: ThemeService }, { type: ɵngcc1.IntlService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { pointer: [{
            type: Input
        }], scale: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadialGaugeAreaComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-radialgauge-area',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadialScaleComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-radialgauge-scale',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, { labels: [{
            type: Input
        }], rangeDistance: [{
            type: Input
        }], ranges: [{
            type: Input
        }], startAngle: [{
            type: Input
        }], endAngle: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadialPointerComponent, [{
        type: Component,
        args: [{
                providers: [ConfigurationService],
                selector: 'kendo-radialgauge-pointer',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionChangesService }]; }, { cap: [{
            type: Input
        }], color: [{
            type: Input
        }], length: [{
            type: Input
        }], value: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadialPointersComponent, [{
        type: Component,
        args: [{
                providers: [CollectionChangesService],
                selector: 'kendo-radialgauge-pointers',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionChangesService }]; }, { children: [{
            type: ContentChildren,
            args: [RadialPointerComponent]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadialRangeComponent, [{
        type: Component,
        args: [{
                providers: [ConfigurationService],
                selector: 'kendo-radialgauge-scale-range',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionChangesService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadialRangesComponent, [{
        type: Component,
        args: [{
                providers: [CollectionChangesService],
                selector: 'kendo-radialgauge-scale-ranges',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionChangesService }]; }, { children: [{
            type: ContentChildren,
            args: [RadialRangeComponent]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RadialGaugeModule, { declarations: [RadialGaugeComponent, RadialGaugeAreaComponent, RadialScaleComponent, RadialLabelsComponent, RadialPointersComponent, RadialPointerComponent, RadialRangeComponent, RadialRangesComponent], imports: [SharedModule], exports: [RadialGaugeComponent, RadialGaugeAreaComponent, RadialScaleComponent, RadialLabelsComponent, RadialPointersComponent, RadialPointerComponent, RadialRangeComponent, RadialRangesComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadialGaugeModule, [{
        type: NgModule,
        args: [{
                declarations: [DIRECTIVES$2],
                exports: [DIRECTIVES$2],
                imports: [SharedModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GaugesModule, { exports: [ArcGaugeModule, LinearGaugeModule, RadialGaugeModule] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GaugesModule, [{
        type: NgModule,
        args: [{
                exports: [ArcGaugeModule, LinearGaugeModule, RadialGaugeModule]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { SharedModule, ArcGaugeModule, LinearGaugeModule, RadialGaugeModule, GaugesModule, CollectionComponent, CollectionItemComponent, GaugeComponent, GaugeAreaComponent, LabelsComponent, RangeComponent, ScaleComponent, SettingsComponent, ConfigurationService, CollectionChangesService, ThemeService, ArcGaugeComponent, ArcGaugeAreaComponent, ArcScaleComponent, ArcLabelsComponent, ArcCenterTemplateDirective, ColorsComponent, ColorComponent, LinearGaugeComponent, LinearGaugeAreaComponent, LinearScaleComponent, LinearLabelsComponent, LinearPointersComponent, LinearPointerComponent, LinearRangeComponent, LinearRangesComponent, RadialGaugeComponent, RadialGaugeAreaComponent, RadialScaleComponent, RadialLabelsComponent, RadialPointersComponent, RadialPointerComponent, RadialRangeComponent, RadialRangesComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0pBR3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b0tBRzZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnSUFHaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozt3Q0FRaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttRkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29JQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OExBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dIQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0T0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dUQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnTUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4V0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7dUpBQUU7QUFDRix5Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttSUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FxQkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7aVJBQUU7QUFDRixvQ0FLRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a1pBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBS0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4VEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBS0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dSQUFFO0FBQ0YsaUNBS0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d1hBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztnTkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7MkZBT21CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OzZGQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQWtCRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NlJBQUU7QUFDRix1Q0FLRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c1dBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUtHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NFJBQUU7QUFDRixvQ0FLRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsrY0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozt3TkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsyVUFBRTtBQUNGLG1DQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O3NOQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztnRkFPc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7NkZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBa0JHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2UkFBRTtBQUNGLHVDQUtHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrWkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FLRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt1WkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozt3TkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsyVUFBRTtBQUNGLG1DQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O3NOQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztnRkFPc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBS2lCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEsIF9fcGFyYW0gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBJbmplY3RhYmxlLCBOZ01vZHVsZSwgSW5wdXQsIFZpZXdDaGlsZCwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIERpcmVjdGl2ZSwgT3B0aW9uYWwsIFRlbXBsYXRlUmVmLCBDb250ZW50Q2hpbGQsIENvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBSZW5kZXJlcjIsIE5nWm9uZSwgQ29udGVudENoaWxkcmVuLCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBSZXNpemVTZW5zb3JNb2R1bGUsIFJlc2l6ZVNlbnNvckNvbXBvbmVudCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNvbW1vbic7XG5leHBvcnQgeyBSZXNpemVTZW5zb3JDb21wb25lbnQgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1jb21tb24nO1xuaW1wb3J0IHsgSW50bFNlcnZpY2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnRsJztcbmltcG9ydCB7IExvY2FsaXphdGlvblNlcnZpY2UsIEwxME5fUFJFRklYIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbDEwbic7XG5pbXBvcnQgeyBleHBvcnRJbWFnZSwgZXhwb3J0U1ZHLCBkcmF3RE9NIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWRyYXdpbmcnO1xuaW1wb3J0IHsgdmFsaWRhdGVQYWNrYWdlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWxpY2Vuc2luZyc7XG5pbXBvcnQgeyBBcmNHYXVnZSwgTGluZWFyR2F1Z2UsIFJhZGlhbEdhdWdlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWNoYXJ0cyc7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGRpZmZPcHRpb25zKG9yaWdpbmFsLCBjdXJyZW50KSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKG9yaWdpbmFsKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGN1cnJlbnQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgZmllbGQgaW4gb3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKGZpZWxkICE9PSAndmFsdWUnICYmIG9yaWdpbmFsLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsW2ZpZWxkXTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRbZmllbGRdO1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGlzT2JqZWN0KG9yaWdpbmFsVmFsdWUpICYmIGlzT2JqZWN0KGN1cnJlbnRWYWx1ZSkgP1xuICAgICAgICAgICAgICAgIGRpZmZPcHRpb25zKG9yaWdpbmFsVmFsdWUsIGN1cnJlbnRWYWx1ZSkgOiBvcmlnaW5hbFZhbHVlICE9PSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZGlmZlBvaW50ZXJPcHRpb25zKG9yaWdpbmFsLCBjdXJyZW50KSB7XG4gICAgaWYgKCFvcmlnaW5hbCB8fCAhY3VycmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgb3JpZ2luYWwgPSBbXS5jb25jYXQob3JpZ2luYWwpO1xuICAgIGN1cnJlbnQgPSBbXS5jb25jYXQoY3VycmVudCk7XG4gICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPT0gY3VycmVudC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IG9yaWdpbmFsLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKGRpZmZPcHRpb25zKG9yaWdpbmFsW2lkeF0sIGN1cnJlbnRbaWR4XSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBDb25maWd1cmF0aW9uU2VydmljZSA9IGNsYXNzIENvbmZpZ3VyYXRpb25TZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBjb3B5Q2hhbmdlcyhwcmVmaXgsIGNoYW5nZXMpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHlOYW1lIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICghY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZXNbcHJvcGVydHlOYW1lXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25OYW1lID0gKHByZWZpeCA/IHByZWZpeCArICcuJyA6ICcnKSArIHByb3BlcnR5TmFtZTtcbiAgICAgICAgICAgIHRoaXMuc2V0KG9wdGlvbk5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkKCkge1xuICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cbiAgICByZWFkVmFsdWVzKCkge1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHBvaW50ZXJzID0gW10uY29uY2F0KHRoaXMub3B0aW9ucy5wb2ludGVyKTtcbiAgICAgICAgcmV0dXJuIHBvaW50ZXJzLm1hcCgocG9pbnRlcikgPT4gcG9pbnRlci52YWx1ZSk7XG4gICAgfVxuICAgIHJlYWRWYWx1ZSgpIHtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlO1xuICAgIH1cbiAgICBzZXQoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25zIH0gPSB0aGlzLm9wdGlvbkNvbnRleHQoZmllbGQpO1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ2hhbmdlcyAmJiAoa2V5ID09PSAndmFsdWUnIHx8IChrZXkgPT09ICdwb2ludGVyJyAmJiAhZGlmZlBvaW50ZXJPcHRpb25zKHRoaXMub3B0aW9ucy5wb2ludGVyLCB2YWx1ZSkpKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICBvcHRpb25Db250ZXh0KGZpZWxkKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gZmllbGQuc3BsaXQoJy4nKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGxldCBrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICB3aGlsZSAocGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XSB8fCB7fTtcbiAgICAgICAgICAgIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsga2V5OiBrZXksIG9wdGlvbnM6IG9wdGlvbnMgfTtcbiAgICB9XG59O1xuQ29uZmlndXJhdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIENvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBDb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UgPSBjbGFzcyBDb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2Uge1xufTtcbkNvbGxlY3Rpb25DaGFuZ2VzU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgQ29sbGVjdGlvbkNoYW5nZXNTZXJ2aWNlKTtcblxuY29uc3QgdGVtcGxhdGUgPSBgXG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1nYXVnZS1wb2ludGVyXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1nYXVnZS10cmFja1wiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tbm9ybWFsLXRleHQtY29sb3JcIj48L2Rpdj5cbmA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFRoZW1lU2VydmljZSA9IGNsYXNzIFRoZW1lU2VydmljZSB7XG4gICAgcmVhZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gICAgfVxuICAgIGxvYWQoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSB0ZW1wbGF0ZTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRlckNvbG9yID0gdGhpcy5nZXRDb2xvcihjb250YWluZXIsICdnYXVnZS1wb2ludGVyJyk7XG4gICAgICAgICAgICBjb25zdCByYW5nZVBsYWNlaG9sZGVyID0gdGhpcy5nZXRDb2xvcihjb250YWluZXIsICdnYXVnZS10cmFjaycpO1xuICAgICAgICAgICAgY29uc3QgdGV4dENvbG9yID0gdGhpcy5nZXRDb2xvcihjb250YWluZXIsICdub3JtYWwtdGV4dC1jb2xvcicpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHBvaW50ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHBvaW50ZXJDb2xvclxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGV4dENvbG9yXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlUGxhY2Vob2xkZXJDb2xvcjogcmFuZ2VQbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgbWlub3JUaWNrczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRleHRDb2xvclxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtYWpvclRpY2tzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGV4dENvbG9yXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0ZXh0Q29sb3JcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q29sb3IoY29udGFpbmVyLCB2YXJOYW1lKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIucXVlcnlTZWxlY3RvcihgLmstdmFyLS0ke3Zhck5hbWV9YCkpLmJhY2tncm91bmRDb2xvcjtcbiAgICB9XG59O1xuVGhlbWVTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBUaGVtZVNlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFNoYXJlZE1vZHVsZSA9IGNsYXNzIFNoYXJlZE1vZHVsZSB7XG59O1xuU2hhcmVkTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBleHBvcnRzOiBbUmVzaXplU2Vuc29yTW9kdWxlXSxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBUaGVtZVNlcnZpY2VcbiAgICAgICAgXVxuICAgIH0pXG5dLCBTaGFyZWRNb2R1bGUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ29sbGVjdGlvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvbkNoYW5nZXNTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbkNoYW5nZXNTZXJ2aWNlID0gY29sbGVjdGlvbkNoYW5nZXNTZXJ2aWNlO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZS5zZXQodGhpcy5rZXksIFtdKTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuY2hpbGRyZW4uY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UuaGFzQ2hhbmdlcyA9IHRydWUpO1xuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbGxlY3Rpb25DaGFuZ2VzU2VydmljZS5oYXNDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLnNldCh0aGlzLmtleSwgdGhpcy5yZWFkSXRlbXMoKSk7XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3Rpb25DaGFuZ2VzU2VydmljZS5oYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZEl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gT2JqZWN0LmFzc2lnbih7fSwgY2hpbGQuY29uZmlndXJhdGlvblNlcnZpY2UucmVhZCgpKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ29sbGVjdGlvbkl0ZW1Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25DaGFuZ2VzU2VydmljZSA9IGNvbGxlY3Rpb25DaGFuZ2VzU2VydmljZTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLmNvcHlDaGFuZ2VzKCcnLCBjaGFuZ2VzKTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UuaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcGFja2FnZU1ldGFkYXRhID0ge1xuICAgIG5hbWU6ICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1nYXVnZXMnLFxuICAgIHByb2R1Y3ROYW1lOiAnS2VuZG8gVUkgZm9yIEFuZ3VsYXInLFxuICAgIHByb2R1Y3RDb2RlczogWydLRU5ET1VJQU5HVUxBUicsICdLRU5ET1VJQ09NUExFVEUnXSxcbiAgICBwdWJsaXNoRGF0ZTogMTYwODEzMzkzNSxcbiAgICB2ZXJzaW9uOiAnJyxcbiAgICBsaWNlbnNpbmdEb2NzVXJsOiAnaHR0cHM6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9teS1saWNlbnNlLz91dG1fbWVkaXVtPXByb2R1Y3QmdXRtX3NvdXJjZT1rZW5kb2FuZ3VsYXImdXRtX2NhbXBhaWduPWtlbmRvLXVpLWFuZ3VsYXItcHVyY2hhc2UtbGljZW5zZS1rZXlzLXdhcm5pbmcnXG59O1xuXG5jb25zdCBpbkRvY3VtZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgICBsZXQgbm9kZSA9IGVsZW1lbnQ7XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gQm9vbGVhbihub2RlKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgR2F1Z2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCB0aGVtZVNlcnZpY2UsIGludGxTZXJ2aWNlLCBsb2NhbGl6YXRpb25TZXJ2aWNlLCBlbGVtZW50LCByZW5kZXJlciwgbmdab25lKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy50aGVtZVNlcnZpY2UgPSB0aGVtZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuaW50bFNlcnZpY2UgPSBpbnRsU2VydmljZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlID0gbG9jYWxpemF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0aGUgR2F1Z2UgcmVzaXplcyBwZXIgc2Vjb25kLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgMTBgLiBUbyBkaXNhYmxlIHRoZSBhdXRvbWF0aWMgcmVzaXppbmcsIHNldCBgcmVzaXplUmF0ZUxpbWl0YCB0byBgMGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2l6ZVJhdGVMaW1pdCA9IDEwO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRydWU7XG4gICAgICAgIHRoaXMudGhlbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnJ0bCA9IGZhbHNlO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHRoaXMuaW50bFNlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5pbnRsQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLnJ0bENoYW5nZS5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdXBkYXRlTWV0aG9kO1xuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZU1ldGhvZCA9IHRoaXMuaW5pdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLmhhc0NoYW5nZXMpIHtcbiAgICAgICAgICAgIHVwZGF0ZU1ldGhvZCA9IHRoaXMudXBkYXRlT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLnZhbHVlQ2hhbmdlKSB7XG4gICAgICAgICAgICB1cGRhdGVNZXRob2QgPSB0aGlzLnNldFZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlTWV0aG9kKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWRyYXdUaW1lb3V0KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnN0YW5jZSAmJiAhaW5Eb2N1bWVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkpIHsgLy8gcmVxdWlyZWQgaW4gY2FzZSB0aGUgZ2F1Z2UgaXMgaW5pdGlhbGl6ZWQgYnkgbmctY29udGVudCBvdXRzaWRlIG9mIHRoZSBET01cbiAgICAgICAgICAgICAgICB0aGlzLmRlZmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWxsKHVwZGF0ZU1ldGhvZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhbGwodXBkYXRlTWV0aG9kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVDYWxsKHVwZGF0ZU1ldGhvZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZURpcmVjdGlvbigpO1xuICAgICAgICB1cGRhdGVNZXRob2QuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgfVxuICAgIHVwZGF0ZU9wdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0T3B0aW9ucyh0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLnJlYWQoKSk7XG4gICAgfVxuICAgIHNldFZhbHVlcygpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5hbGxWYWx1ZXModGhpcy5jb25maWd1cmF0aW9uU2VydmljZS5yZWFkVmFsdWVzKCkpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UuY29weUNoYW5nZXMoJycsIGNoYW5nZXMpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWRyYXdUaW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgR2F1Z2UgYXMgYW4gaW1hZ2UuIFRoZSBleHBvcnQgb3BlcmF0aW9uIGlzIGFzeW5jaHJvbm91cyBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ltYWdlRXhwb3J0T3B0aW9uc30gb3B0aW9ucyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZXhwb3J0ZWQgaW1hZ2UuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggYSBQTkcgaW1hZ2UgdGhhdCBpcyBlbmNvZGVkIGFzIGEgRGF0YSBVUkkuXG4gICAgICovXG4gICAgZXhwb3J0SW1hZ2Uob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cG9ydFZpc3VhbCgpLnRoZW4oKHZpc3VhbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydEltYWdlKHZpc3VhbCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIHRoZSBHYXVnZSBhcyBhbiBTVkcgZG9jdW1lbnQuIFRoZSBleHBvcnQgb3BlcmF0aW9uIGlzIGFzeW5jaHJvbm91cyBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NWR0V4cG9ydE9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGV4cG9ydGVkIGZpbGUuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggYW4gU1ZHIGRvY3VtZW50IHRoYXQgaXMgZW5jb2RlZCBhcyBhIERhdGEgVVJJLlxuICAgICAqL1xuICAgIGV4cG9ydFNWRyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0VmlzdWFsKCkudGhlbigodmlzdWFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0U1ZHKHZpc3VhbCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIHRoZSBHYXVnZSBhcyBhIERyYXdpbmcgYFNjZW5lYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdyb3VwPn0gLSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIGV4cG9ydCB2aXN1YWwuXG4gICAgICovXG4gICAgZXhwb3J0VmlzdWFsKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuaW5zdGFuY2UuZXhwb3J0VmlzdWFsKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25SZXNpemUoX2V2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9SZXNpemUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyIGFuZCByZWRyYXdzIHRoZSBHYXVnZS5cbiAgICAgKiBSZXNpemluZyBpcyBhdXRvbWF0aWMgdW5sZXNzIHlvdSBzZXQgdGhlIGByZXNpemVSYXRlTGltaXRgIG9wdGlvbiB0byBgMGAuXG4gICAgICovXG4gICAgcmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5yZXNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuc3VyZmFjZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWF0ZUluc3RhbmNlKHRoaXMuc3VyZmFjZUVsZW1lbnQubmF0aXZlRWxlbWVudCwgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZS5yZWFkKCksIHRoaXMudGhlbWVTZXJ2aWNlLnJlYWQoKSwge1xuICAgICAgICAgICAgaW50bFNlcnZpY2U6IHRoaXMuaW50bFNlcnZpY2UsXG4gICAgICAgICAgICBydGw6IHRoaXMucnRsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgYXV0b1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplUmF0ZUxpbWl0ID4gMDtcbiAgICB9XG4gICAgdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgdGhpcy5yZXNpemVTZW5zb3IuYWNjZXB0U2l6ZSgpO1xuICAgIH1cbiAgICBpbnRsQ2hhbmdlKCkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZFJlZHJhdygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJ0bENoYW5nZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5ydGwgIT09IHRoaXMuaXNSVEwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWRSZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWZlcnJlZFJlZHJhdygpIHtcbiAgICAgICAgdGhpcy5kZWZlcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURpcmVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5ub1RyYW5zaXRpb25zUmVkcmF3KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWZlcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWRyYXdUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMucmVkcmF3VGltZW91dCA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlRGlyZWN0aW9uKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5pc1JUTDtcbiAgICAgICAgaWYgKHRoaXMucnRsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldERpcmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldERpcmVjdGlvbihjdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXREaXJlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucnRsID0gdGhpcy5pc1JUTDtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdkaXInLCB0aGlzLnJ0bCA/ICdydGwnIDogJ2x0cicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc1JUTCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLnJ0bCk7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcImdhdWdlQXJlYVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInJlbmRlckFzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicmVzaXplUmF0ZUxpbWl0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidHJhbnNpdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnc3VyZmFjZScsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInN1cmZhY2VFbGVtZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoUmVzaXplU2Vuc29yQ29tcG9uZW50LCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUmVzaXplU2Vuc29yQ29tcG9uZW50KVxuXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInJlc2l6ZVNlbnNvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstZ2F1Z2UnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjbGFzc05hbWVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZS5jb3B5Q2hhbmdlcyh0aGlzLmtleSwgY2hhbmdlcyk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLnNldCh0aGlzLmtleSwgbnVsbCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgR2F1Z2VBcmVhQ29tcG9uZW50IGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgR2F1Z2VBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBHYXVnZUFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgR2F1Z2VBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEdhdWdlQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBHYXVnZUFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBMYWJlbHNDb21wb25lbnQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIExhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGFiZWxzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIExhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIExhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUmFuZ2VDb21wb25lbnQgZXh0ZW5kcyBDb2xsZWN0aW9uSXRlbUNvbXBvbmVudCB7XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBSYW5nZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZnJvbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgUmFuZ2VDb21wb25lbnQucHJvdG90eXBlLCBcInRvXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBSYW5nZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUmFuZ2VDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTY2FsZUNvbXBvbmVudCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNjYWxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNjYWxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYWpvclRpY2tzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTY2FsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWlub3JUaWNrc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2NhbGVDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2NhbGVDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2NhbGVDb21wb25lbnQucHJvdG90eXBlLCBcIm1pbm9yVW5pdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2NhbGVDb21wb25lbnQucHJvdG90eXBlLCBcIm1ham9yVW5pdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNjYWxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZXZlcnNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTY2FsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicmFuZ2VTaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTY2FsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicmFuZ2VQbGFjZWhvbGRlckNvbG9yXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBzZWxlY3RzIGEgW3RlbXBsYXRlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyd0ZW1wbGF0ZXN5bnRheCddIH19KVxuICogd2l0aGluIHRoZSBgPGtlbmRvLWFyY2dhdWdlPmAgY29tcG9uZW50IHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgdGhlIGNlbnRlciB0ZW1wbGF0ZVxuICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIGNlbnRlcnRlbXBsYXRlX2FyY2dhdWdlICV9KSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgIDxrZW5kby1hcmNnYXVnZSBbdmFsdWVdPVwidmFsdWVcIj5cbiAqICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0FyY0dhdWdlQ2VudGVyVGVtcGxhdGUgbGV0LXZhbHVlPVwidmFsdWVcIj5cbiAqICAgICAgICAgICAgICAgICB7eyB2YWx1ZSB9fSVcbiAqICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgIDwva2VuZG8tYXJjZ2F1Z2U+XG4gKlxuICogICAgIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIHZhbHVlOiBudW1iZXIgPSAxMDtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IEFyY0NlbnRlclRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgQXJjQ2VudGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuQXJjQ2VudGVyVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0FyY0dhdWdlQ2VudGVyVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBBcmNDZW50ZXJUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qIHRzbGludDpkaXNhYmxlOnVzZS1saWZlLWN5Y2xlLWludGVyZmFjZSAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgQXJjR2F1Z2UgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X2FyY2dhdWdlX2dhdWdlcyAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICAgPGtlbmRvLWFyY2dhdWdlIFt2YWx1ZV09XCJ2YWx1ZVwiIFtzY2FsZV09XCJ7IG1heDogMTAwIH1cIj5cbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0FyY0dhdWdlQ2VudGVyVGVtcGxhdGUgbGV0LXZhbHVlPVwidmFsdWVcIj5cbiAqICAgICAgICAgICAgICB7eyB2YWx1ZSB9fSVcbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgIDwva2VuZG8tYXJjZ2F1Z2U+XG4gKiAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBwdWJsaWMgdmFsdWU6IG51bWJlciA9IDEwO1xuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgQXJjR2F1Z2VDb21wb25lbnQgPSBjbGFzcyBBcmNHYXVnZUNvbXBvbmVudCBleHRlbmRzIEdhdWdlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjaGFuZ2VEZXRlY3RvciwgY29uZmlndXJhdGlvblNlcnZpY2UsIHRoZW1lU2VydmljZSwgaW50bFNlcnZpY2UsIGxvY2FsaXphdGlvblNlcnZpY2UsIGVsZW1lbnQsIHJlbmRlcmVyLCBuZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIHRoZW1lU2VydmljZSwgaW50bFNlcnZpY2UsIGxvY2FsaXphdGlvblNlcnZpY2UsIGVsZW1lbnQsIHJlbmRlcmVyLCBuZ1pvbmUpO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jZW50ZXJUZW1wbGF0ZUNvbnRleHQgPSB7fTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAgICAgc3VwZXIubmdBZnRlclZpZXdDaGVja2VkKCk7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsRWxlbWVudCAmJiAhdGhpcy5jZW50ZXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMubGFiZWxFbGVtZW50ICYmIHRoaXMuY2VudGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2VudGVyVGVtcGxhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIHRoZSBBcmNHYXVnZSBhcyBhIERyYXdpbmcgYFNjZW5lYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEdyb3VwPn0gLSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIGV4cG9ydCB2aXN1YWwuXG4gICAgICovXG4gICAgZXhwb3J0VmlzdWFsKCkge1xuICAgICAgICByZXR1cm4gZHJhd0RPTSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVjdHMgdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lciBhbmQgcmVkcmF3cyB0aGUgR2F1Z2UuXG4gICAgICogUmVzaXppbmcgaXMgYXV0b21hdGljIHVubGVzcyB5b3Ugc2V0IHRoZSBgcmVzaXplUmF0ZUxpbWl0YCBvcHRpb24gdG8gYDBgLlxuICAgICAqL1xuICAgIHJlc2l6ZSgpIHtcbiAgICAgICAgc3VwZXIucmVzaXplKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ2VudGVyVGVtcGxhdGUoKTtcbiAgICB9XG4gICAgY3JlYXRlSW5zdGFuY2UoZWxlbWVudCwgb3B0aW9ucywgdGhlbWUsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBBcmNHYXVnZShlbGVtZW50LCBvcHRpb25zLCB0aGVtZSwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMoKTtcbiAgICB9XG4gICAgdXBkYXRlT3B0aW9ucygpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlT3B0aW9ucygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKCk7XG4gICAgfVxuICAgIHNldFZhbHVlcygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLnJlYWRWYWx1ZSgpO1xuICAgICAgICB0aGlzLmluc3RhbmNlLnZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy51cGRhdGVDZW50ZXJUZW1wbGF0ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVFbGVtZW50cygpIHtcbiAgICAgICAgdGhpcy5yZXNpemVTZW5zb3IuYWNjZXB0U2l6ZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNlbnRlclRlbXBsYXRlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUNlbnRlclRlbXBsYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2UgfHwgIXRoaXMuY2VudGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNlbnRlclRlbXBsYXRlQ29udGV4dC52YWx1ZSA9IHRoaXMuaW5zdGFuY2UudmFsdWUoKTtcbiAgICAgICAgdGhpcy5jZW50ZXJUZW1wbGF0ZUNvbnRleHQuY29sb3IgPSB0aGlzLmluc3RhbmNlLmN1cnJlbnRDb2xvcigpO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkxhYmVsKCk7XG4gICAgfVxuICAgIHBvc2l0aW9uTGFiZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5sYWJlbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5sYWJlbEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmluc3RhbmNlLmNlbnRlckxhYmVsUG9zaXRpb24od2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gYCR7cG9zaXRpb24udG9wfXB4YDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7cG9zaXRpb24ubGVmdH1weGA7XG4gICAgfVxuICAgIC8vdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1lbXB0eVxuICAgIHVwZGF0ZVNpemUoKSB7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEFyY0dhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQXJjR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIEFyY0dhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEFyY0dhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBcmNHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChBcmNDZW50ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcmNDZW50ZXJUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIEFyY0dhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjZW50ZXJUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKFwibGFiZWxcIiwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgQXJjR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsRWxlbWVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstYXJjZ2F1Z2UnKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEFyY0dhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjbGFzc05hbWVcIiwgdm9pZCAwKTtcbkFyY0dhdWdlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9BcmNHYXVnZScsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uYXJjZ2F1Z2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tYXJjZ2F1Z2UnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgI3N1cmZhY2UgY2xhc3M9J2stY2hhcnQtc3VyZmFjZSc+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstYXJjZ2F1Z2UtbGFiZWxcIiAqbmdJZj1cImNlbnRlclRlbXBsYXRlXCIgI2xhYmVsPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwiY2VudGVyVGVtcGxhdGUudGVtcGxhdGVSZWZcIiBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwiY2VudGVyVGVtcGxhdGVDb250ZXh0XCI+PC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cbiAgICA8a2VuZG8tcmVzaXplLXNlbnNvciAocmVzaXplKT1cIm9uUmVzaXplKCRldmVudClcIiBbcmF0ZUxpbWl0XT1cInJlc2l6ZVJhdGVMaW1pdFwiPjwva2VuZG8tcmVzaXplLXNlbnNvcj5cbiAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIENvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBUaGVtZVNlcnZpY2UsXG4gICAgICAgIEludGxTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBBcmNHYXVnZUNvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGUgQXJjR2F1Z2UgYXJlYS5cbiAqIFJlcHJlc2VudHMgdGhlIGVudGlyZSB2aXNpYmxlIGFyZWEgb2YgdGhlIEFyY0dhdWdlLlxuICovXG5sZXQgQXJjR2F1Z2VBcmVhQ29tcG9uZW50ID0gY2xhc3MgQXJjR2F1Z2VBcmVhQ29tcG9uZW50IGV4dGVuZHMgR2F1Z2VBcmVhQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignZ2F1Z2VBcmVhJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbkFyY0dhdWdlQXJlYUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tYXJjZ2F1Z2UtYXJlYScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgQXJjR2F1Z2VBcmVhQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgc2NhbGUgb2YgdGhlIEFyY0dhdWdlXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNjYWxlb3B0aW9uc19hcmNnYXVnZSAlfSkpLlxuICovXG5sZXQgQXJjU2NhbGVDb21wb25lbnQgPSBjbGFzcyBBcmNTY2FsZUNvbXBvbmVudCBleHRlbmRzIFNjYWxlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignc2NhbGUnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXJjU2NhbGVDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQXJjU2NhbGVDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlRGlzdGFuY2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEFyY1NjYWxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYW5nZUxpbmVDYXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEFyY1NjYWxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBBcmNTY2FsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZW5kQW5nbGVcIiwgdm9pZCAwKTtcbkFyY1NjYWxlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1hcmNnYXVnZS1zY2FsZScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgQXJjU2NhbGVDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBzY2FsZSBsYWJlbHMgb2YgdGhlIFJhZGlhbEdhdWdlLlxuICovXG5sZXQgUmFkaWFsTGFiZWxzQ29tcG9uZW50ID0gY2xhc3MgUmFkaWFsTGFiZWxzQ29tcG9uZW50IGV4dGVuZHMgTGFiZWxzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignc2NhbGUubGFiZWxzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFJhZGlhbExhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcblJhZGlhbExhYmVsc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tcmFkaWFsZ2F1Z2Utc2NhbGUtbGFiZWxzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBSYWRpYWxMYWJlbHNDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBzY2FsZSBsYWJlbHMgb2YgdGhlIEFyY0dhdWdlLlxuICovXG5sZXQgQXJjTGFiZWxzQ29tcG9uZW50ID0gY2xhc3MgQXJjTGFiZWxzQ29tcG9uZW50IGV4dGVuZHMgUmFkaWFsTGFiZWxzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgY29uZmlndXJhdGlvblNlcnZpY2Uuc2V0KGAke3RoaXMua2V5fS52aXNpYmxlYCwgdHJ1ZSk7XG4gICAgfVxufTtcbkFyY0xhYmVsc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tYXJjZ2F1Z2Utc2NhbGUtbGFiZWxzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBBcmNMYWJlbHNDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGFuIEFyY0dhdWdlIGNvbG9yIGl0ZW0uXG4gKi9cbmxldCBDb2xvckNvbXBvbmVudCA9IGNsYXNzIENvbG9yQ29tcG9uZW50IGV4dGVuZHMgQ29sbGVjdGlvbkl0ZW1Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25DaGFuZ2VzU2VydmljZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ29sb3JDb21wb25lbnQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENvbG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmcm9tXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDb2xvckNvbXBvbmVudC5wcm90b3R5cGUsIFwidG9cIiwgdm9pZCAwKTtcbkNvbG9yQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbQ29uZmlndXJhdGlvblNlcnZpY2VdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWFyY2dhdWdlLWNvbG9yJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvbkNoYW5nZXNTZXJ2aWNlXSlcbl0sIENvbG9yQ29tcG9uZW50KTtcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2Ygb25lIG9yIG1vcmUgQXJjR2F1Z2UgY29sb3JzXG4gKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgY29sb3JyYW5nZXNfYXJjZ2F1Z2UgJX0pKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgPGtlbmRvLWFyY2dhdWdlIFt2YWx1ZV09XCJ2YWx1ZVwiPlxuICogICAgICAgICAgICAgIDxrZW5kby1hcmNnYXVnZS1jb2xvcnM+XG4gKiAgICAgICAgICAgICAgICAgIDxrZW5kby1hcmNnYXVnZS1jb2xvciAqbmdGb3I9XCJsZXQgaXRlbSBvZiBjb2xvcnNcIlxuICogICAgICAgICAgICAgICAgICAgICAgW2Zyb21dPVwiaXRlbS5mcm9tXCIgW3RvXT1cIml0ZW0udG9cIiBbY29sb3JdPVwiaXRlbS5jb2xvclwiPlxuICogICAgICAgICAgICAgICAgICA8L2tlbmRvLWFyY2dhdWdlLWNvbG9yPlxuICogICAgICAgICAgICAgIDwva2VuZG8tYXJjZ2F1Z2UtY29sb3JzPlxuICogICAgICAgICA8L2tlbmRvLWFyY2dhdWdlPlxuICogICAgIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgICBwdWJsaWMgdmFsdWU6IG51bWJlciA9IDEwO1xuICpcbiAqICAgICBwdWJsaWMgY29sb3JzOiBhbnlbXSA9IFt7XG4gKiAgICAgICAgIHRvOiAyNSxcbiAqICAgICAgICAgY29sb3I6ICcjMDA1OGU5J1xuICogICAgIH0sIHtcbiAqICAgICAgICAgZnJvbTogMjUsXG4gKiAgICAgICAgIHRvOiA1MCxcbiAqICAgICAgICAgY29sb3I6ICcjMzdiNDAwJ1xuICogICAgIH0sIHtcbiAqICAgICAgICAgZnJvbTogNTAsXG4gKiAgICAgICAgIHRvOiA3NSxcbiAqICAgICAgICAgY29sb3I6ICcjZmZjMDAwJ1xuICogICAgIH0sIHtcbiAqICAgICAgICAgZnJvbTogNzUsXG4gKiAgICAgICAgIGNvbG9yOiAnI2YzMTcwMCdcbiAqICAgICB9XTtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IENvbG9yc0NvbXBvbmVudCA9IGNsYXNzIENvbG9yc0NvbXBvbmVudCBleHRlbmRzIENvbGxlY3Rpb25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2NvbG9ycycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oQ29sb3JDb21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBDb2xvcnNDb21wb25lbnQucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHZvaWQgMCk7XG5Db2xvcnNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtDb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2VdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWFyY2dhdWdlLWNvbG9ycycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIENvbGxlY3Rpb25DaGFuZ2VzU2VydmljZV0pXG5dLCBDb2xvcnNDb21wb25lbnQpO1xuXG5jb25zdCBESVJFQ1RJVkVTID0gW0FyY0dhdWdlQ29tcG9uZW50LCBBcmNDZW50ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgQXJjR2F1Z2VBcmVhQ29tcG9uZW50LCBBcmNTY2FsZUNvbXBvbmVudCwgQXJjTGFiZWxzQ29tcG9uZW50LFxuICAgIENvbG9yc0NvbXBvbmVudCwgQ29sb3JDb21wb25lbnRdO1xuLyoqXG4gKiBBIFttb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlcyddIH19KSB0aGF0IGluY2x1ZGVzIHRoZSBBcmNHYXVnZSBjb21wb25lbnQgYW5kIGl0cyBkaXJlY3RpdmVzLlxuICogSW1wb3J0cyB0aGUgYEFyY0dhdWdlTW9kdWxlYCBpbnRvIHlvdXIgYXBwbGljYXRpb25cbiAqIFtyb290IG1vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVzJ10gfX0jYW5ndWxhci1tb2R1bGFyaXR5KSBvciBhbnkgb3RoZXIgc3ViLW1vZHVsZVxuICogdGhhdCB3aWxsIHVzZSB0aGUgQXJjR2F1Z2UgY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1uby1ydW5cbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQgeyBCcm93c2VyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG4gKiBpbXBvcnQgeyBBcmNHYXVnZU1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWdhdWdlcyc7XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF0sXG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSxcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBBcmNHYXVnZU1vZHVsZV1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgQXJjR2F1Z2VNb2R1bGUgPSBjbGFzcyBBcmNHYXVnZU1vZHVsZSB7XG59O1xuQXJjR2F1Z2VNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW0RJUkVDVElWRVNdLFxuICAgICAgICBleHBvcnRzOiBbRElSRUNUSVZFU10sXG4gICAgICAgIGltcG9ydHM6IFtTaGFyZWRNb2R1bGUsIENvbW1vbk1vZHVsZV1cbiAgICB9KVxuXSwgQXJjR2F1Z2VNb2R1bGUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBMaW5lYXJHYXVnZSBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfbGluZWFyZ2F1Z2VfZ2F1Z2VzICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgICA8a2VuZG8tbGluZWFyZ2F1Z2UgW3BvaW50ZXJdPVwieyB2YWx1ZTogdmFsdWUgfVwiPlxuICogICAgICA8L2tlbmRvLWxpbmVhcmdhdWdlPlxuICogICBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIHZhbHVlOiBudW1iZXIgPSAxMDtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IExpbmVhckdhdWdlQ29tcG9uZW50ID0gY2xhc3MgTGluZWFyR2F1Z2VDb21wb25lbnQgZXh0ZW5kcyBHYXVnZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIHRoZW1lU2VydmljZSwgaW50bFNlcnZpY2UsIGxvY2FsaXphdGlvblNlcnZpY2UsIGVsZW1lbnQsIHJlbmRlcmVyLCBuZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIHRoZW1lU2VydmljZSwgaW50bFNlcnZpY2UsIGxvY2FsaXphdGlvblNlcnZpY2UsIGVsZW1lbnQsIHJlbmRlcmVyLCBuZ1pvbmUpO1xuICAgIH1cbiAgICBjcmVhdGVJbnN0YW5jZShlbGVtZW50LCBvcHRpb25zLCB0aGVtZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IExpbmVhckdhdWdlKGVsZW1lbnQsIG9wdGlvbnMsIHRoZW1lLCBjb250ZXh0KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInBvaW50ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2FsZVwiLCB2b2lkIDApO1xuTGluZWFyR2F1Z2VDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kb0xpbmVhckdhdWdlJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5saW5lYXJnYXVnZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1saW5lYXJnYXVnZScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGRpdiAjc3VyZmFjZSBjbGFzcz0nay1jaGFydC1zdXJmYWNlJz48L2Rpdj5cbiAgICA8a2VuZG8tcmVzaXplLXNlbnNvciAocmVzaXplKT1cIm9uUmVzaXplKCRldmVudClcIiBbcmF0ZUxpbWl0XT1cInJlc2l6ZVJhdGVMaW1pdFwiPjwva2VuZG8tcmVzaXplLXNlbnNvcj5cbiAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIFRoZW1lU2VydmljZSxcbiAgICAgICAgSW50bFNlcnZpY2UsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMixcbiAgICAgICAgTmdab25lXSlcbl0sIExpbmVhckdhdWdlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgTGluZWFyR2F1Z2UgYXJlYS5cbiAqIFJlcHJlc2VudHMgdGhlIGVudGlyZSB2aXNpYmxlIGFyZWEgb2YgdGhlIExpbmVhckdhdWdlLlxuICovXG5sZXQgTGluZWFyR2F1Z2VBcmVhQ29tcG9uZW50ID0gY2xhc3MgTGluZWFyR2F1Z2VBcmVhQ29tcG9uZW50IGV4dGVuZHMgR2F1Z2VBcmVhQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignZ2F1Z2VBcmVhJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbkxpbmVhckdhdWdlQXJlYUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tbGluZWFyZ2F1Z2UtYXJlYScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTGluZWFyR2F1Z2VBcmVhQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgc2NhbGUgb2YgdGhlIExpbmVhckdhdWdlXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNjYWxlb3B0aW9uc19saW5lYXJnYXVnZSAlfSkpLlxuICovXG5sZXQgTGluZWFyU2NhbGVDb21wb25lbnQgPSBjbGFzcyBMaW5lYXJTY2FsZUNvbXBvbmVudCBleHRlbmRzIFNjYWxlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignc2NhbGUnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGluZWFyU2NhbGVDb21wb25lbnQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgTGluZWFyU2NhbGVDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIExpbmVhclNjYWxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaXJyb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBMaW5lYXJTY2FsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidmVydGljYWxcIiwgdm9pZCAwKTtcbkxpbmVhclNjYWxlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1saW5lYXJnYXVnZS1zY2FsZScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTGluZWFyU2NhbGVDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBzY2FsZSBsYWJlbHMgb2YgdGhlIExpbmVhckdhdWdlLlxuICovXG5sZXQgTGluZWFyTGFiZWxzQ29tcG9uZW50ID0gY2xhc3MgTGluZWFyTGFiZWxzQ29tcG9uZW50IGV4dGVuZHMgTGFiZWxzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignc2NhbGUubGFiZWxzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbkxpbmVhckxhYmVsc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tbGluZWFyZ2F1Z2Utc2NhbGUtbGFiZWxzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBMaW5lYXJMYWJlbHNDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGEgcG9pbnRlciBpdGVtIG9mIGEgTGluZWFyR2F1Z2UuXG4gKi9cbmxldCBMaW5lYXJQb2ludGVyQ29tcG9uZW50ID0gY2xhc3MgTGluZWFyUG9pbnRlckNvbXBvbmVudCBleHRlbmRzIENvbGxlY3Rpb25JdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvbkNoYW5nZXNTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBMaW5lYXJQb2ludGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIExpbmVhclBvaW50ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBMaW5lYXJQb2ludGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIExpbmVhclBvaW50ZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIExpbmVhclBvaW50ZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNoYXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBMaW5lYXJQb2ludGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBMaW5lYXJQb2ludGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuTGluZWFyUG9pbnRlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1saW5lYXJnYXVnZS1wb2ludGVyJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvbkNoYW5nZXNTZXJ2aWNlXSlcbl0sIExpbmVhclBvaW50ZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBvbmUgb3IgbW9yZSBMaW5lYXJHYXVnZSBwb2ludGVyc1xuICogKFttb3JlIGluZm9ybWF0aW9uXSh7JSBzbHVnIG11bHRpcGxlcG9pbnRlcnNfbGluZWFyZ2F1Z2UgJX0pKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgPGtlbmRvLWxpbmVhcmdhdWdlPlxuICogICAgICAgICAgICAgPGtlbmRvLWxpbmVhcmdhdWdlLXBvaW50ZXJzPlxuICogICAgICAgICAgICAgICAgIDxrZW5kby1saW5lYXJnYXVnZS1wb2ludGVyICpuZ0Zvcj1cImxldCBwb2ludGVyIG9mIHBvaW50ZXJzXCJcbiAqICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT1cInBvaW50ZXIudmFsdWVcIiBbY29sb3JdPVwicG9pbnRlci5jb2xvclwiIHNoYXBlPVwiYmFySW5kaWNhdG9yXCI+XG4gKiAgICAgICAgICAgICAgICAgPC9rZW5kby1saW5lYXJnYXVnZS1wb2ludGVyPlxuICogICAgICAgICAgICAgPC9rZW5kby1saW5lYXJnYXVnZS1wb2ludGVycz5cbiAqICAgICAgICAgPC9rZW5kby1saW5lYXJnYXVnZT5cbiAqICAgICBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICAgcHVibGljIHBvaW50ZXJzOiBhbnlbXSA9IFt7XG4gKiAgICAgICAgIHZhbHVlOiAxMCxcbiAqICAgICAgICAgY29sb3I6ICcjZmY0NTAwJ1xuICogICAgIH0sIHtcbiAqICAgICAgICAgdmFsdWU6IDEyLFxuICogICAgICAgICBjb2xvcjogJyMyOGI0YzgnXG4gKiAgICAgfSwge1xuICogICAgICAgICB2YWx1ZTogMjAsXG4gKiAgICAgICAgIGNvbG9yOiAnIzhiMDAwMCdcbiAqICAgICB9XTtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IExpbmVhclBvaW50ZXJzQ29tcG9uZW50ID0gY2xhc3MgTGluZWFyUG9pbnRlcnNDb21wb25lbnQgZXh0ZW5kcyBDb2xsZWN0aW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvbkNoYW5nZXNTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdwb2ludGVyJywgY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25DaGFuZ2VzU2VydmljZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihMaW5lYXJQb2ludGVyQ29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgTGluZWFyUG9pbnRlcnNDb21wb25lbnQucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHZvaWQgMCk7XG5MaW5lYXJQb2ludGVyc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW0NvbGxlY3Rpb25DaGFuZ2VzU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tbGluZWFyZ2F1Z2UtcG9pbnRlcnMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2VdKVxuXSwgTGluZWFyUG9pbnRlcnNDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGEgc2NhbGUgcmFuZ2UgaXRlbSBvZiBhIExpbmVhckdhdWdlLlxuICovXG5sZXQgTGluZWFyUmFuZ2VDb21wb25lbnQgPSBjbGFzcyBMaW5lYXJSYW5nZUNvbXBvbmVudCBleHRlbmRzIFJhbmdlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvbkNoYW5nZXNTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UpO1xuICAgIH1cbn07XG5MaW5lYXJSYW5nZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1saW5lYXJnYXVnZS1zY2FsZS1yYW5nZScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIENvbGxlY3Rpb25DaGFuZ2VzU2VydmljZV0pXG5dLCBMaW5lYXJSYW5nZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIG9uZSBvciBtb3JlIExpbmVhckdhdWdlIHNjYWxlIHJhbmdlc1xuICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIHNjYWxlcmFuZ2hlc19saW5lYXJnYXVnZSAlfSkpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICA8a2VuZG8tbGluZWFyZ2F1Z2U+XG4gKiAgICAgICAgICAgICA8a2VuZG8tbGluZWFyZ2F1Z2Utc2NhbGU+XG4gKiAgICAgICAgICAgICAgICAgPGtlbmRvLWxpbmVhcmdhdWdlLXNjYWxlLXJhbmdlcz5cbiAqICAgICAgICAgICAgICAgICAgICAgPGtlbmRvLWxpbmVhcmdhdWdlLXNjYWxlLXJhbmdlICpuZ0Zvcj1cImxldCByYW5nZSBvZiByYW5nZXNcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgW2Zyb21dPVwicmFuZ2UuZnJvbVwiIFt0b109XCJyYW5nZS50b1wiIFtjb2xvcl09XCJyYW5nZS5jb2xvclwiPlxuICogICAgICAgICAgICAgICAgICAgICA8L2tlbmRvLWxpbmVhcmdhdWdlLXNjYWxlLXJhbmdlPlxuICogICAgICAgICAgICAgICAgIDwva2VuZG8tbGluZWFyZ2F1Z2Utc2NhbGUtcmFuZ2VzPlxuICogICAgICAgICAgICAgPC9rZW5kby1saW5lYXJnYXVnZS1zY2FsZT5cbiAqICAgICAgICAgPC9rZW5kby1saW5lYXJnYXVnZT5cbiAqICAgICBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICAgcHVibGljIHJhbmdlczogYW55W10gPSBbe1xuICogICAgICAgICBmcm9tOiAwLFxuICogICAgICAgICB0bzogMTUsXG4gKiAgICAgICAgIGNvbG9yOiAnI2ZmZDI0NidcbiAqICAgICB9LCB7XG4gKiAgICAgICAgIGZyb206IDE1LFxuICogICAgICAgICB0bzogMzAsXG4gKiAgICAgICAgIGNvbG9yOiAnIzI4YjRjOCdcbiAqICAgICB9LCB7XG4gKiAgICAgICAgIGZyb206IDMwLFxuICogICAgICAgICB0bzogNTAsXG4gKiAgICAgICAgIGNvbG9yOiAnIzc4ZDIzNydcbiAqICAgICB9XTtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IExpbmVhclJhbmdlc0NvbXBvbmVudCA9IGNsYXNzIExpbmVhclJhbmdlc0NvbXBvbmVudCBleHRlbmRzIENvbGxlY3Rpb25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3NjYWxlLnJhbmdlcycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oTGluZWFyUmFuZ2VDb21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBMaW5lYXJSYW5nZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHZvaWQgMCk7XG5MaW5lYXJSYW5nZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtDb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2VdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWxpbmVhcmdhdWdlLXNjYWxlLXJhbmdlcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIENvbGxlY3Rpb25DaGFuZ2VzU2VydmljZV0pXG5dLCBMaW5lYXJSYW5nZXNDb21wb25lbnQpO1xuXG5jb25zdCBESVJFQ1RJVkVTJDEgPSBbTGluZWFyR2F1Z2VDb21wb25lbnQsIExpbmVhckdhdWdlQXJlYUNvbXBvbmVudCwgTGluZWFyU2NhbGVDb21wb25lbnQsIExpbmVhckxhYmVsc0NvbXBvbmVudCxcbiAgICBMaW5lYXJQb2ludGVyc0NvbXBvbmVudCwgTGluZWFyUG9pbnRlckNvbXBvbmVudCwgTGluZWFyUmFuZ2VDb21wb25lbnQsIExpbmVhclJhbmdlc0NvbXBvbmVudF07XG4vKipcbiAqIEEgW21vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVzJ10gfX0pIHRoYXQgaW5jbHVkZXMgdGhlIExpbmVhckdhdWdlIGNvbXBvbmVudCBhbmQgaXRzIGRpcmVjdGl2ZXMuXG4gKiBJbXBvcnRzIHRoZSBgTGluZWFyR2F1Z2VNb2R1bGVgIGludG8geW91ciBhcHBsaWNhdGlvblxuICogW3Jvb3QgbW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZXMnXSB9fSNhbmd1bGFyLW1vZHVsYXJpdHkpIG9yIGFueSBvdGhlciBzdWItbW9kdWxlXG4gKiB0aGF0IHdpbGwgdXNlIHRoZSBMaW5lYXJHYXVnZSBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IEJyb3dzZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbiAqIGltcG9ydCB7IExpbmVhckdhdWdlTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZ2F1Z2VzJztcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XSxcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIExpbmVhckdhdWdlTW9kdWxlXVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge1xuICogfVxuICogYGBgXG4gKi9cbmxldCBMaW5lYXJHYXVnZU1vZHVsZSA9IGNsYXNzIExpbmVhckdhdWdlTW9kdWxlIHtcbn07XG5MaW5lYXJHYXVnZU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbRElSRUNUSVZFUyQxXSxcbiAgICAgICAgZXhwb3J0czogW0RJUkVDVElWRVMkMV0sXG4gICAgICAgIGltcG9ydHM6IFtTaGFyZWRNb2R1bGVdXG4gICAgfSlcbl0sIExpbmVhckdhdWdlTW9kdWxlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgUmFkaWFsR2F1Z2UgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3JhZGlhbGdhdWdlX2dhdWdlcyAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICAgPGtlbmRvLXJhZGlhbGdhdWdlIFtwb2ludGVyXT1cInsgdmFsdWU6IHZhbHVlIH1cIj5cbiAqICAgICAgPC9rZW5kby1yYWRpYWxnYXVnZT5cbiAqICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyB2YWx1ZTogbnVtYmVyID0gMTA7XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBSYWRpYWxHYXVnZUNvbXBvbmVudCA9IGNsYXNzIFJhZGlhbEdhdWdlQ29tcG9uZW50IGV4dGVuZHMgR2F1Z2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCB0aGVtZVNlcnZpY2UsIGludGxTZXJ2aWNlLCBsb2NhbGl6YXRpb25TZXJ2aWNlLCBlbGVtZW50LCByZW5kZXJlciwgbmdab25lKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCB0aGVtZVNlcnZpY2UsIGludGxTZXJ2aWNlLCBsb2NhbGl6YXRpb25TZXJ2aWNlLCBlbGVtZW50LCByZW5kZXJlciwgbmdab25lKTtcbiAgICB9XG4gICAgY3JlYXRlSW5zdGFuY2UoZWxlbWVudCwgb3B0aW9ucywgdGhlbWUsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBSYWRpYWxHYXVnZShlbGVtZW50LCBvcHRpb25zLCB0aGVtZSwgY29udGV4dCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFJhZGlhbEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb2ludGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBSYWRpYWxHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVcIiwgdm9pZCAwKTtcblJhZGlhbEdhdWdlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9SYWRpYWxHYXVnZScsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8ucmFkaWFsZ2F1Z2UnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tcmFkaWFsZ2F1Z2UnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgI3N1cmZhY2UgY2xhc3M9J2stY2hhcnQtc3VyZmFjZSc+PC9kaXY+XG4gICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3IgKHJlc2l6ZSk9XCJvblJlc2l6ZSgkZXZlbnQpXCIgW3JhdGVMaW1pdF09XCJyZXNpemVSYXRlTGltaXRcIj48L2tlbmRvLXJlc2l6ZS1zZW5zb3I+XG4gIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBUaGVtZVNlcnZpY2UsXG4gICAgICAgIEludGxTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBSYWRpYWxHYXVnZUNvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIFJhZGlhbEdhdWdlIGFyZWEuXG4gKiBSZXByZXNlbnRzIHRoZSBlbnRpcmUgdmlzaWJsZSBhcmVhIG9mIHRoZSBSYWRpYWxHYXVnZS5cbiAqL1xubGV0IFJhZGlhbEdhdWdlQXJlYUNvbXBvbmVudCA9IGNsYXNzIFJhZGlhbEdhdWdlQXJlYUNvbXBvbmVudCBleHRlbmRzIEdhdWdlQXJlYUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2dhdWdlQXJlYScsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5SYWRpYWxHYXVnZUFyZWFDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXJhZGlhbGdhdWdlLWFyZWEnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFJhZGlhbEdhdWdlQXJlYUNvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHNjYWxlIG9mIHRoZSBSYWRpYWxHYXVnZVxuICogKFttb3JlIGluZm9ybWF0aW9uIGFuZCBleGFtcGxlXSh7JSBzbHVnIHNjYWxlb3B0aW9uc19yYWRpYWxnYXVnZSAlfSkpLlxuICovXG5sZXQgUmFkaWFsU2NhbGVDb21wb25lbnQgPSBjbGFzcyBSYWRpYWxTY2FsZUNvbXBvbmVudCBleHRlbmRzIFNjYWxlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignc2NhbGUnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUmFkaWFsU2NhbGVDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgUmFkaWFsU2NhbGVDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlRGlzdGFuY2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgUmFkaWFsU2NhbGVDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgUmFkaWFsU2NhbGVDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFJhZGlhbFNjYWxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlbmRBbmdsZVwiLCB2b2lkIDApO1xuUmFkaWFsU2NhbGVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXJhZGlhbGdhdWdlLXNjYWxlJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBSYWRpYWxTY2FsZUNvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgYSBwb2ludGVyIGl0ZW0gb2YgYSBSYWRpYWxHYXVnZS5cbiAqL1xubGV0IFJhZGlhbFBvaW50ZXJDb21wb25lbnQgPSBjbGFzcyBSYWRpYWxQb2ludGVyQ29tcG9uZW50IGV4dGVuZHMgQ29sbGVjdGlvbkl0ZW1Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25DaGFuZ2VzU2VydmljZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFJhZGlhbFBvaW50ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNhcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUmFkaWFsUG9pbnRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFJhZGlhbFBvaW50ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImxlbmd0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgUmFkaWFsUG9pbnRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcblJhZGlhbFBvaW50ZXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBwcm92aWRlcnM6IFtDb25maWd1cmF0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tcmFkaWFsZ2F1Z2UtcG9pbnRlcicsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIENvbGxlY3Rpb25DaGFuZ2VzU2VydmljZV0pXG5dLCBSYWRpYWxQb2ludGVyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2Ygb25lIG9yIG1vcmUgUmFkaWFsR2F1Z2UgcG9pbnRlcnNcbiAqIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBtdWx0aXBsZXBvaW50ZXJzX3JhZGlhbGdhdWdlICV9KSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgIDxrZW5kby1yYWRpYWxnYXVnZT5cbiAqICAgICAgICAgICAgIDxrZW5kby1yYWRpYWxnYXVnZS1wb2ludGVycz5cbiAqICAgICAgICAgICAgICAgICA8a2VuZG8tcmFkaWFsZ2F1Z2UtcG9pbnRlciAqbmdGb3I9XCJsZXQgcG9pbnRlciBvZiBwb2ludGVyc1wiXG4gKiAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJwb2ludGVyLnZhbHVlXCIgW2NvbG9yXT1cInBvaW50ZXIuY29sb3JcIj5cbiAqICAgICAgICAgICAgICAgICA8L2tlbmRvLXJhZGlhbGdhdWdlLXBvaW50ZXI+XG4gKiAgICAgICAgICAgICA8L2tlbmRvLXJhZGlhbGdhdWdlLXBvaW50ZXJzPlxuICogICAgICAgICA8L2tlbmRvLXJhZGlhbGdhdWdlPlxuICogICAgIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgICBwdWJsaWMgcG9pbnRlcnM6IGFueVtdID0gW3tcbiAqICAgICAgICAgdmFsdWU6IDEwLFxuICogICAgICAgICBjb2xvcjogJyNmZmQyNDYnXG4gKiAgICAgfSwge1xuICogICAgICAgICB2YWx1ZTogMjAsXG4gKiAgICAgICAgIGNvbG9yOiAnIzI4YjRjOCdcbiAqICAgICB9LCB7XG4gKiAgICAgICAgIHZhbHVlOiAzMCxcbiAqICAgICAgICAgY29sb3I6ICcjNzhkMjM3J1xuICogICAgIH1dO1xuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgUmFkaWFsUG9pbnRlcnNDb21wb25lbnQgPSBjbGFzcyBSYWRpYWxQb2ludGVyc0NvbXBvbmVudCBleHRlbmRzIENvbGxlY3Rpb25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3BvaW50ZXInLCBjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvbkNoYW5nZXNTZXJ2aWNlKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKFJhZGlhbFBvaW50ZXJDb21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBSYWRpYWxQb2ludGVyc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwgdm9pZCAwKTtcblJhZGlhbFBvaW50ZXJzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbQ29sbGVjdGlvbkNoYW5nZXNTZXJ2aWNlXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1yYWRpYWxnYXVnZS1wb2ludGVycycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIENvbGxlY3Rpb25DaGFuZ2VzU2VydmljZV0pXG5dLCBSYWRpYWxQb2ludGVyc0NvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgYSBzY2FsZSByYW5nZSBpdGVtIG9mIGEgUmFkaWFsR2F1Z2UuXG4gKi9cbmxldCBSYWRpYWxSYW5nZUNvbXBvbmVudCA9IGNsYXNzIFJhZGlhbFJhbmdlQ29tcG9uZW50IGV4dGVuZHMgUmFuZ2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uQ2hhbmdlc1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25DaGFuZ2VzU2VydmljZSk7XG4gICAgfVxufTtcblJhZGlhbFJhbmdlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbQ29uZmlndXJhdGlvblNlcnZpY2VdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXJhZGlhbGdhdWdlLXNjYWxlLXJhbmdlJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvbkNoYW5nZXNTZXJ2aWNlXSlcbl0sIFJhZGlhbFJhbmdlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2Ygb25lIG9yIG1vcmUgUmFkaWFsR2F1Z2Ugc2NhbGUgcmFuZ2VzXG4gKiAoW21vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVdKHslIHNsdWcgc2NhbGVyYW5naGVzX3JhZGlhbGdhdWdlICV9KSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgIDxrZW5kby1yYWRpYWxnYXVnZT5cbiAqICAgICAgICAgICAgIDxrZW5kby1yYWRpYWxnYXVnZS1zY2FsZT5cbiAqICAgICAgICAgICAgICAgICA8a2VuZG8tcmFkaWFsZ2F1Z2Utc2NhbGUtcmFuZ2VzPlxuICogICAgICAgICAgICAgICAgICAgICA8a2VuZG8tcmFkaWFsZ2F1Z2Utc2NhbGUtcmFuZ2UgKm5nRm9yPVwibGV0IHJhbmdlIG9mIHJhbmdlc1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBbZnJvbV09XCJyYW5nZS5mcm9tXCIgW3RvXT1cInJhbmdlLnRvXCIgW2NvbG9yXT1cInJhbmdlLmNvbG9yXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIDwva2VuZG8tcmFkaWFsZ2F1Z2Utc2NhbGUtcmFuZ2U+XG4gKiAgICAgICAgICAgICAgICAgPC9rZW5kby1yYWRpYWxnYXVnZS1zY2FsZS1yYW5nZXM+XG4gKiAgICAgICAgICAgICA8L2tlbmRvLXJhZGlhbGdhdWdlLXNjYWxlPlxuICogICAgICAgICA8L2tlbmRvLXJhZGlhbGdhdWdlPlxuICogICAgIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgICBwdWJsaWMgcmFuZ2VzOiBhbnlbXSA9IFt7XG4gKiAgICAgICAgIGZyb206IDAsXG4gKiAgICAgICAgIHRvOiAxNSxcbiAqICAgICAgICAgY29sb3I6ICcjZmZkMjQ2J1xuICogICAgIH0sIHtcbiAqICAgICAgICAgZnJvbTogMTUsXG4gKiAgICAgICAgIHRvOiAzMCxcbiAqICAgICAgICAgY29sb3I6ICcjMjhiNGM4J1xuICogICAgIH0sIHtcbiAqICAgICAgICAgZnJvbTogMzAsXG4gKiAgICAgICAgIHRvOiA1MCxcbiAqICAgICAgICAgY29sb3I6ICcjNzhkMjM3J1xuICogICAgIH1dO1xuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgUmFkaWFsUmFuZ2VzQ29tcG9uZW50ID0gY2xhc3MgUmFkaWFsUmFuZ2VzQ29tcG9uZW50IGV4dGVuZHMgQ29sbGVjdGlvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25DaGFuZ2VzU2VydmljZSkge1xuICAgICAgICBzdXBlcignc2NhbGUucmFuZ2VzJywgY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25DaGFuZ2VzU2VydmljZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihSYWRpYWxSYW5nZUNvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFJhZGlhbFJhbmdlc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwgdm9pZCAwKTtcblJhZGlhbFJhbmdlc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW0NvbGxlY3Rpb25DaGFuZ2VzU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tcmFkaWFsZ2F1Z2Utc2NhbGUtcmFuZ2VzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvbkNoYW5nZXNTZXJ2aWNlXSlcbl0sIFJhZGlhbFJhbmdlc0NvbXBvbmVudCk7XG5cbmNvbnN0IERJUkVDVElWRVMkMiA9IFtSYWRpYWxHYXVnZUNvbXBvbmVudCwgUmFkaWFsR2F1Z2VBcmVhQ29tcG9uZW50LCBSYWRpYWxTY2FsZUNvbXBvbmVudCwgUmFkaWFsTGFiZWxzQ29tcG9uZW50LFxuICAgIFJhZGlhbFBvaW50ZXJzQ29tcG9uZW50LCBSYWRpYWxQb2ludGVyQ29tcG9uZW50LCBSYWRpYWxSYW5nZUNvbXBvbmVudCwgUmFkaWFsUmFuZ2VzQ29tcG9uZW50XTtcbi8qKlxuICogQSBbbW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZXMnXSB9fSkgdGhhdCBpbmNsdWRlcyB0aGUgUmFkaWFsR2F1Z2UgY29tcG9uZW50IGFuZCBpdHMgZGlyZWN0aXZlcy5cbiAqIEltcG9ydHMgdGhlIGBSYWRpYWxHYXVnZU1vZHVsZWAgaW50byB5b3VyIGFwcGxpY2F0aW9uXG4gKiBbcm9vdCBtb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlcyddIH19I2FuZ3VsYXItbW9kdWxhcml0eSkgb3IgYW55IG90aGVyIHN1Yi1tb2R1bGVcbiAqIHRoYXQgd2lsbCB1c2UgdGhlIFJhZGlhbEdhdWdlIGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtbm8tcnVuXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuICogaW1wb3J0IHsgUmFkaWFsR2F1Z2VNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1nYXVnZXMnO1xuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdLFxuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sXG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgUmFkaWFsR2F1Z2VNb2R1bGVdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IFJhZGlhbEdhdWdlTW9kdWxlID0gY2xhc3MgUmFkaWFsR2F1Z2VNb2R1bGUge1xufTtcblJhZGlhbEdhdWdlTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtESVJFQ1RJVkVTJDJdLFxuICAgICAgICBleHBvcnRzOiBbRElSRUNUSVZFUyQyXSxcbiAgICAgICAgaW1wb3J0czogW1NoYXJlZE1vZHVsZV1cbiAgICB9KVxuXSwgUmFkaWFsR2F1Z2VNb2R1bGUpO1xuXG4vKipcbiAqIEEgW21vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVzJ10gfX0pIHRoYXQgaW5jbHVkZXMgYWxsIEdhdWdlIGNvbXBvbmVudHMgYW5kIGRpcmVjdGl2ZXMuXG4gKlxuICogSW1wb3J0cyB0aGUgYEdhdWdlc01vZHVsZWAgaW50byB5b3VyIGFwcGxpY2F0aW9uXG4gKiBbcm9vdCBtb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlcyddIH19I2FuZ3VsYXItbW9kdWxhcml0eSkgb3IgYW55IG90aGVyIHN1Yi1tb2R1bGVcbiAqIHRoYXQgd2lsbCB1c2UgdGhlIEdhdWdlIGNvbXBvbmVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IEJyb3dzZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbiAqIGltcG9ydCB7IEdhdWdlc01vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNoYXJ0cyc7XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF0sXG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSxcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBHYXVnZXNNb2R1bGVdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IEdhdWdlc01vZHVsZSA9IGNsYXNzIEdhdWdlc01vZHVsZSB7XG59O1xuR2F1Z2VzTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBleHBvcnRzOiBbQXJjR2F1Z2VNb2R1bGUsIExpbmVhckdhdWdlTW9kdWxlLCBSYWRpYWxHYXVnZU1vZHVsZV1cbiAgICB9KVxuXSwgR2F1Z2VzTW9kdWxlKTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBTaGFyZWRNb2R1bGUsIEFyY0dhdWdlTW9kdWxlLCBMaW5lYXJHYXVnZU1vZHVsZSwgUmFkaWFsR2F1Z2VNb2R1bGUsIEdhdWdlc01vZHVsZSwgQ29sbGVjdGlvbkNvbXBvbmVudCwgQ29sbGVjdGlvbkl0ZW1Db21wb25lbnQsIEdhdWdlQ29tcG9uZW50LCBHYXVnZUFyZWFDb21wb25lbnQsIExhYmVsc0NvbXBvbmVudCwgUmFuZ2VDb21wb25lbnQsIFNjYWxlQ29tcG9uZW50LCBTZXR0aW5nc0NvbXBvbmVudCwgQ29uZmlndXJhdGlvblNlcnZpY2UsIENvbGxlY3Rpb25DaGFuZ2VzU2VydmljZSwgVGhlbWVTZXJ2aWNlLCBBcmNHYXVnZUNvbXBvbmVudCwgQXJjR2F1Z2VBcmVhQ29tcG9uZW50LCBBcmNTY2FsZUNvbXBvbmVudCwgQXJjTGFiZWxzQ29tcG9uZW50LCBBcmNDZW50ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgQ29sb3JzQ29tcG9uZW50LCBDb2xvckNvbXBvbmVudCwgTGluZWFyR2F1Z2VDb21wb25lbnQsIExpbmVhckdhdWdlQXJlYUNvbXBvbmVudCwgTGluZWFyU2NhbGVDb21wb25lbnQsIExpbmVhckxhYmVsc0NvbXBvbmVudCwgTGluZWFyUG9pbnRlcnNDb21wb25lbnQsIExpbmVhclBvaW50ZXJDb21wb25lbnQsIExpbmVhclJhbmdlQ29tcG9uZW50LCBMaW5lYXJSYW5nZXNDb21wb25lbnQsIFJhZGlhbEdhdWdlQ29tcG9uZW50LCBSYWRpYWxHYXVnZUFyZWFDb21wb25lbnQsIFJhZGlhbFNjYWxlQ29tcG9uZW50LCBSYWRpYWxMYWJlbHNDb21wb25lbnQsIFJhZGlhbFBvaW50ZXJzQ29tcG9uZW50LCBSYWRpYWxQb2ludGVyQ29tcG9uZW50LCBSYWRpYWxSYW5nZUNvbXBvbmVudCwgUmFkaWFsUmFuZ2VzQ29tcG9uZW50IH07XG4iXX0=