import { Directive, Input, ElementRef, NgZone, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
/**
 * @hidden
 */
export class IgxScrollInertiaDirective {
    constructor(element, _zone) {
        this.element = element;
        this._zone = _zone;
        this.wheelStep = 50;
        this.inertiaStep = 1.5;
        this.swipeToleranceX = 20;
        this.inertiaDeltaY = 3;
        this.inertiaDeltaX = 2;
        this.inertiaDuration = 0.5;
        this._savedSpeedsX = [];
        this.setPointerCaptureFName = typeof Element.prototype['msSetPointerCapture'] === 'function' ?
            'msSetPointerCapture' :
            'setPointerCapture';
        this.releasePointerCaptureFName = typeof Element.prototype['msReleasePointerCapture'] === 'function' ?
            'msReleasePointerCapture' :
            'releasePointerCapture';
        this.baseDeltaMultiplier = 1 / 120;
        this.firefoxDeltaMultiplier = 1 / 30;
    }
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            this.parentElement = this.element.nativeElement.parentElement || this.element.nativeElement.parentNode;
            if (!this.parentElement) {
                return;
            }
            const targetElem = this.parentElement;
            targetElem.addEventListener('wheel', this.onWheel.bind(this));
            targetElem.addEventListener('touchstart', this.onTouchStart.bind(this));
            targetElem.addEventListener('touchmove', this.onTouchMove.bind(this));
            targetElem.addEventListener('touchend', this.onTouchEnd.bind(this));
            targetElem.addEventListener('pointerdown', this.onPointerDown.bind(this));
            targetElem.addEventListener('pointerup', this.onPointerUp.bind(this));
            targetElem.addEventListener('MSGestureStart', this.onMSGestureStart.bind(this));
            targetElem.addEventListener('MSGestureChange', this.onMSGestureChange.bind(this));
        });
    }
    ngOnDestroy() {
        this._zone.runOutsideAngular(() => {
            const targetElem = this.parentElement;
            if (!targetElem) {
                return;
            }
            targetElem.removeEventListener('wheel', this.onWheel);
            targetElem.removeEventListener('touchstart', this.onTouchStart);
            targetElem.removeEventListener('touchmove', this.onTouchMove);
            targetElem.removeEventListener('touchend', this.onTouchEnd);
            targetElem.removeEventListener('pointerdown', this.onPointerDown);
            targetElem.removeEventListener('pointerup', this.onPointerUp);
            targetElem.removeEventListener('MSGestureStart', this.onMSGestureStart);
            targetElem.removeEventListener('MSGestureChange', this.onMSGestureChange);
        });
    }
    /**
     * @hidden
     * Function that is called when scrolling with the mouse wheel or using touchpad
     */
    onWheel(evt) {
        // if no scrollbar return
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        // if ctrl key is pressed and the user want to zoom in/out the page
        if (evt.ctrlKey) {
            return;
        }
        let scrollDeltaX;
        let scrollDeltaY;
        const scrollStep = this.wheelStep;
        const minWheelStep = 1 / this.wheelStep;
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        if (evt.wheelDeltaX) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaX = -evt.wheelDeltaX * this.baseDeltaMultiplier;
            if (-minWheelStep < scrollDeltaX && scrollDeltaX < minWheelStep) {
                scrollDeltaX = Math.sign(scrollDeltaX) * minWheelStep;
            }
        }
        else if (evt.deltaX) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            const deltaScaledX = evt.deltaX * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);
            scrollDeltaX = this.calcAxisCoords(deltaScaledX, -1, 1);
        }
        /** Get delta for the Y axis */
        if (evt.wheelDeltaY) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaY = -evt.wheelDeltaY * this.baseDeltaMultiplier;
            if (-minWheelStep < scrollDeltaY && scrollDeltaY < minWheelStep) {
                scrollDeltaY = Math.sign(scrollDeltaY) * minWheelStep;
            }
        }
        else if (evt.deltaY) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            const deltaScaledY = evt.deltaY * (evt.deltaMode === 0 ? this.firefoxDeltaMultiplier : 1);
            scrollDeltaY = this.calcAxisCoords(deltaScaledY, -1, 1);
        }
        if (scrollDeltaX && this.IgxScrollInertiaDirection === 'horizontal') {
            this._scrollToX(this._startX + scrollDeltaX * scrollStep);
            const curScrollLeft = this.IgxScrollInertiaScrollContainer.scrollLeft;
            const maxScrollLeft = parseInt(this.IgxScrollInertiaScrollContainer.children[0].style.width, 10);
            if (0 < curScrollLeft && curScrollLeft < maxScrollLeft) {
                // Prevent navigating through pages when scrolling on Mac
                evt.preventDefault();
            }
        }
        else if (scrollDeltaY && this.IgxScrollInertiaDirection === 'vertical') {
            this._scrollToY(this._startY + scrollDeltaY * scrollStep);
            this.preventParentScroll(evt, true);
        }
    }
    /**
     * @hidden
     * When there is still room to scroll up/down prevent the parent elements from scrolling too.
     */
    preventParentScroll(evt, preventDefault) {
        const curScrollTop = this.IgxScrollInertiaScrollContainer.scrollTop;
        const maxScrollTop = this.IgxScrollInertiaScrollContainer.children[0].scrollHeight -
            this.IgxScrollInertiaScrollContainer.offsetHeight;
        if (0 < curScrollTop && curScrollTop < maxScrollTop) {
            if (preventDefault) {
                evt.preventDefault();
            }
            if (evt.stopPropagation) {
                evt.stopPropagation();
            }
        }
    }
    /**
     * @hidden
     * Function that is called the first moment we start interacting with the content on a touch device
     */
    onTouchStart(event) {
        if (typeof MSGesture === 'function' || !this.IgxScrollInertiaScrollContainer) {
            return false;
        }
        // stops any current ongoing inertia
        cancelAnimationFrame(this._touchInertiaAnimID);
        const touch = event.touches[0];
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = touch.pageX;
        this._touchStartY = touch.pageY;
        this._lastTouchEnd = new Date().getTime();
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._savedSpeedsX = [];
        this._savedSpeedsY = [];
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        this._touchPrevented = false;
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    /**
     * @hidden
     * Function that is called when we need to scroll the content based on touch interactions
     */
    onTouchMove(event) {
        if (typeof MSGesture === 'function') {
            this._touchPrevented = false;
            return false;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        const touch = event.touches[0];
        const destX = this._startX + (this._touchStartX - touch.pageX) * Math.sign(this.inertiaStep);
        const destY = this._startY + (this._touchStartY - touch.pageY) * Math.sign(this.inertiaStep);
        /* Handle complex touchmoves when swipe stops but the toch doesn't end and then a swipe is initiated again */
        /* **********************************************************/
        const timeFromLastTouch = (new Date().getTime()) - this._lastTouchEnd;
        if (timeFromLastTouch !== 0 && timeFromLastTouch < 100) {
            const speedX = (this._lastTouchX - touch.pageX) / timeFromLastTouch;
            const speedY = (this._lastTouchY - touch.pageY) / timeFromLastTouch;
            // Save the last 5 speeds between two touchmoves on X axis
            if (this._savedSpeedsX.length < 5) {
                this._savedSpeedsX.push(speedX);
            }
            else {
                this._savedSpeedsX.shift();
                this._savedSpeedsX.push(speedX);
            }
            // Save the last 5 speeds between two touchmoves on Y axis
            if (this._savedSpeedsY.length < 5) {
                this._savedSpeedsY.push(speedY);
            }
            else {
                this._savedSpeedsY.shift();
                this._savedSpeedsY.push(speedY);
            }
        }
        this._lastTouchEnd = new Date().getTime();
        this._lastMovedX = this._lastTouchX - touch.pageX;
        this._lastMovedY = this._lastTouchY - touch.pageY;
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._totalMovedX += this._lastMovedX;
        let scrolledXY; // Object: {x, y}
        /*	Do not scroll using touch untill out of the swipeToleranceX bounds */
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            scrolledXY = this._scrollTo(this._startX, destY);
        }
        else {
            /*	Record the direction the first time we are out of the swipeToleranceX bounds.
            *	That way we know which direction we apply the offset so it doesn't hickup when moving out of the swipeToleranceX bounds */
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /*	Scroll with offset ammout of swipeToleranceX in the direction we have exited the bounds and
            don't change it after that ever until touchend and again touchstart */
            scrolledXY = this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        if (scrolledXY.x === 0 && scrolledXY.y === 0) {
            this._touchPrevented = true;
        }
        // On Safari preventing the touchmove would prevent default page scroll behaviour even if there is the element doesn't have overflow
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, true);
        }
    }
    onTouchEnd(event) {
        if (typeof MSGesture === 'function') {
            return;
        }
        let speedX = 0;
        let speedY = 0;
        // savedSpeedsX and savedSpeedsY have same length
        for (let i = 0; i < this._savedSpeedsX.length; i++) {
            speedX += this._savedSpeedsX[i];
            speedY += this._savedSpeedsY[i];
        }
        speedX = this._savedSpeedsX.length ? speedX / this._savedSpeedsX.length : 0;
        speedY = this._savedSpeedsX.length ? speedY / this._savedSpeedsY.length : 0;
        // Use the lastMovedX and lastMovedY to determine if the swipe stops without lifting the finger so we don't start inertia
        if ((Math.abs(speedX) > 0.1 || Math.abs(speedY) > 0.1) &&
            (Math.abs(this._lastMovedX) > 2 || Math.abs(this._lastMovedY) > 2)) {
            this._inertiaInit(speedX, speedY);
        }
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    /**
     * @hidden
     * Function that is called when we need to detect touch starting on a touch device on IE/Edge
     */
    onPointerDown(event) {
        if (!event || (event.pointerType !== 2 && event.pointerType !== 'touch') ||
            typeof MSGesture !== 'function') {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        // setPointerCaptureFName is the name of the function that is supported
        event.target[this.setPointerCaptureFName](this._pointer = event.pointerId);
        // create gestureObject only one time to prevent overlapping during intertia
        if (!this._gestureObject) {
            this._gestureObject = new MSGesture();
            this._gestureObject.target = this.parentElement;
        }
        this._gestureObject.addPointer(this._pointer);
    }
    /**
     * @hidden
     * Function that is called when we need to detect touch ending on a touch device on IE/Edge
     */
    onPointerUp(event) {
        if (!this._pointer) {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        /* releasePointerCaptureFName is the name of the function that is supported */
        event.target[this.releasePointerCaptureFName](this._pointer);
        delete this._pointer;
    }
    /**
     * @hidden
     *  Function that is called when a gesture begins on IE/Edge
     */
    onMSGestureStart(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = event.screenX;
        this._touchStartY = event.screenY;
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        return false;
    }
    /**
     * @hidden
     * Function that is called when a we need to scroll based on the gesture performed on IE/Edge
     */
    onMSGestureChange(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        const touchPos = event;
        const destX = this._startX + this._touchStartX - touchPos.screenX;
        const destY = this._startY + this._touchStartY - touchPos.screenY;
        /* Logic regarding x tolerance to prevent accidental horizontal scrolling when scrolling vertically */
        this._totalMovedX = this._touchStartX - touchPos.screenX;
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            /* Do not scroll horizontally yet while in the tolerance range */
            this._scrollToY(destY);
        }
        else {
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /* Once the tolerance is exceeded it can be scrolled horizontally */
            this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        return false;
    }
    _inertiaInit(speedX, speedY) {
        const stepModifer = this.inertiaStep;
        const inertiaDuration = this.inertiaDuration;
        let x = 0;
        this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // Sets timeout until executing next movement iteration of the inertia
        const inertiaStep = () => {
            if (x > 6) {
                cancelAnimationFrame(this._touchInertiaAnimID);
                return;
            }
            if (Math.abs(speedX) > Math.abs(speedY)) {
                x += 0.05 / (1 * inertiaDuration);
            }
            else {
                x += 0.05 / (1 * inertiaDuration);
            }
            if (x <= 1) {
                // We use constant quation to determine the offset without speed falloff befor x reaches 1
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += 1 * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += 1 * speedY * 15 * stepModifer;
                }
            }
            else {
                // We use the quation "y = 2 / (x + 0.55) - 0.3" to determine the offset
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += Math.abs(2 / (x + 0.55) - 0.3) * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += Math.abs(2 / (x + 0.55) - 0.3) * speedY * 15 * stepModifer;
                }
            }
            // If we have mixed environment we use the default behaviour. i.e. touchscreen + mouse
            this._scrollTo(this._nextX, this._nextY);
            this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
        };
        // Start inertia and continue it recursively
        this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
    }
    calcAxisCoords(target, min, max) {
        if (target === undefined || target < min) {
            target = min;
        }
        else if (target > max) {
            target = max;
        }
        return target;
    }
    _scrollTo(destX, destY) {
        const curPosX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        const curPosY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // TODO Trigger scrolling event?
        const scrolledX = this._scrollToX(destX);
        const scrolledY = this._scrollToY(destY);
        return { x: scrolledX, y: scrolledY };
    }
    _scrollToX(dest) {
        this.IgxScrollInertiaScrollContainer.scrollLeft = dest;
    }
    _scrollToY(dest) {
        this.IgxScrollInertiaScrollContainer.scrollTop = dest;
    }
}
IgxScrollInertiaDirective.decorators = [
    { type: Directive, args: [{ selector: '[igxScrollInertia]' },] }
];
IgxScrollInertiaDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
IgxScrollInertiaDirective.propDecorators = {
    IgxScrollInertiaDirection: [{ type: Input }],
    IgxScrollInertiaScrollContainer: [{ type: Input }],
    wheelStep: [{ type: Input }],
    inertiaStep: [{ type: Input }],
    swipeToleranceX: [{ type: Input }],
    inertiaDeltaY: [{ type: Input }],
    inertiaDeltaX: [{ type: Input }],
    inertiaDuration: [{ type: Input }]
};
/**
 * @hidden
 */
export class IgxScrollInertiaModule {
}
IgxScrollInertiaModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxScrollInertiaDirective],
                exports: [IgxScrollInertiaDirective],
                imports: [CommonModule]
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsX2luZXJ0aWEuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvc2Nyb2xsLWluZXJ0aWEvc2Nyb2xsX2luZXJ0aWEuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQVUsUUFBUSxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQ2xHLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUUvQzs7R0FFRztBQUVILE1BQU0sT0FBTyx5QkFBeUI7SUF3RGxDLFlBQW9CLE9BQW1CLEVBQVUsS0FBYTtRQUExQyxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQVUsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQS9DdkQsY0FBUyxHQUFHLEVBQUUsQ0FBQztRQUdmLGdCQUFXLEdBQUcsR0FBRyxDQUFDO1FBR2xCLG9CQUFlLEdBQUcsRUFBRSxDQUFDO1FBR3JCLGtCQUFhLEdBQUcsQ0FBQyxDQUFDO1FBR2xCLGtCQUFhLEdBQUcsQ0FBQyxDQUFDO1FBR2xCLG9CQUFlLEdBQUcsR0FBRyxDQUFDO1FBVXJCLGtCQUFhLEdBQUcsRUFBRSxDQUFDO1FBU25CLDJCQUFzQixHQUFHLE9BQU8sT0FBTyxDQUFDLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLFVBQVUsQ0FBQyxDQUFDO1lBQzdGLHFCQUFxQixDQUFDLENBQUM7WUFDdkIsbUJBQW1CLENBQUM7UUFDaEIsK0JBQTBCLEdBQUcsT0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDLHlCQUF5QixDQUFDLEtBQUssVUFBVSxDQUFDLENBQUM7WUFDckcseUJBQXlCLENBQUMsQ0FBQztZQUMzQix1QkFBdUIsQ0FBQztRQUtwQix3QkFBbUIsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQzlC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QUMsVUFBVSxDQUFDO1FBQ2hFLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQywrQkFBK0IsQ0FBQyxTQUFTLENBQUM7UUFFL0QsZ0NBQWdDO1FBQ2hDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDekMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUV6QyxPQUFPLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFLENBQUM7SUFDMUMsQ0FBQztJQUNPLFVBQVUsQ0FBQyxJQUFJO1FBQ25CLElBQUksQ0FBQywrQkFBK0IsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO0lBQzNELENBQUM7SUFDTyxVQUFVLENBQUMsSUFBSTtRQUNuQixJQUFJLENBQUMsK0JBQStCLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztJQUMxRCxDQUFDOzs7WUFuZUosU0FBUyxTQUFDLEVBQUUsUUFBUSxFQUFFLG9CQUFvQixFQUFFOzs7WUFObEIsVUFBVTtZQUFFLE1BQU07Ozt3Q0FTeEMsS0FBSzs4Q0FHTCxLQUFLO3dCQUdMLEtBQUs7MEJBR0wsS0FBSzs4QkFHTCxLQUFLOzRCQUdMLEtBQUs7NEJBR0wsS0FBSzs4QkFHTCxLQUFLOztBQThjVjs7R0FFRztBQU9ILE1BQU0sT0FBTyxzQkFBc0I7OztZQU5sQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFLENBQUMseUJBQXlCLENBQUM7Z0JBQ3pDLE9BQU8sRUFBRSxDQUFDLHlCQUF5QixDQUFDO2dCQUNwQyxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUM7YUFDMUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBFbGVtZW50UmVmLCBOZ1pvbmUsIE9uSW5pdCwgTmdNb2R1bGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tpZ3hTY3JvbGxJbmVydGlhXScgfSlcbmV4cG9ydCBjbGFzcyBJZ3hTY3JvbGxJbmVydGlhRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgSWd4U2Nyb2xsSW5lcnRpYURpcmVjdGlvbjogc3RyaW5nO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lcjogYW55O1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgd2hlZWxTdGVwID0gNTA7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpbmVydGlhU3RlcCA9IDEuNTtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHN3aXBlVG9sZXJhbmNlWCA9IDIwO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaW5lcnRpYURlbHRhWSA9IDM7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpbmVydGlhRGVsdGFYID0gMjtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGluZXJ0aWFEdXJhdGlvbiA9IDAuNTtcblxuICAgIHByaXZhdGUgX3RvdWNoSW5lcnRpYUFuaW1JRDtcbiAgICBwcml2YXRlIF9zdGFydFg7XG4gICAgcHJpdmF0ZSBfc3RhcnRZO1xuICAgIHByaXZhdGUgX3RvdWNoU3RhcnRYO1xuICAgIHByaXZhdGUgX3RvdWNoU3RhcnRZO1xuICAgIHByaXZhdGUgX2xhc3RUb3VjaEVuZDtcbiAgICBwcml2YXRlIF9sYXN0VG91Y2hYO1xuICAgIHByaXZhdGUgX2xhc3RUb3VjaFk7XG4gICAgcHJpdmF0ZSBfc2F2ZWRTcGVlZHNYID0gW107XG4gICAgcHJpdmF0ZSBfc2F2ZWRTcGVlZHNZO1xuICAgIHByaXZhdGUgX3RvdGFsTW92ZWRYO1xuICAgIHByaXZhdGUgX29mZnNldFJlY29yZGVkO1xuICAgIHByaXZhdGUgX29mZnNldERpcmVjdGlvbjtcbiAgICBwcml2YXRlIF90b3VjaFByZXZlbnRlZDtcbiAgICBwcml2YXRlIF9sYXN0TW92ZWRYO1xuICAgIHByaXZhdGUgX2xhc3RNb3ZlZFk7XG4gICAgcHJpdmF0ZSBfZ2VzdHVyZU9iamVjdDtcbiAgICBwcml2YXRlIHNldFBvaW50ZXJDYXB0dXJlRk5hbWUgPSB0eXBlb2YgRWxlbWVudC5wcm90b3R5cGVbJ21zU2V0UG9pbnRlckNhcHR1cmUnXSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICdtc1NldFBvaW50ZXJDYXB0dXJlJyA6XG4gICAgICAgICdzZXRQb2ludGVyQ2FwdHVyZSc7XG4gICAgcHJpdmF0ZSByZWxlYXNlUG9pbnRlckNhcHR1cmVGTmFtZSA9IHR5cGVvZiBFbGVtZW50LnByb3RvdHlwZVsnbXNSZWxlYXNlUG9pbnRlckNhcHR1cmUnXSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICdtc1JlbGVhc2VQb2ludGVyQ2FwdHVyZScgOlxuICAgICAgICAncmVsZWFzZVBvaW50ZXJDYXB0dXJlJztcbiAgICBwcml2YXRlIF9wb2ludGVyO1xuICAgIHByaXZhdGUgX25leHRYO1xuICAgIHByaXZhdGUgX25leHRZO1xuICAgIHByaXZhdGUgcGFyZW50RWxlbWVudDtcbiAgICBwcml2YXRlIGJhc2VEZWx0YU11bHRpcGxpZXIgPSAxIC8gMTIwO1xuICAgIHByaXZhdGUgZmlyZWZveERlbHRhTXVsdGlwbGllciA9IDEgLyAzMDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7IH1cblxuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsZW0gPSB0aGlzLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbldoZWVsLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbS5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMub25Qb2ludGVyRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRhcmdldEVsZW0uYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5vblBvaW50ZXJVcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRhcmdldEVsZW0uYWRkRXZlbnRMaXN0ZW5lcignTVNHZXN0dXJlU3RhcnQnLCB0aGlzLm9uTVNHZXN0dXJlU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ01TR2VzdHVyZUNoYW5nZScsIHRoaXMub25NU0dlc3R1cmVDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRFbGVtID0gdGhpcy5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCF0YXJnZXRFbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0RWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMub25XaGVlbCk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydCk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUpO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Ub3VjaEVuZCk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdGhpcy5vblBvaW50ZXJEb3duKTtcbiAgICAgICAgICAgIHRhcmdldEVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5vblBvaW50ZXJVcCk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ01TR2VzdHVyZVN0YXJ0JywgdGhpcy5vbk1TR2VzdHVyZVN0YXJ0KTtcbiAgICAgICAgICAgIHRhcmdldEVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignTVNHZXN0dXJlQ2hhbmdlJywgdGhpcy5vbk1TR2VzdHVyZUNoYW5nZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHNjcm9sbGluZyB3aXRoIHRoZSBtb3VzZSB3aGVlbCBvciB1c2luZyB0b3VjaHBhZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBvbldoZWVsKGV2dCkge1xuICAgICAgICAvLyBpZiBubyBzY3JvbGxiYXIgcmV0dXJuXG4gICAgICAgIGlmICghdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgY3RybCBrZXkgaXMgcHJlc3NlZCBhbmQgdGhlIHVzZXIgd2FudCB0byB6b29tIGluL291dCB0aGUgcGFnZVxuICAgICAgICBpZiAoZXZ0LmN0cmxLZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2Nyb2xsRGVsdGFYO1xuICAgICAgICBsZXQgc2Nyb2xsRGVsdGFZO1xuICAgICAgICBjb25zdCBzY3JvbGxTdGVwID0gdGhpcy53aGVlbFN0ZXA7XG4gICAgICAgIGNvbnN0IG1pbldoZWVsU3RlcCA9IDEgLyB0aGlzLndoZWVsU3RlcDtcblxuICAgICAgICB0aGlzLl9zdGFydFggPSB0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgdGhpcy5fc3RhcnRZID0gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcDtcblxuICAgICAgICBpZiAoZXZ0LndoZWVsRGVsdGFYKSB7XG4gICAgICAgICAgICAvKiBPcHRpb24gc3VwcG9ydGVkIG9uIENocm9tZSwgU2FmYXJpLCBPcGVyYS5cbiAgICAgICAgICAgIC8qIDEyMCBpcyBkZWZhdWx0IGZvciBtb3VzZXdoZWVsIG9uIHRoZXNlIGJyb3dzZXJzLiBPdGhlciB2YWx1ZXMgYXJlIGZvciB0cmFja3BhZHMgKi9cbiAgICAgICAgICAgIHNjcm9sbERlbHRhWCA9IC1ldnQud2hlZWxEZWx0YVggKiB0aGlzLmJhc2VEZWx0YU11bHRpcGxpZXI7XG5cbiAgICAgICAgICAgIGlmICgtbWluV2hlZWxTdGVwIDwgc2Nyb2xsRGVsdGFYICYmIHNjcm9sbERlbHRhWCA8IG1pbldoZWVsU3RlcCkge1xuICAgICAgICAgICAgICAgIHNjcm9sbERlbHRhWCA9IE1hdGguc2lnbihzY3JvbGxEZWx0YVgpICogbWluV2hlZWxTdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2dC5kZWx0YVgpIHtcbiAgICAgICAgICAgIC8qIEZvciBvdGhlciBicm93c2VycyB0aGF0IGRvbid0IHByb3ZpZGUgd2hlZWxEZWx0YSwgdXNlIHRoZSBkZWx0YVkgdG8gZGV0ZXJtaW5lIGRpcmVjdGlvbiBhbmQgcGFzcyBkZWZhdWx0IHZhbHVlcy4gKi9cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhU2NhbGVkWCA9IGV2dC5kZWx0YVggKiAoZXZ0LmRlbHRhTW9kZSA9PT0gMCA/IHRoaXMuZmlyZWZveERlbHRhTXVsdGlwbGllciA6IDEpO1xuICAgICAgICAgICAgc2Nyb2xsRGVsdGFYID0gdGhpcy5jYWxjQXhpc0Nvb3JkcyhkZWx0YVNjYWxlZFgsIC0xLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBHZXQgZGVsdGEgZm9yIHRoZSBZIGF4aXMgKi9cbiAgICAgICAgaWYgKGV2dC53aGVlbERlbHRhWSkge1xuICAgICAgICAgICAgLyogT3B0aW9uIHN1cHBvcnRlZCBvbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEuXG4gICAgICAgICAgICAvKiAxMjAgaXMgZGVmYXVsdCBmb3IgbW91c2V3aGVlbCBvbiB0aGVzZSBicm93c2Vycy4gT3RoZXIgdmFsdWVzIGFyZSBmb3IgdHJhY2twYWRzICovXG4gICAgICAgICAgICBzY3JvbGxEZWx0YVkgPSAtZXZ0LndoZWVsRGVsdGFZICogdGhpcy5iYXNlRGVsdGFNdWx0aXBsaWVyO1xuXG4gICAgICAgICAgICBpZiAoLW1pbldoZWVsU3RlcCA8IHNjcm9sbERlbHRhWSAmJiBzY3JvbGxEZWx0YVkgPCBtaW5XaGVlbFN0ZXApIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxEZWx0YVkgPSBNYXRoLnNpZ24oc2Nyb2xsRGVsdGFZKSAqIG1pbldoZWVsU3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldnQuZGVsdGFZKSB7XG4gICAgICAgICAgICAvKiBGb3Igb3RoZXIgYnJvd3NlcnMgdGhhdCBkb24ndCBwcm92aWRlIHdoZWVsRGVsdGEsIHVzZSB0aGUgZGVsdGFZIHRvIGRldGVybWluZSBkaXJlY3Rpb24gYW5kIHBhc3MgZGVmYXVsdCB2YWx1ZXMuICovXG4gICAgICAgICAgICBjb25zdCBkZWx0YVNjYWxlZFkgPSBldnQuZGVsdGFZICogKGV2dC5kZWx0YU1vZGUgPT09IDAgPyB0aGlzLmZpcmVmb3hEZWx0YU11bHRpcGxpZXIgOiAxKTtcbiAgICAgICAgICAgIHNjcm9sbERlbHRhWSA9IHRoaXMuY2FsY0F4aXNDb29yZHMoZGVsdGFTY2FsZWRZLCAtMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbERlbHRhWCAmJiB0aGlzLklneFNjcm9sbEluZXJ0aWFEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9YKFxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0WCArIHNjcm9sbERlbHRhWCAqIHNjcm9sbFN0ZXBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBjdXJTY3JvbGxMZWZ0ID0gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICBjb25zdCBtYXhTY3JvbGxMZWZ0ID0gcGFyc2VJbnQodGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLmNoaWxkcmVuWzBdLnN0eWxlLndpZHRoLCAxMCk7XG4gICAgICAgICAgICBpZiAoMCA8IGN1clNjcm9sbExlZnQgJiYgY3VyU2Nyb2xsTGVmdCA8IG1heFNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5hdmlnYXRpbmcgdGhyb3VnaCBwYWdlcyB3aGVuIHNjcm9sbGluZyBvbiBNYWNcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzY3JvbGxEZWx0YVkgJiYgdGhpcy5JZ3hTY3JvbGxJbmVydGlhRGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxUb1koXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRZICsgc2Nyb2xsRGVsdGFZICogc2Nyb2xsU3RlcFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMucHJldmVudFBhcmVudFNjcm9sbChldnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFdoZW4gdGhlcmUgaXMgc3RpbGwgcm9vbSB0byBzY3JvbGwgdXAvZG93biBwcmV2ZW50IHRoZSBwYXJlbnQgZWxlbWVudHMgZnJvbSBzY3JvbGxpbmcgdG9vLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBwcmV2ZW50UGFyZW50U2Nyb2xsKGV2dCwgcHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgY29uc3QgY3VyU2Nyb2xsVG9wID0gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgICAgY29uc3QgbWF4U2Nyb2xsVG9wID0gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLmNoaWxkcmVuWzBdLnNjcm9sbEhlaWdodCAtXG4gICAgICAgICAgICB0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBpZiAoMCA8IGN1clNjcm9sbFRvcCAmJiBjdXJTY3JvbGxUb3AgPCBtYXhTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2dC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgdGhlIGZpcnN0IG1vbWVudCB3ZSBzdGFydCBpbnRlcmFjdGluZyB3aXRoIHRoZSBjb250ZW50IG9uIGEgdG91Y2ggZGV2aWNlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG9uVG91Y2hTdGFydChldmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIE1TR2VzdHVyZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9wcyBhbnkgY3VycmVudCBvbmdvaW5nIGluZXJ0aWFcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fdG91Y2hJbmVydGlhQW5pbUlEKTtcblxuICAgICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG5cbiAgICAgICAgdGhpcy5fc3RhcnRYID0gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQ7XG5cbiAgICAgICAgdGhpcy5fc3RhcnRZID0gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcDtcblxuICAgICAgICB0aGlzLl90b3VjaFN0YXJ0WCA9IHRvdWNoLnBhZ2VYO1xuICAgICAgICB0aGlzLl90b3VjaFN0YXJ0WSA9IHRvdWNoLnBhZ2VZO1xuXG4gICAgICAgIHRoaXMuX2xhc3RUb3VjaEVuZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLl9sYXN0VG91Y2hYID0gdG91Y2gucGFnZVg7XG4gICAgICAgIHRoaXMuX2xhc3RUb3VjaFkgPSB0b3VjaC5wYWdlWTtcbiAgICAgICAgdGhpcy5fc2F2ZWRTcGVlZHNYID0gW107XG4gICAgICAgIHRoaXMuX3NhdmVkU3BlZWRzWSA9IFtdO1xuXG4gICAgICAgIC8vIFZhcnMgcmVnYXJkaW5nIHN3aXBlIG9mZnNldFxuICAgICAgICB0aGlzLl90b3RhbE1vdmVkWCA9IDA7XG4gICAgICAgIHRoaXMuX29mZnNldFJlY29yZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29mZnNldERpcmVjdGlvbiA9IDA7XG5cbiAgICAgICAgdGhpcy5fdG91Y2hQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuSWd4U2Nyb2xsSW5lcnRpYURpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgdGhpcy5wcmV2ZW50UGFyZW50U2Nyb2xsKGV2ZW50LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB3ZSBuZWVkIHRvIHNjcm9sbCB0aGUgY29udGVudCBiYXNlZCBvbiB0b3VjaCBpbnRlcmFjdGlvbnNcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb25Ub3VjaE1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBNU0dlc3R1cmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoUHJldmVudGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgICAgY29uc3QgZGVzdFggPSB0aGlzLl9zdGFydFggKyAodGhpcy5fdG91Y2hTdGFydFggLSB0b3VjaC5wYWdlWCkgKiBNYXRoLnNpZ24odGhpcy5pbmVydGlhU3RlcCk7XG4gICAgICAgIGNvbnN0IGRlc3RZID0gdGhpcy5fc3RhcnRZICsgKHRoaXMuX3RvdWNoU3RhcnRZIC0gdG91Y2gucGFnZVkpICogTWF0aC5zaWduKHRoaXMuaW5lcnRpYVN0ZXApO1xuXG4gICAgICAgIC8qIEhhbmRsZSBjb21wbGV4IHRvdWNobW92ZXMgd2hlbiBzd2lwZSBzdG9wcyBidXQgdGhlIHRvY2ggZG9lc24ndCBlbmQgYW5kIHRoZW4gYSBzd2lwZSBpcyBpbml0aWF0ZWQgYWdhaW4gKi9cbiAgICAgICAgLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgICAgIGNvbnN0IHRpbWVGcm9tTGFzdFRvdWNoID0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSAtIHRoaXMuX2xhc3RUb3VjaEVuZDtcbiAgICAgICAgaWYgKHRpbWVGcm9tTGFzdFRvdWNoICE9PSAwICYmIHRpbWVGcm9tTGFzdFRvdWNoIDwgMTAwKSB7XG4gICAgICAgICAgICBjb25zdCBzcGVlZFggPSAodGhpcy5fbGFzdFRvdWNoWCAtIHRvdWNoLnBhZ2VYKSAvIHRpbWVGcm9tTGFzdFRvdWNoO1xuICAgICAgICAgICAgY29uc3Qgc3BlZWRZID0gKHRoaXMuX2xhc3RUb3VjaFkgLSB0b3VjaC5wYWdlWSkgLyB0aW1lRnJvbUxhc3RUb3VjaDtcblxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgbGFzdCA1IHNwZWVkcyBiZXR3ZWVuIHR3byB0b3VjaG1vdmVzIG9uIFggYXhpc1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NhdmVkU3BlZWRzWC5sZW5ndGggPCA1KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRTcGVlZHNYLnB1c2goc3BlZWRYKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRTcGVlZHNYLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRTcGVlZHNYLnB1c2goc3BlZWRYKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgbGFzdCA1IHNwZWVkcyBiZXR3ZWVuIHR3byB0b3VjaG1vdmVzIG9uIFkgYXhpc1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NhdmVkU3BlZWRzWS5sZW5ndGggPCA1KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRTcGVlZHNZLnB1c2goc3BlZWRZKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRTcGVlZHNZLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRTcGVlZHNZLnB1c2goc3BlZWRZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0VG91Y2hFbmQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5fbGFzdE1vdmVkWCA9IHRoaXMuX2xhc3RUb3VjaFggLSB0b3VjaC5wYWdlWDtcbiAgICAgICAgdGhpcy5fbGFzdE1vdmVkWSA9IHRoaXMuX2xhc3RUb3VjaFkgLSB0b3VjaC5wYWdlWTtcbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoWCA9IHRvdWNoLnBhZ2VYO1xuICAgICAgICB0aGlzLl9sYXN0VG91Y2hZID0gdG91Y2gucGFnZVk7XG5cbiAgICAgICAgdGhpcy5fdG90YWxNb3ZlZFggKz0gdGhpcy5fbGFzdE1vdmVkWDtcblxuICAgICAgICBsZXQgc2Nyb2xsZWRYWTsgLy8gT2JqZWN0OiB7eCwgeX1cbiAgICAgICAgLypcdERvIG5vdCBzY3JvbGwgdXNpbmcgdG91Y2ggdW50aWxsIG91dCBvZiB0aGUgc3dpcGVUb2xlcmFuY2VYIGJvdW5kcyAqL1xuICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5fdG90YWxNb3ZlZFgpIDwgdGhpcy5zd2lwZVRvbGVyYW5jZVggJiYgIXRoaXMuX29mZnNldFJlY29yZGVkKSB7XG4gICAgICAgICAgICBzY3JvbGxlZFhZID0gdGhpcy5fc2Nyb2xsVG8odGhpcy5fc3RhcnRYLCBkZXN0WSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKlx0UmVjb3JkIHRoZSBkaXJlY3Rpb24gdGhlIGZpcnN0IHRpbWUgd2UgYXJlIG91dCBvZiB0aGUgc3dpcGVUb2xlcmFuY2VYIGJvdW5kcy5cbiAgICAgICAgICAgICpcdFRoYXQgd2F5IHdlIGtub3cgd2hpY2ggZGlyZWN0aW9uIHdlIGFwcGx5IHRoZSBvZmZzZXQgc28gaXQgZG9lc24ndCBoaWNrdXAgd2hlbiBtb3Zpbmcgb3V0IG9mIHRoZSBzd2lwZVRvbGVyYW5jZVggYm91bmRzICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuX29mZnNldFJlY29yZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0RGlyZWN0aW9uID0gTWF0aC5zaWduKGRlc3RYIC0gdGhpcy5fc3RhcnRYKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXRSZWNvcmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qXHRTY3JvbGwgd2l0aCBvZmZzZXQgYW1tb3V0IG9mIHN3aXBlVG9sZXJhbmNlWCBpbiB0aGUgZGlyZWN0aW9uIHdlIGhhdmUgZXhpdGVkIHRoZSBib3VuZHMgYW5kXG4gICAgICAgICAgICBkb24ndCBjaGFuZ2UgaXQgYWZ0ZXIgdGhhdCBldmVyIHVudGlsIHRvdWNoZW5kIGFuZCBhZ2FpbiB0b3VjaHN0YXJ0ICovXG4gICAgICAgICAgICBzY3JvbGxlZFhZID0gdGhpcy5fc2Nyb2xsVG8oZGVzdFggLSB0aGlzLl9vZmZzZXREaXJlY3Rpb24gKiB0aGlzLnN3aXBlVG9sZXJhbmNlWCxcbiAgICAgICAgICAgICAgICBkZXN0WSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Nyb2xsZWRYWS54ID09PSAwICYmIHNjcm9sbGVkWFkueSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT24gU2FmYXJpIHByZXZlbnRpbmcgdGhlIHRvdWNobW92ZSB3b3VsZCBwcmV2ZW50IGRlZmF1bHQgcGFnZSBzY3JvbGwgYmVoYXZpb3VyIGV2ZW4gaWYgdGhlcmUgaXMgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIG92ZXJmbG93XG4gICAgICAgIGlmICh0aGlzLklneFNjcm9sbEluZXJ0aWFEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmVudFBhcmVudFNjcm9sbChldmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgb25Ub3VjaEVuZChldmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIE1TR2VzdHVyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGVlZFggPSAwO1xuICAgICAgICBsZXQgc3BlZWRZID0gMDtcblxuICAgICAgICAvLyBzYXZlZFNwZWVkc1ggYW5kIHNhdmVkU3BlZWRzWSBoYXZlIHNhbWUgbGVuZ3RoXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2F2ZWRTcGVlZHNYLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzcGVlZFggKz0gdGhpcy5fc2F2ZWRTcGVlZHNYW2ldO1xuICAgICAgICAgICAgc3BlZWRZICs9IHRoaXMuX3NhdmVkU3BlZWRzWVtpXTtcbiAgICAgICAgfVxuICAgICAgICBzcGVlZFggPSB0aGlzLl9zYXZlZFNwZWVkc1gubGVuZ3RoID8gc3BlZWRYIC8gdGhpcy5fc2F2ZWRTcGVlZHNYLmxlbmd0aCA6IDA7XG4gICAgICAgIHNwZWVkWSA9IHRoaXMuX3NhdmVkU3BlZWRzWC5sZW5ndGggPyBzcGVlZFkgLyB0aGlzLl9zYXZlZFNwZWVkc1kubGVuZ3RoIDogMDtcblxuICAgICAgICAvLyBVc2UgdGhlIGxhc3RNb3ZlZFggYW5kIGxhc3RNb3ZlZFkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBzd2lwZSBzdG9wcyB3aXRob3V0IGxpZnRpbmcgdGhlIGZpbmdlciBzbyB3ZSBkb24ndCBzdGFydCBpbmVydGlhXG4gICAgICAgIGlmICgoTWF0aC5hYnMoc3BlZWRYKSA+IDAuMSB8fCBNYXRoLmFicyhzcGVlZFkpID4gMC4xKSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKHRoaXMuX2xhc3RNb3ZlZFgpID4gMiB8fCBNYXRoLmFicyh0aGlzLl9sYXN0TW92ZWRZKSA+IDIpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbmVydGlhSW5pdChzcGVlZFgsIHNwZWVkWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuSWd4U2Nyb2xsSW5lcnRpYURpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgdGhpcy5wcmV2ZW50UGFyZW50U2Nyb2xsKGV2ZW50LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB3ZSBuZWVkIHRvIGRldGVjdCB0b3VjaCBzdGFydGluZyBvbiBhIHRvdWNoIGRldmljZSBvbiBJRS9FZGdlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudCB8fCAoZXZlbnQucG9pbnRlclR5cGUgIT09IDIgJiYgZXZlbnQucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHx8XG4gICAgICAgICAgICB0eXBlb2YgTVNHZXN0dXJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldFBvaW50ZXJDYXB0dXJlRk5hbWUgaXMgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgc3VwcG9ydGVkXG4gICAgICAgIGV2ZW50LnRhcmdldFt0aGlzLnNldFBvaW50ZXJDYXB0dXJlRk5hbWVdKHRoaXMuX3BvaW50ZXIgPSBldmVudC5wb2ludGVySWQpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBnZXN0dXJlT2JqZWN0IG9ubHkgb25lIHRpbWUgdG8gcHJldmVudCBvdmVybGFwcGluZyBkdXJpbmcgaW50ZXJ0aWFcbiAgICAgICAgaWYgKCF0aGlzLl9nZXN0dXJlT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9nZXN0dXJlT2JqZWN0ID0gbmV3IE1TR2VzdHVyZSgpO1xuICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZU9iamVjdC50YXJnZXQgPSB0aGlzLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2VzdHVyZU9iamVjdC5hZGRQb2ludGVyKHRoaXMuX3BvaW50ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHdlIG5lZWQgdG8gZGV0ZWN0IHRvdWNoIGVuZGluZyBvbiBhIHRvdWNoIGRldmljZSBvbiBJRS9FZGdlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5fcG9pbnRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiByZWxlYXNlUG9pbnRlckNhcHR1cmVGTmFtZSBpcyB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBpcyBzdXBwb3J0ZWQgKi9cbiAgICAgICAgZXZlbnQudGFyZ2V0W3RoaXMucmVsZWFzZVBvaW50ZXJDYXB0dXJlRk5hbWVdKHRoaXMuX3BvaW50ZXIpO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wb2ludGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiAgRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBhIGdlc3R1cmUgYmVnaW5zIG9uIElFL0VkZ2VcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb25NU0dlc3R1cmVTdGFydChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0O1xuICAgICAgICB0aGlzLl9zdGFydFkgPSB0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wO1xuXG5cbiAgICAgICAgdGhpcy5fdG91Y2hTdGFydFggPSBldmVudC5zY3JlZW5YO1xuICAgICAgICB0aGlzLl90b3VjaFN0YXJ0WSA9IGV2ZW50LnNjcmVlblk7XG5cbiAgICAgICAgLy8gVmFycyByZWdhcmRpbmcgc3dpcGUgb2Zmc2V0XG4gICAgICAgIHRoaXMuX3RvdGFsTW92ZWRYID0gMDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0UmVjb3JkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0RGlyZWN0aW9uID0gMDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgd2UgbmVlZCB0byBzY3JvbGwgYmFzZWQgb24gdGhlIGdlc3R1cmUgcGVyZm9ybWVkIG9uIElFL0VkZ2VcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb25NU0dlc3R1cmVDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLklneFNjcm9sbEluZXJ0aWFTY3JvbGxDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3VjaFBvcyA9IGV2ZW50O1xuICAgICAgICBjb25zdCBkZXN0WCA9IHRoaXMuX3N0YXJ0WCArIHRoaXMuX3RvdWNoU3RhcnRYIC0gdG91Y2hQb3Muc2NyZWVuWDtcbiAgICAgICAgY29uc3QgZGVzdFkgPSB0aGlzLl9zdGFydFkgKyB0aGlzLl90b3VjaFN0YXJ0WSAtIHRvdWNoUG9zLnNjcmVlblk7XG4gICAgICAgIC8qIExvZ2ljIHJlZ2FyZGluZyB4IHRvbGVyYW5jZSB0byBwcmV2ZW50IGFjY2lkZW50YWwgaG9yaXpvbnRhbCBzY3JvbGxpbmcgd2hlbiBzY3JvbGxpbmcgdmVydGljYWxseSAqL1xuICAgICAgICB0aGlzLl90b3RhbE1vdmVkWCA9IHRoaXMuX3RvdWNoU3RhcnRYIC0gdG91Y2hQb3Muc2NyZWVuWDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3RvdGFsTW92ZWRYKSA8IHRoaXMuc3dpcGVUb2xlcmFuY2VYICYmICF0aGlzLl9vZmZzZXRSZWNvcmRlZCkge1xuICAgICAgICAgICAgLyogRG8gbm90IHNjcm9sbCBob3Jpem9udGFsbHkgeWV0IHdoaWxlIGluIHRoZSB0b2xlcmFuY2UgcmFuZ2UgKi9cbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvWShkZXN0WSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX29mZnNldFJlY29yZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0RGlyZWN0aW9uID0gTWF0aC5zaWduKGRlc3RYIC0gdGhpcy5fc3RhcnRYKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXRSZWNvcmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBPbmNlIHRoZSB0b2xlcmFuY2UgaXMgZXhjZWVkZWQgaXQgY2FuIGJlIHNjcm9sbGVkIGhvcml6b250YWxseSAqL1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG8oZGVzdFggLSB0aGlzLl9vZmZzZXREaXJlY3Rpb24gKiB0aGlzLnN3aXBlVG9sZXJhbmNlWCwgZGVzdFkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfaW5lcnRpYUluaXQoc3BlZWRYLCBzcGVlZFkpIHtcbiAgICAgICAgY29uc3Qgc3RlcE1vZGlmZXIgPSB0aGlzLmluZXJ0aWFTdGVwO1xuICAgICAgICBjb25zdCBpbmVydGlhRHVyYXRpb24gPSB0aGlzLmluZXJ0aWFEdXJhdGlvbjtcbiAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICB0aGlzLl9uZXh0WCA9IHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0O1xuICAgICAgICB0aGlzLl9uZXh0WSA9IHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3A7XG5cbiAgICAgICAgLy8gU2V0cyB0aW1lb3V0IHVudGlsIGV4ZWN1dGluZyBuZXh0IG1vdmVtZW50IGl0ZXJhdGlvbiBvZiB0aGUgaW5lcnRpYVxuICAgICAgICBjb25zdCBpbmVydGlhU3RlcCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh4ID4gNikge1xuICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RvdWNoSW5lcnRpYUFuaW1JRCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3BlZWRYKSA+IE1hdGguYWJzKHNwZWVkWSkpIHtcbiAgICAgICAgICAgICAgICB4ICs9IDAuMDUgLyAoMSAqIGluZXJ0aWFEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggKz0gMC4wNSAvICgxICogaW5lcnRpYUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHggPD0gMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBjb25zdGFudCBxdWF0aW9uIHRvIGRldGVybWluZSB0aGUgb2Zmc2V0IHdpdGhvdXQgc3BlZWQgZmFsbG9mZiBiZWZvciB4IHJlYWNoZXMgMVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzcGVlZFkpIDw9IE1hdGguYWJzKHNwZWVkWCkgKiB0aGlzLmluZXJ0aWFEZWx0YVkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV4dFggKz0gMSAqIHNwZWVkWCAqIDE1ICogc3RlcE1vZGlmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzcGVlZFkpID49IE1hdGguYWJzKHNwZWVkWCkgKiB0aGlzLmluZXJ0aWFEZWx0YVgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV4dFkgKz0gMSAqIHNwZWVkWSAqIDE1ICogc3RlcE1vZGlmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgdGhlIHF1YXRpb24gXCJ5ID0gMiAvICh4ICsgMC41NSkgLSAwLjNcIiB0byBkZXRlcm1pbmUgdGhlIG9mZnNldFxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzcGVlZFkpIDw9IE1hdGguYWJzKHNwZWVkWCkgKiB0aGlzLmluZXJ0aWFEZWx0YVkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV4dFggKz0gTWF0aC5hYnMoMiAvICh4ICsgMC41NSkgLSAwLjMpICogc3BlZWRYICogMTUgKiBzdGVwTW9kaWZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNwZWVkWSkgPj0gTWF0aC5hYnMoc3BlZWRYKSAqIHRoaXMuaW5lcnRpYURlbHRhWCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0WSArPSBNYXRoLmFicygyIC8gKHggKyAwLjU1KSAtIDAuMykgKiBzcGVlZFkgKiAxNSAqIHN0ZXBNb2RpZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBtaXhlZCBlbnZpcm9ubWVudCB3ZSB1c2UgdGhlIGRlZmF1bHQgYmVoYXZpb3VyLiBpLmUuIHRvdWNoc2NyZWVuICsgbW91c2VcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuX25leHRYLCB0aGlzLl9uZXh0WSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3RvdWNoSW5lcnRpYUFuaW1JRCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShpbmVydGlhU3RlcCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3RhcnQgaW5lcnRpYSBhbmQgY29udGludWUgaXQgcmVjdXJzaXZlbHlcbiAgICAgICAgdGhpcy5fdG91Y2hJbmVydGlhQW5pbUlEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGluZXJ0aWFTdGVwKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNhbGNBeGlzQ29vcmRzKHRhcmdldCwgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA8IG1pbikge1xuICAgICAgICAgICAgdGFyZ2V0ID0gbWluO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCA+IG1heCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gbWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zY3JvbGxUbyhkZXN0WCwgZGVzdFkpIHtcbiAgICAgICAgY29uc3QgY3VyUG9zWCA9IHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0O1xuICAgICAgICBjb25zdCBjdXJQb3NZID0gdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcDtcblxuICAgICAgICAvLyBUT0RPIFRyaWdnZXIgc2Nyb2xsaW5nIGV2ZW50P1xuICAgICAgICBjb25zdCBzY3JvbGxlZFggPSB0aGlzLl9zY3JvbGxUb1goZGVzdFgpO1xuICAgICAgICBjb25zdCBzY3JvbGxlZFkgPSB0aGlzLl9zY3JvbGxUb1koZGVzdFkpO1xuXG4gICAgICAgIHJldHVybiB7IHg6IHNjcm9sbGVkWCwgeTogc2Nyb2xsZWRZIH07XG4gICAgfVxuICAgIHByaXZhdGUgX3Njcm9sbFRvWChkZXN0KSB7XG4gICAgICAgIHRoaXMuSWd4U2Nyb2xsSW5lcnRpYVNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ID0gZGVzdDtcbiAgICB9XG4gICAgcHJpdmF0ZSBfc2Nyb2xsVG9ZKGRlc3QpIHtcbiAgICAgICAgdGhpcy5JZ3hTY3JvbGxJbmVydGlhU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCA9IGRlc3Q7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hTY3JvbGxJbmVydGlhRGlyZWN0aXZlXSxcbiAgICBleHBvcnRzOiBbSWd4U2Nyb2xsSW5lcnRpYURpcmVjdGl2ZV0sXG4gICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBJZ3hTY3JvbGxJbmVydGlhTW9kdWxlIHtcbn1cblxuIl19